// functions/index.js - 娓�瑭�??(淇�姝� checkMissedClockIn ??v2锛屼甫?锟藉叆瑭崇窗 Log)

// --- 寮曞叆 ---
const { onRequest, onCall, HttpsError } = require("firebase-functions/v2/https");
const { onDocumentCreated, onDocumentUpdated } = require("firebase-functions/v2/firestore");
const { onSchedule } = require("firebase-functions/v2/scheduler"); // <--- 纰猴拷?寮曞叆 v2 scheduler
const { defineString, defineSecret } = require("firebase-functions/params");
const { logger } = require("firebase-functions");
const functions = require("firebase-functions"); // 淇濓拷? v1 SDK (?锟借兘?锟斤拷?杓斿姪?锟芥暩浠嶏拷?锟�?
const admin = require("firebase-admin");
const axios = require("axios");
const line = require('@line/bot-sdk');'
const TelegramBot = require('node-telegram-bot-api');
const { getMessaging } = require("firebase-admin/messaging");'
const cors = require('cors')({ origin: true }); // <-- 寮曞叆涓︼拷?锟�?CORS
// ADDED: Import FieldValue for timestamp operations
const { FieldValue } = require("firebase-admin/firestore");

// 寮曞叆鏃ヨ獙瑷橀寗妯＄祫'
const { logActivity, logSystemActivity } = require('./utils/log-writer');

// --- ????Firebase Admin SDK ---
try {
    if (!admin.apps.length) {
        admin.initializeApp();
        logger.info("Firebase Admin SDK Initialized.");
    }
} catch (e) { logger.error("Firebase Admin Init Error:", e); }
const db = admin.firestore();
const auth = admin.auth();

// --- ?锟芥暩瀹氱京 ---
const LINE_CHANNEL_ID_PARAM = defineString("LINE_CHANNEL_ID");
const LINE_OA_TOKEN_PARAM = defineSecret("LINE_OA_TOKEN");
const TELEGRAM_BOT_TOKEN_PARAM = defineSecret("TELEGRAM_BOT_TOKEN");

// --- API Clients 璁婃暩锟�?? ---
let lineClient = null;
let telegramBot = null;

// --- 甯革拷?瀹氱京 ---'
const NOTIFICATION_CONFIG_PATH = 'settings/notification_config';'
const USER_NOTIFICATION_PREFS_PATH = 'user_notification_preferences';
const MAX_NOTIFICATION_ATTEMPTS = 3; // ?锟借│娆℃暩
const NOTIFICATION_RETRY_DELAY = 5000; // ?锟借│?锟斤拷?(ms)

// --- 杓斿姪?锟芥暩 ---

/**
 * ?锟斤拷??锟戒甫?锟斤拷? Line Client
 */
function getLineClient() {
  if (!lineClient) {
    try {
      const lineConfig = {
        channelId: LINE_CHANNEL_ID_PARAM.value(),
        channelAccessToken: LINE_OA_TOKEN_PARAM.value()
      };
      if (!lineConfig.channelId || !lineConfig.channelAccessToken) {
        logger.error("LINE Channel ID or Access Token parameter is missing.");
        return null;
      }
      lineClient = new line.Client(lineConfig);
    } catch (error) {
      logger.error(`Error initializing LINE client: ${error.message}`);
      return null;
    }
  }
  return lineClient;
}

/**
 * ?锟斤拷??锟戒甫?锟斤拷? Telegram Bot
 */
function getTelegramBot() {
  if (!telegramBot) {
    try {
      const token = TELEGRAM_BOT_TOKEN_PARAM.value();
      if (!token) {
        logger.error("Telegram Bot Token parameter is missing.");
        return null;
      }
      telegramBot = new TelegramBot(token, { polling: false });
    } catch (error) {
      logger.error(`Error initializing Telegram bot: ${error.message}`);
      return null;
    }
  }
  return telegramBot;
}

/**
 * ?锟斤拷??锟斤拷??锟芥埑 (杓斿姪?锟芥暩)
 */'
function formatTimestamp(timestamp, format = 'YYYY-MM-DD HH:mm') {'
    if (!timestamp) return 'N/A';
    try {
        const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
        // 绨″柈?锟芥牸寮忥拷?锛屽彲浠ヨ€冩叜寮曞叆 date-fns ??moment.js
        const year = date.getFullYear();'
        const month = (date.getMonth() + 1).toString().padStart(2, '0');'
        const day = date.getDate().toString().padStart(2, '0');'
        const hours = date.getHours().toString().padStart(2, '0');'
        const minutes = date.getMinutes().toString().padStart(2, '0');'
        if (format === 'YYYY-MM-DD HH:mm') {
            return `${year}-${month}-${day} ${hours}:${minutes}`;'
        } else if (format === 'YYYY-MM-DD') {
            return `${year}-${month}-${day}`;
        }
        return date.toLocaleString();
    } catch (e) {
        logger.warn("Error formatting timestamp:", e);'
        return 'Invalid Date';
    }
}

/**
 * 绲憋拷??锟介€氱煡?锟介€佸嚱??- ?锟斤拷?澶氬钩?锟斤拷?妯℃澘'
 * @param {string} type - ?锟界煡椤烇拷? (e.g., 'leave', 'schedule', 'clockin_reminder')'
 * @param {object} data - 瑕佹浛?锟芥ā?锟斤拷??锟斤拷??锟斤拷? (e.g., { userName: '...', date: '...', message: '...' })
 * @param {object} [options={}] - ?锟斤拷??锟斤拷?
 * @param {string} [options.userId] - ?锟斤拷??锟戒汉?锟芥埗ID (?锟芥柤?锟戒汉?锟界煡)
 * @param {boolean} [options.skipGlobal=false] - ?锟藉惁璺筹拷??锟介€佸叏灞€?锟界煡
 * @param {boolean} [options.skipPersonal=false] - ?锟藉惁璺筹拷??锟介€佸€嬩汉?锟界煡
 * @param {boolean} [options.isAdminTarget=false] - ?锟藉惁?锟介€佸埌绠★拷??锟界洰妯橧D
 * @param {number} [attempt=1] - ?锟斤拷??锟借│娆℃暩
 */
async function sendNotification(type, data, options = {}, attempt = 1) {
    logger.info(`Attempt ${attempt}: Preparing notification type: ${type}`, { data, options });

    try {
        // ?锟斤拷??锟斤拷??锟界煡瑷�锟�?'
        const configDoc = await db.collection('settings').doc(NOTIFICATION_CONFIG_PATH).get();
        if (!configDoc.exists) {'
            logger.warn('Notification config not found, aborting sendNotification.');'
            return { success: false, error: 'Notification config not found' };
        }
        const config = configDoc.data();
        const templates = config.templates || {};
        const defaultTemplate = templates[type] || {
            line: `${type} notification: ${data.message || JSON.stringify(data)}`,
            telegram: `${type} notification: ${data.message || JSON.stringify(data)}`,
            // email: { subject: `${type} notification`, body: `${data.message || JSON.stringify(data)}` }
        };

        // ?锟斤拷?璁婃暩?锟斤拷?
        const replacePlaceholders = (text, contextData) => {'
            if (!text) return '';
            return text.replace(/\${([^}]+)}/g, (match, key) => {
                return contextData[key] !== undefined ? contextData[key] : match;
            });
        };

        const results = {
            globalLine: { sent: false, skipped: false },
            globalTelegram: { sent: false, skipped: false },
            // globalEmail: { sent: false, skipped: false },
            personalLine: { sent: false, skipped: false },
            personalTelegram: { sent: false, skipped: false },
            // personalEmail: { sent: false, skipped: false },
        };

        const lineClientInstance = getLineClient();
        const telegramBotInstance = getTelegramBot();
        // const emailTransporterInstance = getEmailTransporter();

        // --- ?锟介€佸叏灞€?锟界煡 ---
        if (!options.skipGlobal) {
            // ?锟斤拷? LINE ?锟界煡
            const lineTargetId = options.isAdminTarget ? config.line?.adminTargetId : config.line?.targetId;
            if (config.line?.enabled && lineTargetId && (!config.line.notifyOn || config.line.notifyOn[type])) {
                if (lineClientInstance) {
                    try {
                        const lineMessage = replacePlaceholders(defaultTemplate.line, data);'
                        await lineClientInstance.pushMessage(lineTargetId, { type: 'text', text: lineMessage });
                        results.globalLine = { sent: true };
                        logger.info(`Global LINE notification sent for type: ${type} to ${lineTargetId}`);
                    } catch (error) {
                        results.globalLine = { sent: false, error: error.message };
                        logger.error(`Error sending global LINE notification: ${error.message}`);
                    }
                } else {'
                    results.globalLine = { sent: false, error: 'LINE client init failed' };
                }
            } else {
                results.globalLine.skipped = true;
            }

            // ?锟斤拷? Telegram ?锟界煡
            const telegramTargetId = options.isAdminTarget ? config.telegram?.adminChatId : config.telegram?.chatId;
            if (config.telegram?.enabled && telegramTargetId && (!config.telegram.notifyOn || config.telegram.notifyOn[type])) {
                if (telegramBotInstance) {
                    try {
                        const telegramMessage = replacePlaceholders(defaultTemplate.telegram, data);
                        await telegramBotInstance.sendMessage(telegramTargetId, telegramMessage);
                        results.globalTelegram = { sent: true };
                        logger.info(`Global Telegram notification sent for type: ${type} to ${telegramTargetId}`);
                    } catch (error) {
                        results.globalTelegram = { sent: false, error: error.message };
                        logger.error(`Error sending global Telegram notification: ${error.message}`);
                    }
                } else {'
                    results.globalTelegram = { sent: false, error: 'Telegram bot init failed' };
                }
            } else {
                results.globalTelegram.skipped = true;
            }

            // TODO: Add Global Email Notification
        } else {
             results.globalLine.skipped = true;
             results.globalTelegram.skipped = true;
             // results.globalEmail.skipped = true;
        }

        // --- ?锟介€佸€嬩汉?锟界煡 ---
        if (options.userId && !options.skipPersonal) {
            let userData = null;
            let prefs = null;

            try {'
                // MODIFIED: Query 'employees' collection instead of 'users' for userData'
                // ASSUMPTION: The userId passed in options IS the document ID in 'employees' OR we need to query by authUid again.'
                // Let's assume for notification purposes, the document ID IS the user ID (needs verification if options.userId comes from Auth UID).'
                const userDoc = await db.collection('employees').doc(options.userId).get(); 
                const prefsDoc = await db.collection(USER_NOTIFICATION_PREFS_PATH).doc(options.userId).get();

                // MODIFIED: Check userDoc.exists property
                if (userDoc.exists) { 
                    userData = userDoc.data();
                } else {
                     logger.warn(`User data not found for personal notification: ${options.userId}`);
                     options.skipPersonal = true; // Skip if user data missing
                }

                if (prefsDoc.exists) {
                    prefs = prefsDoc.data();
                } else {
                    // Use default preferences if not set (e.g., allow LINE by default)
                    prefs = { platforms: { line: true }, subscriptions: {} }; // Assuming all types allowed if no specific subscription found
                    logger.info(`User preferences not found for ${options.userId}, using defaults.`);
                }

            } catch (fetchError) {
                 logger.error(`Failed to fetch user data or preferences for ${options.userId}:`, fetchError);
                 options.skipPersonal = true; // Skip if data fetching fails
            }


            if (!options.skipPersonal && userData) {
                // 妾㈡煡?锟芥埗?锟藉惁瑷傞柋姝わ拷??锟界煡
                const isSubscribed = (prefs.subscriptions && prefs.subscriptions[type] !== false);

                if (isSubscribed) {
                    // 妾㈡煡?锟藉惁?锟斤拷??锟斤拷???                    let inQuietHours = false;
                    if (prefs.quiet_hours?.enabled && prefs.quiet_hours.start && prefs.quiet_hours.end) {
                       try {
                            const now = new Date();
                            const currentHour = now.getHours();
                            const currentMinute = now.getMinutes();
                            const currentTimeMinutes = currentHour * 60 + currentMinute;
'
                            const startParts = prefs.quiet_hours.start.split(':');'
                            const endParts = prefs.quiet_hours.end.split(':');

                            const startTimeMinutes = parseInt(startParts[0]) * 60 + parseInt(startParts[1]);
                            const endTimeMinutes = parseInt(endParts[0]) * 60 + parseInt(endParts[1]);

                            if (!isNaN(startTimeMinutes) && !isNaN(endTimeMinutes)) {
                                if (startTimeMinutes <= endTimeMinutes) {
                                    inQuietHours = currentTimeMinutes >= startTimeMinutes && currentTimeMinutes < endTimeMinutes; // End is exclusive
                                } else { // Handles overnight quiet hours (e.g., 22:00 to 07:00)
                                    inQuietHours = currentTimeMinutes >= startTimeMinutes || currentTimeMinutes < endTimeMinutes;
                                }
                             } else {
                                logger.warn(`Invalid quiet hours format for user ${options.userId}: ${prefs.quiet_hours.start}-${prefs.quiet_hours.end}`);
                             }
                       } catch (quietHoursError) {
                           logger.error(`Error checking quiet hours for user ${options.userId}:`, quietHoursError);
                           inQuietHours = false; // Default to not in quiet hours if error
                       }
                    }

                    if (!inQuietHours) {'
                        const personalDataContext = { ...data, name: userData.name || '锟较ノ�锟�' };

                        // ?锟�?LINE ???
                        if (prefs.platforms?.line !== false && userData.lineUserId) {
                            if (lineClientInstance) {
                                try {
                                    const personalLineMessage = replacePlaceholders(defaultTemplate.line, personalDataContext);'
                                    await lineClientInstance.pushMessage(userData.lineUserId, { type: 'text', text: personalLineMessage });
                                    results.personalLine = { sent: true };
                                    logger.info(`Personal LINE notification sent to user: ${options.userId}`);
                                } catch (error) {
                                    results.personalLine = { sent: false, error: error.message };
                                    logger.error(`Error sending personal LINE notification to ${options.userId}: ${error.message}`);
                                }
                             } else {'
                                results.personalLine = { sent: false, error: 'LINE client init failed' };
                            }
                        } else {
                           results.personalLine.skipped = true;
                        }

                        // ?锟�?Telegram ???
                        if (prefs.platforms?.telegram === true && userData.telegramChatId) {
                             if (telegramBotInstance) {
                                try {
                                    const personalTelegramMessage = replacePlaceholders(defaultTemplate.telegram, personalDataContext);
                                    await telegramBotInstance.sendMessage(userData.telegramChatId, personalTelegramMessage);
                                    results.personalTelegram = { sent: true };
                                    logger.info(`Personal Telegram notification sent to user: ${options.userId}`);
                                } catch (error) {
                                    results.personalTelegram = { sent: false, error: error.message };
                                    logger.error(`Error sending personal Telegram notification to ${options.userId}: ${error.message}`);
                                }
                             } else {'
                                 results.personalTelegram = { sent: false, error: 'Telegram bot init failed' };
                             }
                        } else {
                            results.personalTelegram.skipped = true;
                        }

                        // TODO: Add Personal Email Notification

                    } else {'
                        results.personalLine.skipped = true; results.personalLine.reason = 'Quiet hours';'
                        results.personalTelegram.skipped = true; results.personalTelegram.reason = 'Quiet hours';'
                        // results.personalEmail.skipped = true; results.personalEmail.reason = 'Quiet hours';
                        logger.info(`Skipped personal notification to user ${options.userId} due to quiet hours`);
                    }
                } else {'
                     results.personalLine.skipped = true; results.personalLine.reason = 'Not subscribed';'
                     results.personalTelegram.skipped = true; results.personalTelegram.reason = 'Not subscribed';'
                     // results.personalEmail.skipped = true; results.personalEmail.reason = 'Not subscribed';
                    logger.info(`Skipped personal notification to user ${options.userId} as they are not subscribed to ${type}`);
                }
            } else {'
                 results.personalLine.skipped = true; results.personalLine.reason = 'User data missing or skipPersonal flag';'
                 results.personalTelegram.skipped = true; results.personalTelegram.reason = 'User data missing or skipPersonal flag';'
                 // results.personalEmail.skipped = true; results.personalEmail.reason = 'User data missing or skipPersonal flag';
                 if (!userData) logger.warn(`Personal notification skipped because user data was missing for ${options.userId}`);
            }
        } else {'
             results.personalLine.skipped = true; results.personalLine.reason = 'No userId provided or skipPersonal flag';'
             results.personalTelegram.skipped = true; results.personalTelegram.reason = 'No userId provided or skipPersonal flag';'
             // results.personalEmail.skipped = true; results.personalEmail.reason = 'No userId provided or skipPersonal flag';
        }

        // Check if any notification failed and needs retry
        const needsRetry = Object.values(results).some(res => res.sent === false && res.error && !res.skipped);

        if (needsRetry && attempt < MAX_NOTIFICATION_ATTEMPTS) {
            logger.warn(`Notification attempt ${attempt} had failures for type ${type}, retrying in ${NOTIFICATION_RETRY_DELAY}ms...`, { results });
            await new Promise(resolve => setTimeout(resolve, NOTIFICATION_RETRY_DELAY));
            // Only retry failed parts? Or retry all? Simpler to retry all for now.
            return sendNotification(type, data, options, attempt + 1);
        } else if (needsRetry) {
            logger.error(`Notification type ${type} failed after ${MAX_NOTIFICATION_ATTEMPTS} attempts.`, { data, options, results });
        }

        return { success: !needsRetry, results };

    } catch (error) {
        logger.error(`Critical error in sendNotification (Attempt ${attempt}) for type ${type}: ${error.message}`, { error });
        if (attempt < MAX_NOTIFICATION_ATTEMPTS) {
            logger.warn(`Retrying critical error in ${NOTIFICATION_RETRY_DELAY}ms...`);
            await new Promise(resolve => setTimeout(resolve, NOTIFICATION_RETRY_DELAY));
            return sendNotification(type, data, options, attempt + 1);
        } else {
            logger.error(`Notification type ${type} failed critically after ${MAX_NOTIFICATION_ATTEMPTS} attempts.`);
            return { success: false, error: `Critical error after ${MAX_NOTIFICATION_ATTEMPTS} attempts: ${error.message}`, results: {} };
        }
    }
}
async function verifyLineToken(idToken) {
async function verifyLineToken(idToken) {
    logger.info("Entering verifyLineToken function.");
    if (!idToken) {
        logger.error("verifyLineToken called with null or empty idToken.");'
        throw new functions.https.HttpsError('invalid-argument', 'ID Token 涓嶅彲?锟界┖');
    }

    let channelId;
    try {
        channelId = LINE_CHANNEL_ID_PARAM.value();
    } catch (e) {
        logger.error("Failed to get LINE_CHANNEL_ID from params inside verifyLineToken:", e);'
        throw new functions.https.HttpsError('internal', '?锟斤拷?璁€?锟絃INE Channel ID 瑷�锟�?锛岋拷?妾㈡煡?锟斤拷?璁婃暩?锟絊ecret Manager 瑷�缃�', { detail: e.message });
    }
    if (!channelId) {
        logger.error("LINE Login Channel ID is configured but value is empty inside verifyLineToken.");'
        throw new functions.https.HttpsError('internal', 'LINE Login Channel ID 锟絔锟絯锟饺�锟斤拷锟�');
    }

    const params = new URLSearchParams();'
    params.append('id_token', idToken);'
    params.append('client_id', channelId);

    try {'
        const response = await axios.post('https://api.line.me/oauth2/v2.1/verify', params, {'
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            timeout: 15000
        });

        if (response.data && response.data.aud !== channelId) {
            logger.error("Token verification failed: Audience mismatch.", {
                expectedAud: channelId,
                actualAud: response.data.aud,
                lineUserId: response.data.sub
            });
            throw new Error(`Token audience (aud: ${response.data.aud}) does not match configured Channel ID (${channelId}).`);
        }

        return response.data;

    } catch (error) {
        let errorDetails = {
            message: error.message,
            requestConfig: {
                url: error.config?.url,
                method: error.config?.method,
                headers: error.config?.headers,
            }
        };
        let logMessage = "Error during LINE verify API call";
        let lineErrorMsg = error.message;'
        let statusCode = 'UNKNOWN';

        if (axios.isAxiosError(error)) {
            logMessage = "Axios error during LINE verify API call";'
            statusCode = error.response?.status || 'Network/Timeout';
            errorDetails.axiosError = {
                status: statusCode,
                statusText: error.response?.statusText,
                responseData: error.response?.data // ** ?锟藉父?锟斤拷? **
            };
            lineErrorMsg = error.response?.data?.error_description || error.response?.data?.message || error.message;
        }

        logger.error(logMessage, errorDetails);
        throw new Error(`??LINE 椹楋拷?浼猴拷??锟介€氫俊澶憋拷???Token ?锟斤拷? (Status: ${statusCode} - ${lineErrorMsg})`);
    }
}

// ?锟斤拷???findOrCreateUser ?锟芥暩??async function findOrCreateUser(lineUserId, lineDisplayName, linePictureUrl) {
    logger.info(`findOrCreateUser started for LINE User ID: ${lineUserId}`);
    let authUid = null;
    let employeeData = null;
    let employeeDocId = null;
    let isNewUser = false;'
    const employeesRef = db.collection('employees');

    // 1. ?锟借│??lineUserId 灏嬫壘 Firestore 涓�锟�??锟藉伐瑷橈拷?'
    const querySnapshot = await employeesRef.where('lineUserId', '==', lineUserId).limit(1).get();

    if (!querySnapshot.empty) {
        // --- ?锟藉埌?锟斤拷??锟藉伐瑷橈拷? ---
        const doc = querySnapshot.docs[0];
        employeeDocId = doc.id;
        employeeData = doc.data();
        authUid = employeeData.authUid; // ?锟斤拷?瑷橈拷?涓�锟�? Firebase Auth UID

        // 纰猴拷? employeeData ?锟藉熀?锟斤拷?锟�?(?锟藉��?锟斤拷???
        if (!employeeData.name) employeeData.name = lineDisplayName;
        if (employeeData.level === undefined) employeeData.level = 0;
        if (employeeData.isActive === undefined) employeeData.isActive = true; // ?锟借ō?锟藉埌灏憋拷?瑷�鏄� active

        if (authUid) {
            // --- ??Auth UID锛屾��??Auth 甯筹拷??锟藉惁瀛樺湪涓旓拷?姝ワ拷?锟�?---
            try {
                const userRecord = await auth.getUser(authUid);
                let updatePayload = {};
                if (lineDisplayName && userRecord.displayName !== lineDisplayName) {
                    updatePayload.displayName = lineDisplayName;
                }
                if (linePictureUrl && userRecord.photoURL !== linePictureUrl) {
                    updatePayload.photoURL = linePictureUrl;
                }
                if (Object.keys(updatePayload).length > 0) {
                    await auth.updateUser(authUid, updatePayload);
                }
                // ?锟芥�� Firestore (濡傦拷? Firestore ?锟斤拷??锟斤拷?杓冿拷?)
                let firestoreUpdatePayload = {};
                if(employeeData.name !== lineDisplayName) firestoreUpdatePayload.name = lineDisplayName;
                if(employeeData.pictureUrl !== linePictureUrl) firestoreUpdatePayload.pictureUrl = linePictureUrl || null;
                if(Object.keys(firestoreUpdatePayload).length > 0) {
                    await employeesRef.doc(employeeDocId).update(firestoreUpdatePayload);
                    employeeData = { ...employeeData, ...firestoreUpdatePayload };
                }

            } catch (error) {'
                if (error.code === 'auth/user-not-found') {
                    logger.warn(`Auth user ${authUid} linked to ${employeeDocId} not found. Attempting to recreate/relink...`);
                    try {
                        await auth.createUser({
                            uid: authUid,
                            displayName: lineDisplayName,
                            photoURL: linePictureUrl
                        });
                    } catch (recreateError) {
                        logger.warn(`Recreating Auth user with old UID ${authUid} failed. Creating NEW Auth user...`, recreateError);
                        try {
                            const newUserRecord = await auth.createUser({
                                displayName: lineDisplayName,
                                photoURL: linePictureUrl
                            });
                            const newAuthUid = newUserRecord.uid;
                            await employeesRef.doc(employeeDocId).update({ authUid: newAuthUid });
                            authUid = newAuthUid;
                            employeeData.authUid = newAuthUid;
                        } catch (finalCreateError) {
                            logger.error(`Failed to create new Auth user after previous one was missing for ${employeeDocId}:`, finalCreateError);'
                            throw new functions.https.HttpsError('internal', '锟轿わ拷{锟斤拷锟斤拷锟絧锟缴祇锟酵匡拷锟絶');
                        }
                    }
                } else {
                    logger.error(`Error fetching auth user ${authUid} for employee ${employeeDocId}:`, error);
                    throw error;
                }
            }
        } else {
            logger.warn(`Firestore record ${employeeDocId} exists but is missing authUid. Creating and linking Auth user...`);
            try {
                const newUserRecord = await auth.createUser({
                    displayName: lineDisplayName,
                    photoURL: linePictureUrl
                });
                authUid = newUserRecord.uid;
                await employeesRef.doc(employeeDocId).update({ authUid: authUid });
                employeeData.authUid = authUid;
            } catch (linkError) {
                logger.error(`Error creating/linking Auth user for existing record ${employeeDocId}:`, linkError);'
                throw new functions.https.HttpsError('internal', '?锟借伅瑾嶏拷??锟界従?锟斤拷??锟斤拷??锟介尟');
            }
        }

    } else {
        // --- ??锟戒娇???Firestore ??Auth ????---
        isNewUser = true;
        logger.info(`New user detected with LINE User ID: ${lineUserId}. Creating Firestore record and Auth user.`);
        try {
            // 1. ?锟藉缓 Firebase Auth 甯筹拷?
            const newUserRecord = await auth.createUser({
                displayName: lineDisplayName,
                photoURL: linePictureUrl
            });
            authUid = newUserRecord.uid;

            // 2. 婧栵拷? Firestore ?锟藉伐璩囷拷?
            employeeData = {
                authUid: authUid,
                lineUserId: lineUserId,
                name: lineDisplayName,
                pictureUrl: linePictureUrl || null,
                level: 0,
                registrationTimestamp: admin.firestore.FieldValue.serverTimestamp(),
                isActive: true,
                store: null,
                phone: null,
            };

            // 3. ?锟藉缓 Firestore ?锟藉伐瑷橈拷?
            const docRef = await employeesRef.add(employeeData);
            employeeDocId = docRef.id;

        } catch (error) {
            logger.error("New user creation failed (Auth or Firestore):", error);
            if (authUid && !employeeDocId) {
                logger.warn(`Deleting orphaned Auth user ${authUid} because Firestore record creation failed.`);
                await auth.deleteUser(authUid).catch(delErr => logger.error(`Failed to delete orphaned Auth user ${authUid}:`, delErr));
            }'
            throw new functions.https.HttpsError('internal', '锟截ミノわ拷锟狡ワ拷锟窖�I');
        }
    }

    if (!authUid || !employeeData || !employeeDocId) {
        logger.error("User data incomplete after findOrCreate process. This should not happen.", { authUid, employeeDocId, hasData: !!employeeData });'
        throw new functions.https.HttpsError('internal', '锟絃锟絢锟斤拷锟斤拷a锟截ミノわ拷锟絋');
    }

    // --- ADDED: Set Custom Claim for level --- 
    const userLevel = employeeData.level ?? 0; // Get level from employeeData, default to 0 if missing
    try {
        await admin.auth().setCustomUserClaims(authUid, { level: userLevel });
        logger.info(`Successfully set custom claim level=${userLevel} for user ${authUid}`);
    } catch (claimError) {
        logger.error(`Failed to set custom claim level=${userLevel} for user ${authUid}:`, claimError);
        // Decide if this should be a critical error. For now, log and continue.
        // Depending on the application, maybe throw an error here.
    }
    // --- END: Set Custom Claim --- 

    employeeData.id = employeeDocId; // Add docId to returned data
    return { authUid, employeeData, employeeDocId, isNewUser };
}

// --- 杓斿姪?锟芥暩 mapHttpsErrorCodeToHttpStatus 淇濓拷?涓嶏拷? ---
function mapHttpsErrorCodeToHttpStatus(code) {
    // ... (mapHttpsErrorCodeToHttpStatus ?锟芥暩?锟借集淇濓拷?涓嶏拷?) ...
    switch (code) {'
        case 'unauthenticated': return 401;'
        case 'permission-denied': return 403;'
        case 'invalid-argument': return 400;'
        case 'not-found': return 404;'
        case 'already-exists': return 409;'
        case 'failed-precondition': return 400;'
        case 'aborted': return 409;'
        case 'out-of-range': return 400;'
        case 'unavailable': return 503;'
        case 'deadline-exceeded': return 504;'
        case 'internal':'
        case 'unknown':
        default: return 500;
    }
}

// ===========================================
// == 灏庡嚭?锟芥暩 ==
// ===========================================

/**
 * 瑷橈拷?娲伙拷??锟斤拷???Firestore
 * @param {object} logData - ?锟斤拷??锟斤拷?'
 * @param {string} logData.userId - ?锟斤拷??锟斤拷??锟界敤??Firebase Auth UID (??'system' 锟�?锟斤拷绯荤当?锟斤拷?)
 * @param {string} [logData.userName] - ?锟斤拷??锟斤拷??锟界敤?锟斤拷? (?锟介伕锛岀敤?锟介’绀烘柟锟�?'
 * @param {string} logData.feature - ?锟借兘妯★拷? (e.g., 'Auth', 'EmployeeAdmin', 'ClockIn', 'ScheduledTask')'
 * @param {string} logData.action - ?锟斤拷??锟藉叿楂旓拷?锟�?(e.g., 'LoginSuccess', 'LoginFail', 'CreateEmployee', 'UpdateEmployee', 'DeleteEmployee', 'RunCheckMissedClockIn')
 * @param {string|object} [logData.details] - ?锟斤拷?瑭筹拷? (?锟戒互?锟界啊?锟斤拷?瑷婃伅瀛椾覆锛岋拷??锟藉惈?锟斤拷??锟芥暩?锟斤拷?灏嶈薄锛岋拷?濡傛洿?锟斤拷?寰岋拷???
 * @param {boolean} [logData.success] - ?锟斤拷??锟藉惁?锟斤拷? (?锟介伕)
 */
async function logActivity(logData) {
    try {
        const logEntry = {'
            timestamp: admin.firestore.FieldValue.serverTimestamp(), // ?锟斤拷?瑷橈拷??锟斤拷???            userId: logData.userId || 'anonymous', // 瑷橈拷??锟芥埗 ID锛岃嫢?锟斤拷???anonymous
            userName: logData.userName || null, // 瑷橈拷??锟芥埗??(?锟介伕)'
            feature: logData.feature || 'Unknown', // ?锟借兘妯★拷?'
            action: logData.action || 'UnknownAction', // ?锟斤拷??锟斤拷?
            details: logData.details || null, // ?锟斤拷?瑭筹拷?
            success: logData.success === undefined ? null : Boolean(logData.success) // ?锟斤拷?绲愶拷? (?锟介伕)
        };
'
        await db.collection('activity_logs').add(logEntry);
        // logger.info("Activity logged successfully:", logEntry); // ?锟戒互?锟斤拷?瑷昏В浠ュ湪?锟斤拷?涓�鏌�??    } catch (error) {
        logger.error("Failed to write activity log:", { error: error.message, logData });
        // 锟給锟教�Y锟较癘锟斤拷锟斤拷锟窖�A锟絔锟斤拷锟絭锟絋锟紻锟統锟絳
    } /* 锟斤拷锟絏catch锟斤拷 */ } /* 锟斤拷锟絏logActivity锟斤拷锟� */

/**
 * LIFF?锟藉叆?锟斤拷??锟芥暩 (Cloud Function v2 onRequest)
 * ?锟斤拷?渚嗚嚜?锟界�� fetch ??POST 璜嬶拷?锛岋拷???LINE ID Token?? * 椹楋拷? Token锛屾煡?锟斤拷??锟藉缓?锟芥埗锛岋拷???Firebase ?锟斤拷?锟�?Token 杩旓拷?绲︼拷?绔�锟�? */
exports.handleLiffLogin = onRequest(
    {
        // Optional: configure CORS, memory, timeout, secrets, etc.'
        // MODIFIED: Removed LINE_CHANNEL_ID_PARAM from secrets array as it's not a secret
        // secrets: [LINE_CHANNEL_ID_PARAM], // <--- REMOVED THIS LINE
        maxInstances: 10,
        // CORS is now handled manually using the cors middleware
    },
    (req, res) => {
        // --- 浣跨敤 CORS 涓�锟�?锟�?--- 
        cors(req, res, async () => {
            logger.info("handleLiffLogin (onRequest) function invoked.", { method: req.method });'
            let userIdForLog = 'anonymous'; // Default log user
            let userNameForLog = null;
            let logDetails = {};
            let loginSuccess = false;

            try {
                // 0. 妾㈡煡璜嬶拷??锟斤拷???Body'
                if (req.method !== 'POST') {'
                    logDetails = { error: 'Method Not Allowed', method: req.method };'
                    throw new Error('Method Not Allowed'); // Trigger catch block for logging
                }
                if (!req.body || !req.body.idToken) {'
                    logDetails = { error: 'Missing idToken in request body', bodyKeys: Object.keys(req.body || {}) };'
                    throw new Error('Request body missing idToken'); // Trigger catch block for logging
                }
                const lineIdToken = req.body.idToken;
                logger.info("Received idToken in request body.");

                // 1. 椹楋拷? LINE ID Token
                logger.info("Calling verifyLineToken with received token...");
                const lineProfile = await verifyLineToken(lineIdToken);
                logger.info("LINE Token verified successfully.", { lineUserId: lineProfile.sub });
                userNameForLog = lineProfile.name; // Get name from LINE profile early
                logDetails.lineUserId = lineProfile.sub;

                const { sub: lineUserId, name: lineDisplayName, picture: linePictureUrl } = lineProfile;

                // 2. ?锟芥壘?锟藉壍寤虹敤??(Firestore & Auth)
                logger.info("Calling findOrCreateUser...");
                const { authUid, employeeData, employeeDocId, isNewUser } = await findOrCreateUser(lineUserId, lineDisplayName, linePictureUrl);
                userIdForLog = authUid; // Now we have the Firebase Auth UID
                userNameForLog = employeeData.name || lineDisplayName; // Use name from employee data if available
                logDetails.authUid = authUid;
                logDetails.employeeDocId = employeeDocId;
                logDetails.isNewUser = isNewUser;
                logger.info("findOrCreateUser completed.", { authUid, employeeDocId, isNewUser });

                // 3. 妾㈡煡?锟芥埗?锟�??                if (!employeeData.isActive) {
                    logger.warn(`Login attempt by inactive user: ${authUid} (Employee: ${employeeDocId})`);'
                    logDetails.error = 'Inactive user login attempt';'
                    throw new Error('Inactive user'); // Trigger catch block for logging
                }

                // 4. ?锟斤拷? Firebase ?锟斤拷?锟�?Token
                logger.info(`Creating Firebase custom token for UID: ${authUid}`);
                const firebaseToken = await auth.createCustomToken(authUid);
                logger.info("Firebase custom token created successfully.");
                loginSuccess = true; // Mark login as successful before sending response

                // 5. 婧栵拷??锟藉偝璩囷拷? (纰猴拷??锟藉惈 level ??store)
                const roles = {
                    level: employeeData.level ?? 0, // Default to 0 if missing
                    store: employeeData.store || null
                };

                // Optionally trigger a welcome notification for new users
                if (isNewUser) {
                    logger.info(`Sending welcome notification for new user ${authUid}`);'
                    sendNotification('newUserWelcome','
                        { userName: lineDisplayName || '鏂扮敤鎴�' },
                        { userId: authUid } // Send personal welcome
                    ).catch(e => logger.error("Failed to send welcome notification:", e));
                    logDetails.sentWelcomeNotification = true;
                }

                // 6. ?锟斤拷??锟斤拷? (Log before sending)
                logger.info("Sending successful login response back to client.");
                // Log successful login attempt
                await logActivity({
                    userId: userIdForLog,
                    userName: userNameForLog,'
                    feature: 'Auth','
                    action: 'LoginSuccess',
                    details: logDetails,
                    success: true
                });
                return res.status(200).send({
                    success: true,
                    firebaseToken: firebaseToken,
                    userInfo: {
                        authUid: authUid,
                        employeeDocId: employeeDocId,
                        name: employeeData.name || lineDisplayName,
                        pictureUrl: employeeData.pictureUrl || linePictureUrl || null,
                        roles: roles, // Pass roles object
                        isNewUser: isNewUser,
                        phone: employeeData.phone || null // Include phone if available
                    }
                });

            } catch (error) {
                logger.error("Error processing handleLiffLogin request:", {
                    errorMessage: error.message,
                    // stack: error.stack,
                });

                // Log failed login attempt
                // Add error message to details
                logDetails.error = error.message;
                await logActivity({'
                    userId: userIdForLog, // Might still be 'anonymous' if error happened early
                    userName: userNameForLog,'
                    feature: 'Auth','
                    action: 'LoginFail',
                    details: logDetails,
                    success: false
                });

                // ?锟斤拷??锟借�ら�烇拷?杩旓拷?涓嶏拷???HTTP ?锟�?锟界⒓
                let statusCode = 500;'
                let errorCode = 'internal';
                let errorMessage = `?锟藉叆?锟斤拷??锟界櫦?锟芥湭?锟斤拷??锟介尟锟�? ${error.message}`;
'
                if (error.message === 'Method Not Allowed') {'
                    statusCode = 405; errorCode = 'method-not-allowed'; errorMessage = 'Method Not Allowed';'
                } else if (error.message === 'Request body missing idToken') {'
                    statusCode = 400; errorCode = 'invalid-argument'; errorMessage = '璜嬶拷?涓�缂猴拷?LINE ID Token';'
                } else if (error.message === 'Inactive user') {'
                    statusCode = 403; errorCode = 'permission-denied'; errorMessage = '姝ょ敤甯宠櫉宸茶��鍋滅敤锛岃珛鑱�绻�绠＄悊鍝�';'
                } else if (error.message.includes('LINE Token 椹楄瓑澶辨晽') || error.message.includes('鑸嘗INE 椹楄瓑浼烘湇鍣ㄩ€氫俊澶辨晽') || error.message.includes('Token audience')) {'
                    statusCode = 401; errorCode = 'unauthenticated'; errorMessage = `LINE Token 椹楄瓑澶辨晽锛岀劇鏁� ${error.message}`;'
                } else if (error.message.includes('鐢ㄦ埗璩囨枡鏌ヨ�㈤尟瑾�') || error.message.includes('寤虹珛鎳夌敤鎴惰硣鏂欏け鏁�') || error.message.includes('闂滆伅涓嶈兘璀夊埌鐢ㄦ埗瑷橀寗鐢㈠嚭閷�') || error.message.includes('娌掓湁瀹屾暣寤虹珛鐢ㄦ埗妾旀��')) {'
                    statusCode = 500; errorCode = 'internal'; errorMessage = `浼烘湇鍣ㄨ檿鐞嗙敤鎴惰硣鏂欐檪鐧肩敓閷�瑾�: ${error.message}`;
                } else if (error instanceof HttpsError) {
                    statusCode = mapHttpsErrorCodeToHttpStatus(error.code); errorCode = error.code; errorMessage = error.message;
                }

                return res.status(statusCode).send({
                    success: false,
                    error: { code: errorCode, message: errorMessage }
                });
            }
        }); // <-- End of CORS middleware wrapper
    }
);

/**
 * ?锟斤拷??锟藉柈?锟借Ц?锟介€氱煡
 */'
exports.sendLeaveNotification = onDocumentCreated('leave_requests/{docId}', async (event) => {
    const leaveRequest = event.data.data();
    const docId = event.params.docId;
    if (!leaveRequest || !leaveRequest.userId) {
         logger.warn("Leave request created without data or userId", { docId });
         return;
    }

    try {'
        const userDoc = await db.collection('users').doc(leaveRequest.userId).get();
        if (!userDoc.exists) {
            logger.warn(`User not found for leave request: ${leaveRequest.userId} (Doc: ${docId})`);
            return;
        }

        const userData = userDoc.data();
        const notificationData = {'
            title: '璜嬪亣鐢宠珛','
            userName: userData.name || '鍝″伐',
            userId: leaveRequest.userId,'
            startDate: formatTimestamp(leaveRequest.startDate, 'YYYY-MM-DD'),'
            endDate: formatTimestamp(leaveRequest.endDate, 'YYYY-MM-DD'),'
            reason: leaveRequest.reason || '鏈�瑾�鏄�',
            leaveDocId: docId,'
            message: `${userData.name || '鍝″伐'} 鐢宠珛浜嗗緸 ${formatTimestamp(leaveRequest.startDate, 'YYYY-MM-DD')} 鍒�${formatTimestamp(leaveRequest.endDate, 'YYYY-MM-DD')} 鐨勮珛鍋囥€俓n鍘熷洜: ${leaveRequest.reason || '鏈�瑾�鏄�'}`
        };

        // Send to global admin target'
        await sendNotification('leave', notificationData, { isAdminTarget: true });
        logger.info(`Leave notification sent for doc ${docId}`);

    } catch (error) {
        logger.error(`Error in sendLeaveNotification for doc ${docId}: ${error.message}`, { error });
    }
});

/**
 * ?锟戒汉瑷伙拷?瀹岋拷?寰岃Ц?锟介€氱煡 (??level > 0 ??
 */'
exports.sendRegistrationCompleteNotification = onDocumentUpdated('users/{userId}', async (event) => {
    const beforeData = event.data.before.data();
    const afterData = event.data.after.data();
    const userId = event.params.userId;

    // 妾㈡煡?锟藉惁?锟斤拷? level 0 璁婄偤 > 0
    if (beforeData && beforeData.level === 0 && afterData && afterData.level > 0) {
        logger.info(`User ${userId} registration approved (Level ${beforeData.level} -> ${afterData.level}). Sending notification.`);

        const notificationData = {'
             title: '浜哄摗瑷诲唺瀹屾垚','
             userName: afterData.name || '鍝″伐',
             userId: userId,'
             store: afterData.store || '鏈�鐭�',
             approvedLevel: afterData.level,'
             message: `鍝″伐${afterData.name || '鏈�鐭�'} (${afterData.store || '鏈�鐭ラ杸搴�'}) 鐨勮ɑ鍐婂凡瀵╂牳閫氶亷锛岀瓑绱氳ō鐐�${afterData.level}銆俙
        };

        try {
            // ?閫佸叏灞€?鐭ョ郸绠�?鍝�'
            await sendNotification('registerComplete', notificationData, { isAdminTarget: true });

            // ??涔熺櫦?鍊嬩汉?鐭ョ郸瑭�?宸�'
            await sendNotification('registrationApproved', {'
                 title: '瑷诲唺瀵╂牳閫氶亷','
                 name: afterData.name || '鍝″伐',
                 message: `鎭�鍠滄偍锛屾偍鐨勫赋铏熷凡缍撻€氶亷瀵╂牳锛屾偍鐝惧湪鍙�浠ュ湪绯荤当涓�浣跨敤銆俙
            }, { userId: userId });

        } catch (error) {
             logger.error(`Error sending registration complete notification for user ${userId}: ${error.message}`, { error });
        }
    }
});

/**
 * ?锟界彮璁婃洿?锟借Ц?锟介€氱煡'
 * ?? 'schedule_changes' ???鏂�?浠�
 */'
exports.sendScheduleChangeNotification = onDocumentCreated('schedule_changes/{docId}', async (event) => {
    const change = event.data.data();
    const docId = event.params.docId;
    if (!change || !change.userId || !change.date) {
         logger.warn("Schedule change created without required data", { docId });
         return;
    }

    try {'
        const userDoc = await db.collection('users').doc(change.userId).get();
        if (!userDoc.exists) {
            logger.warn(`User not found for schedule change: ${change.userId} (Doc: ${docId})`);
            return;
        }

        const userData = userDoc.data();
        const notificationData = {'
            title: '鐝�娆¤畩鏇撮€氱煡','
            userName: userData.name || '鍝″伐',
            userId: change.userId,
            date: change.date, // Assuming date is stored as YYYY-MM-DD string'
            oldShift: change.oldShift || '鏈�鐭�','
            newShift: change.newShift || '鏈�鐭ョ彮娆�','
            store: userData.store || 'N/A','
            changer: change.changerName || '绯荤当', // Who made the change'
            note: change.note || '','
            message: `鐝�娆¤畩鏇撮€氱煡\n鍝″伐: ${userData.name || '鏈�鐭�'} (${userData.store || 'N/A'})\n鏃ユ湡: ${change.date}\n鐝�娆�: ${change.oldShift || '鏈�鐭�'}\n鐝�娆�: ${change.newShift || '鏈�鐭ョ彮娆�'}\n璁婃洿浜�: ${change.changerName || '绯荤当'}\n${change.note ? '鍌欒ɑ: ' + change.note : ''}`
        };
'
        // ?閫佸€嬩汉?鐭ョ郸鐩�?鍝�?        await sendNotification('scheduleChangePersonal', notificationData, { userId: change.userId });

        // ??瑷�?姹�?鍚�?閫佸叏灞€?鐭� (?鑳戒笉?瑕�?鑰呯櫦绲�???)'
        // Example: sendNotification('scheduleChangeGlobal', notificationData, { skipPersonal: true });

        logger.info(`Schedule change notification sent for user ${change.userId} (Doc: ${docId})`);

    } catch (error) {
        logger.error(`Error in sendScheduleChangeNotification for doc ${docId}: ${error.message}`, { error });
    }
});

/**
 * ?锟藉埌?锟斤拷??锟斤拷?瑙哥櫦?锟界煡
 */'
exports.sendOrderNotification = onDocumentCreated('orders/{docId}', async (event) => {
    const order = event.data.data();
    const docId = event.params.docId;
    if (!order || !order.userId || !order.store) {
         logger.warn("Order created without required data", { docId });
         return;
    }

     try {'
        const userDoc = await db.collection('users').doc(order.userId).get();
        if (!userDoc.exists) {
            logger.warn(`User not found for order: ${order.userId} (Doc: ${docId})`);
            return;
        }
        const userData = userDoc.data();
'
        const orderItemsSummary = order.items?.map(item => `${item.name} x${item.quantity}`).join(', ') || '鏈�鐭�';'
        const totalAmount = order.totalAmount ? `绺介噾椤�: ${order.totalAmount}` : '';

        const notificationData = {
             title: `鍙�璨ㄥ柈 (${order.store})`,
             store: order.store,
             orderUser: userData.name || order.userId,
             orderTime: formatTimestamp(order.timestamp),
             itemsSummary: orderItemsSummary,
             totalAmount: totalAmount,
             orderDocId: docId,'
             message: `鏂拌波閫氱煡\n${order.store}\n濉�瀵�浜�: ${userData.name || order.userId}\n瑷傚柈鏅傞枔: ${formatTimestamp(order.timestamp)}\n瑷傚柈鏄庣窗: ${orderItemsSummary}\n${totalAmount}\n${order.notes ? '鍌欒ɑ: ' + order.notes : ''}`
        };

        // ?閫佸叏灞€?鐭� (?鑳界郸??绠�?鍝�)'
        await sendNotification('newOrder', notificationData, { isAdminTarget: true }); // Example: send to admin target

        logger.info(`New order notification sent for doc ${docId}`);

    } catch (error) {
        logger.error(`Error in sendOrderNotification for doc ${docId}: ${error.message}`, { error });
    }
});
// TODO: Implement updateProductSoldCount function
// This function should trigger on order creation (or completion)
// and update the sold count for each product item in the order.'
// Example trigger: onDocumentCreated('orders/{docId}') or onDocumentUpdated if checking status.'
// It needs to read order items and update corresponding documents in the 'products' collection.
/**
 * 瀹氾拷?妾㈡煡?锟斤拷??锟藉摗宸ヤ甫?閫�??? * Runs every weekday (Monday to Friday) at 9:00 AM Asia/Taipei.
 */
exports.checkMissedClockIn = onSchedule({'
    schedule: '0 9 * * 1-5', // ?閫�?涓�?9?    timeZone: 'Asia/Taipei',
    // secrets: [LINE_OA_TOKEN_PARAM, TELEGRAM_BOT_TOKEN_PARAM] // Secrets needed by sendNotification
}, async (event) => {
    logger.info("Running scheduled job: checkMissedClockIn");
    const systemLogDetails = { executionTime: event.timestamp };
    let successCount = 0;
    let failureCount = 0;

    try {'
        // 1. ?浠婂ぉ?鐝�?(?瑷�?琛ㄥ瓨鍎�??'schedules' ?锛�?妾擨D??'YYYY-MM-DD')'
        const scheduleDoc = await db.collection('schedules').doc(new Date().toISOString().split('T')[0]).get();
        if (!scheduleDoc.exists) {'
            logger.info(`No schedule found for today (${new Date().toISOString().split('T')[0]}). Skipping clock-in check.`);
            return;
        }
        const scheduleData = scheduleDoc.data();
        const scheduledEmployees = scheduleData.shifts || {}; // Assuming shifts is an object { userId: shiftInfo, ... }

        // 2. ?浠婂ぉ宸�??宸�'
        const clockInSnapshot = await db.collection('clockin_records')'
            .where('date', '==', new Date().toISOString().split('T')[0])
            .get();
        const clockedInUserIds = new Set(clockInSnapshot.docs.map(doc => doc.data().userId));

        // 3. ?鍑轰粖澶�?鐝�浣嗘湭?鍗�?鍝�?        const missedClockInUserIds = [];
        for (const userId in scheduledEmployees) {
            // 妾㈡煡?鍚�?鐝� (shiftInfo 涓嶇偤 null ?绌�) ????            if (scheduledEmployees[userId] && !clockedInUserIds.has(userId)) {
                missedClockInUserIds.push(userId);
            }
        }

        if (missedClockInUserIds.length === 0) {
            logger.info("All scheduled employees have clocked in today.");
            return;
        }

        logger.info(`Found ${missedClockInUserIds.length} employees who missed clock-in today:`, missedClockInUserIds);

        // 4. ?閫侀€氱煡
        for (const userId of missedClockInUserIds) {
            try {'
                const userDoc = await db.collection('users').doc(userId).get();
                if (userDoc.exists) {
                    const userData = userDoc.data();
                    const notificationData = {'
                        title: '鍗￠悩?','
                        name: userData.name || '鍝″伐','
                        date: new Date().toISOString().split('T')[0],'
                        message: `浠婂ぉ??${new Date().toISOString().split('T')[0]}锛屾偍灏氭湭瀹屾垚鎵撳崱锛乣
                    };
                    // ?閫佸€嬩汉?鐭�'
                    await sendNotification('clockinReminder', notificationData, { userId: userId });
                } else {
                    logger.warn(`User ${userId} found in schedule but user document does not exist.`);
                }
            } catch (userError) {
                logger.error(`Error processing or notifying user ${userId} for missed clock-in: ${userError.message}`);
            }
        }

        logger.info("Finished sending clock-in reminders.");
        successCount = 1; // Replace with actual count if iterating
        systemLogDetails.result = "Check completed (example: found X missed clock-ins)";'
        await logActivity({ userId: 'system', feature: 'ScheduledTask', action: 'RunCheckMissedClockIn', details: systemLogDetails, success: true });
        logger.info("checkMissedClockIn finished successfully.");

    } catch (error) {
        logger.error("Error during checkMissedClockIn execution:", error);
        failureCount = 1;
        systemLogDetails.error = error.message;'
        await logActivity({ userId: 'system', feature: 'ScheduledTask', action: 'RunCheckMissedClockIn', details: systemLogDetails, success: false });
    }
});

// TODO: Add other scheduled tasks like generating salary reports, etc.
// TODO: Add Backup Scheduled Task (`scheduledFirestoreBackup` from previous response)

// --- Other potential triggers or functions ---

// Example: Function to handle leave request approval/rejection and notify user'
exports.handleLeaveStatusChange = onDocumentUpdated('leave_requests/{docId}', async (event) => {
    const beforeData = event.data.before.data();
    const afterData = event.data.after.data();
    const docId = event.params.docId;
    const userId = afterData.userId;

    // Check if status changed and the user ID exists
    if (!userId || beforeData.status === afterData.status || !afterData.status) {
        return; // No status change or missing data
    }

    logger.info(`Leave request ${docId} status changed from ${beforeData.status} to ${afterData.status} for user ${userId}`);

    try {'
        const userDoc = await db.collection('users').doc(userId).get();
        if (!userDoc.exists) {
             logger.warn(`User ${userId} not found for leave status notification.`);
             return;
        }
        const userData = userDoc.data();
'
        let notificationType = '';
        let notificationData = {'
             title: '璜嬪亣鐢宠珛鏇存敼閫氱煡','
             name: userData.name || '鍝″伐','
             startDate: formatTimestamp(afterData.startDate, 'YYYY-MM-DD'),'
             endDate: formatTimestamp(afterData.endDate, 'YYYY-MM-DD'),'
             status: afterData.status === 'approved' ? '宸叉壒鍑�' : (afterData.status === 'rejected' ? '宸叉嫆绲�' : afterData.status),'
             reason: afterData.rejectionReason || '', // Include rejection reason if available'
             message: `璜嬪亣鐢宠珛鏇存敼閫氱煡\n璜嬪亣鏅傞枔: ${formatTimestamp(afterData.startDate, 'YYYY-MM-DD')} 鑷� ${formatTimestamp(afterData.endDate, 'YYYY-MM-DD')}\n鐙€鎱�: ${afterData.status === 'approved' ? '宸叉壒鍑�' : afterData.status === 'rejected' ? '宸叉嫆绲�' : '寰呭�╂牳'}\n${afterData.status === 'approved' ? '' : afterData.status === 'rejected' ? `\n鎷掔禃鐞嗙敱: ${afterData.rejectionReason}` : ''}`
        };
'
        if (afterData.status === 'approved') {'
            notificationType = 'leaveApproved';
            notificationData.message += `宸茶��鎵瑰噯`;'
        } else if (afterData.status === 'rejected') {'
            notificationType = 'leaveRejected';
            notificationData.message += `宸茶��鎷掔禃`;
            if(afterData.rejectionReason) {
                 notificationData.message += `\n鎷掔禃鐞嗙敱: ${afterData.rejectionReason}`;
            }
        } else {
            // Handle other statuses if needed
            return;
        }

        // Send personal notification to the employee
        await sendNotification(notificationType, notificationData, { userId: userId });

    } catch (error) {
        logger.error(`Error sending leave status change notification for doc ${docId}: ${error.message}`, { error });
    }
});

// Cloud Function: Get current scheduling system status
// MODIFIED: Use v2 syntax'
exports.getScheduleSystemStatus = onCall({ region: 'asia-east1' }, async (request) => { 
    if (!request.auth) { // Use request.auth
        // ... (unauthenticated error) ...'
        throw new HttpsError('unauthenticated', '闇€瑕佺櫥鍏ユ墠鑳戒娇鐢ㄦ�ゅ姛鑳�'); // Use imported HttpsError
    }
    const uid = request.auth.uid; // Use request.auth.uid
    
    // --- Use correct collection paths ---'
    const configRef = db.collection('settings').doc('schedule_config');'
    const userRef = db.collection('users').doc(uid);
    // --- End correct collection paths ---

    try {
        // Read config and user data
        let [configDoc, userDoc] = await Promise.all([
            configRef.get(),
            userRef.get()
        ]);

        if (!configDoc.exists) {
            // Log error?'
            throw new HttpsError('not-found', 'Schedule configuration not found.'); // Use imported HttpsError
        }
        if (!userDoc.exists) {
            // Log error?'
            throw new HttpsError('not-found', 'User data not found.'); // Use imported HttpsError
        }

        let configData = configDoc.data();
        const userData = userDoc.data();
        const now = new Date();
        const nowTimestamp = admin.firestore.Timestamp.now();

        // Initialize variables based on configData'
        let currentStatus = configData.systemStatus || 'DISABLED';
        let isLocked = configData.isLocked || false;
        let lockedBy = configData.lockedBy || null;
        let lockExpiresAt = configData.lockExpiresAt || null;
        let remainingSeconds = null;

        // --- ADDED: Check for Force Open Expiration ---
        if (configData.forceOpenUntil && configData.forceOpenUntil instanceof admin.firestore.Timestamp) {
            if (nowTimestamp.toMillis() > configData.forceOpenUntil.toMillis()) {
                // MODIFIED: console.log -> logger.info
                logger.info(`Force open period expired at ${configData.forceOpenUntil.toDate().toISOString()}. Reverting status.`);
                try {
                    await configRef.update({'
                        systemStatus: 'CLOSED',
                        forceOpenUntil: admin.firestore.FieldValue.delete(),
                        lastForcedOpenBy: admin.firestore.FieldValue.delete(),
                        lastForcedOpenAt: admin.firestore.FieldValue.delete()
                    });
                    // MODIFIED: console.log -> logger.info
                    logger.info("System status reverted to CLOSED after force open expiration.");
                    configDoc = await configRef.get(); // Re-fetch needed
                    configData = configDoc.data();'
                    currentStatus = configData.systemStatus || 'CLOSED';
                } catch (revertError) {
                    // MODIFIED: console.error -> logger.error
                    logger.error("Error reverting status after force open expiration:", revertError);'
                    currentStatus = 'CLOSED';
                }
            } else {
                 // MODIFIED: console.log -> logger.info
                logger.info(`System is force-opened until ${configData.forceOpenUntil.toDate().toISOString()}.`);'
                currentStatus = 'IDLE'; // Override status
            }
        }
        // --- End Force Open Check ---

        // --- Normal Status Check (Only if not forced open) ---'
        if (currentStatus !== 'IDLE' && currentStatus !== 'IN_USE' && !(configData.forceOpenUntil && nowTimestamp.toMillis() <= configData.forceOpenUntil.toMillis())) {'
             if (currentStatus === 'ENABLED' || currentStatus === 'CLOSED') { 
                 const openTimeStr = configData.openTime;
                 const closeTimeStr = configData.closeTime;
                 if (openTimeStr && closeTimeStr) {'
                     const [openH, openM] = openTimeStr.split(':').map(Number);'
                     const [closeH, closeM] = closeTimeStr.split(':').map(Number);
                     const openDate = new Date(now); openDate.setHours(openH, openM, 0, 0);
                     const closeDate = new Date(now); closeDate.setHours(closeH, closeM, 0, 0);
                     if (closeDate <= openDate) closeDate.setDate(closeDate.getDate() + 1);'
                     currentStatus = (now >= openDate && now < closeDate) ? 'IDLE' : 'CLOSED';
                 } else {'
                     currentStatus = 'CLOSED';
                 }
             }
        }
        // --- End Normal Status Check ---

        // --- Check Lock Status (using configRef) ---
        if (isLocked && lockExpiresAt && lockExpiresAt.toMillis() < nowTimestamp.toMillis()) {
            // MODIFIED: console.log -> logger.info
            logger.info("Lock expired. Releasing automatically.");
            try {
                await configRef.update({
                    isLocked: false,
                    lockedBy: null,
                    lockExpiresAt: null
                });
                isLocked = false;
                lockedBy = null;
                lockExpiresAt = null;
                // MODIFIED: console.log -> logger.info
                logger.info("Expired lock released.");'
                 if (currentStatus === 'IN_USE') {
                     // Re-evaluate status after lock release
                     if (configData.forceOpenUntil && nowTimestamp.toMillis() <= configData.forceOpenUntil.toMillis()) {'
                         currentStatus = 'IDLE';
                     } else {
                         // Re-run time check logic
                         const openTimeStr = configData.openTime; 
                         const closeTimeStr = configData.closeTime;
                         if (openTimeStr && closeTimeStr) {'
                            const [openH, openM] = openTimeStr.split(':').map(Number);'
                            const [closeH, closeM] = closeTimeStr.split(':').map(Number);
                            const openDate = new Date(now); openDate.setHours(openH, openM, 0, 0);
                            const closeDate = new Date(now); closeDate.setHours(closeH, closeM, 0, 0);
                            if (closeDate <= openDate) closeDate.setDate(closeDate.getDate() + 1);'
                            currentStatus = (now >= openDate && now < closeDate) ? 'IDLE' : 'CLOSED';
                         } else {'
                             currentStatus = 'CLOSED';
                         }
                     }
                     // MODIFIED: console.log -> logger.info
                     logger.info("System status updated after lock expiry:", currentStatus);
                 }
            } catch (releaseError) {
                // MODIFIED: console.error -> logger.error
                logger.error("Error releasing expired lock:", releaseError);
            }
        }

        // Update status to IN_USE if still locked 
        if (isLocked) {'
            currentStatus = 'IN_USE';
            if (lockExpiresAt) {
                 remainingSeconds = Math.max(0, Math.floor((lockExpiresAt.toMillis() - nowTimestamp.toMillis()) / 1000));
            }
        }
        // --- End Lock Status Check ---

        // Get Forbidden/Holiday Dates
        // Assuming helper functions exist later in the file
        const forbiddenDates = getForbiddenDates(configData, userData); 
        const holidayDates = getHolidayDates(configData);

        // Return final result
        return {
            systemStatus: currentStatus,
            isLocked: isLocked,
            lockedBy: isLocked ? { id: lockedBy.id, name: lockedBy.name } : null,
            lockExpiresAt: lockExpiresAt ? lockExpiresAt.toDate().toISOString() : null,
            remainingSeconds: remainingSeconds,
            forbiddenDates: forbiddenDates, 
            holidayDates: holidayDates 
        };

    } catch (error) {
        // MODIFIED: console.error -> logger.error
        logger.error("Error in getScheduleSystemStatus:", error);
        // Log error?
        if (error instanceof HttpsError) { // Check imported HttpsError
            throw error; 
        }'
        throw new HttpsError('internal', 'Failed to get schedule system status.', error.message); // Use imported HttpsError
    }
});

/**
 * Cloud Function: ?瑭�?鐣�?鐢�?瀹�?绯�? * ...
 */
// MODIFIED: Use v2 syntax'
exports.requestScheduleLock = onCall({ region: 'asia-east1' }, async (request) => {
    if (!request.auth) { // Use request.auth'
        await logActivity('System', 'requestScheduleLock', 'Unauthorized', 'Error', { message: 'User not authenticated.' });'
        throw new HttpsError('unauthenticated', '闇€瑕佺櫥鍏ユ墠鑳戒娇鐢ㄦ�ゅ姛鑳�'); // Use imported HttpsError
    }
    const uid = request.auth.uid; // Use request.auth.uid
    const now = new Date(); // Current server time
    const serverTimestamp = admin.firestore.FieldValue.serverTimestamp(); // For setting timestamps
    // ... rest of the logic remains largely the same, use request.auth.uid ...
    // ... (inside the function logic where uid or employeeName is needed) ...
    // MODIFIED: Removed declaration of settingsRef, statusRef, employeeRef as they seem unused here (mistake?)
    // Re-adding declarations as they ARE used.'
    const configRef = db.collection('system_config').doc('schedule_config'); // Assuming system_config is correct'
    const userRef = db.collection('users').doc(uid); // Assuming users collection holds employee data


     try {
            // 1. 璁€瑷�瀹氬伐璩�?
            // MODIFIED: Fetch config and user data, not settings/status/employee
            const [configSnap, userSnap] = await Promise.all([
                configRef.get(),
                userRef.get() // Use userRef from declaration
            ]);

            if (!configSnap.exists) {'
                 await logActivity(uid, 'requestScheduleLock', 'System', 'Failure', { reason: 'Config not found' });'
                throw new HttpsError('failed-precondition', '绯荤当瑷�瀹氫笉瀛樺湪'); // Use imported HttpsError
            }
            if (!userSnap.exists) { // Check userSnap'
                 await logActivity(uid, 'requestScheduleLock', 'System', 'Failure', { reason: 'User not found' }); // Log User not found'
                throw new HttpsError('not-found', '鎵句笉鍒版偍鐨勭敤鎴惰硣鏂�'); // Use imported HttpsError, clarify user data
            }

            const config = configSnap.data();
            const userData = userSnap.data(); // Use userData
            const employeeName = userData.name || uid; // Use name from userData

            // 2. 妾㈡煡绯荤当?(config 璁€??'
             const systemStatus = config.systemStatus || 'DISABLED';
             const isLocked = config.isLocked || false;
             const lockedBy = config.lockedBy || null;
             const lockExpiresAt = config.lockExpiresAt || null; // Firestore Timestamp
             const forceOpenUntil = config.forceOpenUntil || null; // Firestore Timestamp
             const nowTimestamp = admin.firestore.Timestamp.now();

             let effectiveStatus = systemStatus;
             let isForceOpenActive = false;

             // Check Force Open
             if (forceOpenUntil && nowTimestamp.toMillis() <= forceOpenUntil.toMillis()) {'
                 effectiveStatus = 'IDLE'; // Force open overrides normal status
                 isForceOpenActive = true;
                 // MODIFIED: console.log -> logger.info
                 logger.info("Request lock: System is force-opened.");
             } else if (forceOpenUntil) {
                 // Force open expired, should have been reverted by getStatus, but double-check
                 // MODIFIED: console.warn -> logger.warn
                 logger.warn("Request lock: Found expired forceOpenUntil, system should be CLOSED/DISABLED.");
                 // Assume it should be CLOSED if not explicitly ENABLED'
                 effectiveStatus = (systemStatus === 'ENABLED') ? 'CLOSED' : systemStatus; // Revert logic might be complex
             }

             // Check normal window if not forced open'
             if (!isForceOpenActive && (effectiveStatus === 'ENABLED' || effectiveStatus === 'CLOSED')) {
                 const openTimeStr = config.openTime;
                 const closeTimeStr = config.closeTime;
                 if (openTimeStr && closeTimeStr) {'
                     const [openH, openM] = openTimeStr.split(':').map(Number);'
                     const [closeH, closeM] = closeTimeStr.split(':').map(Number);
                     const openDate = new Date(now); openDate.setHours(openH, openM, 0, 0);
                     const closeDate = new Date(now); closeDate.setHours(closeH, closeM, 0, 0);
                     if (closeDate <= openDate) closeDate.setDate(closeDate.getDate() + 1);'
                     effectiveStatus = (now >= openDate && now < closeDate) ? 'IDLE' : 'CLOSED';
                 } else {'
                     effectiveStatus = 'CLOSED'; // Default to closed if window times missing
                 }
             }

             // Check if lock expired
             if (isLocked && lockExpiresAt && lockExpiresAt.toMillis() < nowTimestamp.toMillis()) {
                 // MODIFIED: console.warn -> logger.warn
                 logger.warn(`Found expired lock during request by ${uid}. System should be IDLE/CLOSED now.`);
                 // Assume status is IDLE/CLOSED based on time window check above'
                 // The lock should be released automatically by getStatus, but we proceed assuming it's available
             } else if (isLocked) {
                 // Still locked by someone'
                 effectiveStatus = 'IN_USE';
             }

'
            // 3. 妾㈡煡?锟斤拷?锟�??锟芥槸?锟斤拷?瑷憋拷?锟�?            if (effectiveStatus !== 'IDLE') {'
                let reason = 'closed';'
                let message = '绯荤当???浣跨敤??浣跨敤涓�锛岃珛寰岃│銆�';'
                if (effectiveStatus === 'IN_USE' && lockedBy?.id !== uid) {'
                    reason = 'locked';'
                    message = `绯荤当?锟斤拷?锟�?锟斤拷 ${lockedBy?.name || '?浣跨敤鑰�'} 浣跨敤涓�锛岃珛寰岃│銆俙;'
                    message = `绯荤当?锟斤拷?锟�?锟斤拷 ${lockedBy?.name || '?锟斤拷?浣跨敤??} 浣跨敤涓�锟�?璜嬶拷?寰岋拷?瑭︺€俙;'
                     await logActivity(employeeName, 'requestScheduleLock', 'System', 'Failure', { reason: 'Already locked', lockedBy: lockedBy?.name || lockedBy?.id });'
                } else if (effectiveStatus === 'DISABLED') {'
                     reason = 'disabled';'
                     message = '?锟界彮绯荤当?锟斤拷?宸诧拷??锟斤拷?;'
                     await logActivity(employeeName, 'requestScheduleLock', 'System', 'Failure', { reason: 'System disabled' });'
                } else if (effectiveStatus === 'CLOSED') {'
                     await logActivity(employeeName, 'requestScheduleLock', 'System', 'Failure', { reason: 'Outside window' });
                }
                return { success: false, reason: reason, message: message };
            }


            // 4. ?锟借│浣跨敤浜嬶拷??锟斤拷? (?锟芥柊 config ?锟戒欢)
            let lockAcquired = false;
            let finalLockExpiresAt = null;

            await db.runTransaction(async (transaction) => { // Use db.runTransaction
                const freshConfigSnap = await transaction.get(configRef);
                if (!freshConfigSnap.exists) {'
                     throw new HttpsError('failed-precondition', '璁€?锟借ō瀹氬け??(浜嬶拷?锟�?'); // Use imported HttpsError
                }
                const freshConfigData = freshConfigSnap.data();
                const freshIsLocked = freshConfigData.isLocked || false;
                const freshLockExpiresAt = freshConfigData.lockExpiresAt || null;

                // Re-check lock status within transaction
                if (freshIsLocked && freshLockExpiresAt && freshLockExpiresAt.toMillis() >= nowTimestamp.toMillis()) {
                    // Locked by someone else within transaction
                    lockAcquired = false;
                } else {
                    // Available to lock
                    const sessionDurationMillis = (config.lockDurationSeconds || 300) * 1000; // Use config.lockDurationSeconds
                    const newExpiresAtDate = new Date(now.getTime() + sessionDurationMillis);
                    finalLockExpiresAt = newExpiresAtDate; // Store for return value

                    const lockPayload = {
                        isLocked: true,
                        lockedBy: { id: uid, name: employeeName }, // Store ID and name
                        lockAcquiredAt: serverTimestamp, // Use server timestamp
                        lockExpiresAt: admin.firestore.Timestamp.fromDate(newExpiresAtDate) // Convert JS Date to Firestore Timestamp
                    };
                    transaction.update(configRef, lockPayload);
                    lockAcquired = true;
                }
            });

            // 5. ?锟斤拷?浜嬶拷?绲愶拷?杩旓拷?
            if (lockAcquired && finalLockExpiresAt) {'
                 await logActivity(employeeName, 'requestScheduleLock', 'System', 'Success', { expiresAt: finalLockExpiresAt.toISOString() });
                return {
                    success: true,
                    lockExpiresAt: finalLockExpiresAt.toISOString() // 杩旓拷? ISO ?锟斤拷??锟斤拷??锟界郸?锟界��
                };
            } else {
                // ?锟斤拷?澶憋拷? (宸茶��浠栦汉?锟斤拷? - ?锟斤拷??锟戒腑琚�鎼�??'
                 const lockedByOtherName = (await configRef.get()).data()?.lockedBy?.name || '?锟斤拷?浣跨敤??; // Read again to get current holder name'
                 await logActivity(employeeName, 'requestScheduleLock', 'System', 'Failure', { reason: 'Locked during transaction', lockedBy: lockedByOtherName });
                return {
                    success: false,'
                    reason: 'locked',
                    message: `绯荤当锟�?锟斤拷 ${lockedByOtherName} 浣跨敤涓�锟�?璜嬶拷?寰岋拷?瑭︺€俙 // Update message
                };
            }

     } catch (error) {
         // MODIFIED: console.error -> logger.error
         logger.error(`Error in requestScheduleLock for user ${uid}:`, error);'
          await logActivity(uid, 'requestScheduleLock', 'System', 'Error', { message: error.message, code: error.code });
         if (error instanceof HttpsError) { // Check imported HttpsError
             throw error; // ?锟斤拷? HttpsError
         } else {
             // Handle potential transaction errors more gracefully if needed'
             throw new HttpsError('internal', '璜嬶拷??锟斤拷??锟界彮绯荤当?锟界櫦?锟藉収?锟介尟瑾わ拷?); // Use imported HttpsError
         }
     }
});

/**
 * Cloud Function: ?锟芥斁?锟斤拷??锟芥埗?锟斤拷??锟斤拷??锟界郴绲憋拷?锟�? * ...
 */
// MODIFIED: Use v2 syntax'
exports.releaseScheduleLock = onCall({ region: 'asia-east1' }, async (request) => {
    if (!request.auth) { // Use request.auth'
        await logActivity('System', 'releaseScheduleLock', 'Unauthorized', 'Error', { message: 'User not authenticated.' });'
        throw new HttpsError('unauthenticated', '?锟斤拷???锟斤拷?璀夛拷??锟斤拷??锟斤拷??锟斤拷?瀹氾拷?); // Use imported HttpsError
    }
    const uid = request.auth.uid; // Use request.auth.uid
    // ... rest of the logic remains largely the same, use request.auth.uid ...'
    const userRef = db.collection('users').doc(uid); // Assuming users collection holds employee data'
    const configRef = db.collection('system_config').doc('schedule_config'); // Update config doc

    try {
            const userSnap = await userRef.get();
            const employeeName = userSnap.exists ? (userSnap.data().name || uid) : uid;

            // 浣跨敤浜嬶拷?纰猴拷?璁€?锟斤拷?瀵�鍏�?锟斤拷?瀛愶拷?            let released = false;'
            let message = '';
            let currentHolder = null; // For logging if release failed due to wrong holder

            await db.runTransaction(async (transaction) => { // Use db.runTransaction
                const configSnap = await transaction.get(configRef); // Read config doc

                if (!configSnap.exists) {
                    // ?锟�?锟斤拷?浠讹拷?瀛樺湪锛岀劇?锟�?锟芥斁锛岋拷??锟借��??                    // MODIFIED: console.warn -> logger.warn'
                    logger.warn(`releaseScheduleLock called by ${uid}, but config document doesn't exist.`);'
                    message = '绯荤当瑷�锟�??锟藉父锛岀劇?锟�?锟芥斁??;
                    released = false; // Consider this not a successful release in the normal sense
                    return; // Exit transaction
                }

                const currentConfigData = configSnap.data();
                currentHolder = currentConfigData.lockedBy?.name; // Store for potential logging

                if (!currentConfigData.isLocked) { // Check isLocked flag
                    // 绯荤当涓嶆槸 IN_USE ?锟�?锟斤拷??锟斤拷??锟芥斁'
                    message = '绯荤当?锟斤拷?涓︼拷??锟斤拷??锟�?锟斤拷?;
                    released = false;
                } else if (currentConfigData.lockedBy?.id !== uid) { // Check lockedBy.id
                    // ?锟斤拷??锟界敱?锟斤拷??锟芥埗?锟斤拷?'
                    message = '?锟戒甫?锟斤拷??锟斤拷??锟界郴绲憋拷?瀹氾拷??锟斤拷??锟芥斁??;
                    released = false;
                    // Log will happen outside transaction based on flag
                } else {
                    // 纰猴拷??锟界暥?锟界敤?锟斤拷??锟斤拷? -> ?锟芥斁
                    const releasePayload = {
                        isLocked: false,
                        lockedBy: null,
                        lockAcquiredAt: null,
                        lockExpiresAt: null,
                        // Optionally keep lastStatusChangeReason or update it
                        // lastStatusChangeReason: `Released by user ${uid}`
                    };
                    transaction.update(configRef, releasePayload);
                    released = true;'
                    message = '?锟界彮?锟斤拷?宸诧拷??锟斤拷??锟斤拷?;
                }
            });

            // 瑷橈拷??锟斤拷? (浜嬶拷??锟斤拷?锟�?
            if (released) {'
                await logActivity(employeeName, 'releaseScheduleLock', 'System', 'Success', { message });
            } else {
                 // Log failure if it was due to not holding the lock'
                 if (message === '?锟戒甫?锟斤拷??锟斤拷??锟界郴绲憋拷?瀹氾拷??锟斤拷??锟芥斁??) {'
                     await logActivity(employeeName, 'releaseScheduleLock', 'System', 'Failure', { reason: 'Not lock holder', currentHolder: currentHolder || 'Unknown' });
                 } else if(message) { // Log other info messages'
                     await logActivity(employeeName, 'releaseScheduleLock', 'System', 'Info', { message });
                 }
            }

            return { success: released, message: message };

    } catch (error) {
        // Get name using request.auth.token if available in v2
        const actorName = request.auth?.token?.name || uid; // Use request.auth.token.name
        // MODIFIED: console.error -> logger.error
        logger.error(`Error in releaseScheduleLock for user ${uid}:`, error);'
        await logActivity(actorName, 'releaseScheduleLock', 'System', 'Error', { message: error.message, code: error.code });
        if (error instanceof HttpsError) { // Check imported HttpsError
            throw error; // ?锟斤拷? HttpsError
        } else {'
            throw new HttpsError('internal', '?锟芥斁?锟界彮?锟斤拷??锟界櫦?锟藉収?锟介尟瑾わ拷?); // Use imported HttpsError
        }
    }
});

// --- ADD isAdmin HELPER AND forceOpenScheduling FUNCTION --- 

// --- Helper: Check Admin Role (Example) ---
// MODIFIED: Adapt isAdmin to work with v2 request object
async function isAdmin(request) { 
    if (!request.auth) {
        // Log for debugging server-side check failure'
        logger.error('isAdmin check failed: Unauthenticated.');'
        throw new HttpsError('unauthenticated', 'The function must be called while authenticated.'); // Use imported HttpsError
    }
    const uid = request.auth.uid;
    try {'
        const userDoc = await db.collection('users').doc(uid).get(); // db is assumed to be initialized globally
        if (!userDoc.exists || (userDoc.data().level ?? 0) < 9) { // Assuming level 9+ is admin, handle missing level'
             logger.warn(`isAdmin check failed for user ${uid}: Level is ${userDoc.data()?.level ?? 'missing/undefined'} (Exists: ${userDoc.exists})`);'
            throw new HttpsError('permission-denied', 'User does not have admin privileges.'); // Use imported HttpsError
        }
        logger.info(`isAdmin check passed for user ${uid} (Level: ${userDoc.data().level})`);
        return true; // Return true if admin
    } catch (error) {
         logger.error(`Error during isAdmin check for user ${uid}:`, error);
         // Re-throw permission denied if it was that, otherwise throw internal error'
         if (error instanceof HttpsError && error.code === 'permission-denied') {
             throw error;
         }'
         throw new HttpsError('internal', 'Error checking admin privileges.', error.message); // Use imported HttpsError
    }
}


// --- NEW: Cloud Function to Force Open Scheduling (v2 syntax) ---
// MODIFIED: Use v2 syntax'
exports.forceOpenScheduling = onCall({ region: 'asia-east1' }, async (request) => {
    await isAdmin(request); // Ensure caller is admin using the adapted helper
'
    const configRef = db.collection('system_config').doc('schedule_config'); // Use system_config collection
    const now = admin.firestore.Timestamp.now();
    const thirtyMinutesInMillis = 30 * 60 * 1000;
    const forceOpenUntil = admin.firestore.Timestamp.fromMillis(now.toMillis() + thirtyMinutesInMillis);

    try {
        await configRef.update({'
            systemStatus: 'IDLE', // Force to IDLE
            forceOpenUntil: forceOpenUntil,
            lastForcedOpenBy: request.auth.uid, // Use request.auth.uid
            lastForcedOpenAt: now         // Optional: Log when it was forced
        });
        // MODIFIED: console.log -> logger.info
        logger.info(`Scheduling system forced open until ${forceOpenUntil.toDate().toISOString()} by ${request.auth.uid}`);
        // Log activity (optional)'
        await logActivity(request.auth.uid, 'forceOpenScheduling', 'Admin Action', 'Success', { until: forceOpenUntil.toDate().toISOString() });
        return { success: true };
    } catch (error) {
        // MODIFIED: console.error -> logger.error
        logger.error("Error forcing schedule open:", error);
        // Log activity (optional)'
        await logActivity(request.auth.uid, 'forceOpenScheduling', 'Admin Action', 'Error', { message: error.message });'
        throw new HttpsError('internal', 'Failed to update schedule config.', error.message); // Use imported HttpsError
    }
});

/**
 * Cloud Function: Review Leave Request
 * Handles approval or rejection of leave requests by administrators
 * Requires level 9+ permission (admin)
 * 
 * @param {Object} request.data
 * @param {string} request.data.requestId - ID of the leave request document
 * @param {boolean} request.data.approved - Whether the request is approved or rejected
 * @param {string} [request.data.reason] - Optional reason for rejection
 */'
exports.reviewLeaveRequest = onCall({ region: 'asia-east1' }, async (request) => {
    // 1. Authentication check
    if (!request.auth) {
        logger.error("reviewLeaveRequest: Unauthenticated call.");'
        throw new HttpsError('unauthenticated', '?锟斤拷?锟�?璀夎韩锟�?);
    }

    // 2. Permission check - require level 9+ (admin)
    const requiredLevel = 9;
    let adminName = null;
    
    try {'
        const adminDoc = await db.collection('users').doc(request.auth.uid).get();
        if (!adminDoc.exists) {
            logger.error(`reviewLeaveRequest: Admin user ${request.auth.uid} not found in database.`);'
            throw new HttpsError('permission-denied', '?锟斤拷??锟界��?锟藉摗璩囷拷?');
        }
        
        const adminData = adminDoc.data();
        const userLevel = adminData.level ?? 0;
        adminName = adminData.name || request.auth.uid;
        
        if (userLevel < requiredLevel) {
            logger.error(`reviewLeaveRequest: Permission denied for UID ${request.auth.uid}. Required: ${requiredLevel}, User has: ${userLevel}.`);'
            throw new HttpsError('permission-denied', `娆婏拷?涓嶈冻 (?锟斤拷?锟�?锟�?${requiredLevel})`);
        }
        
        logger.info(`reviewLeaveRequest: Called by admin ${adminName} (${request.auth.uid}). Data:`, request.data);
    } catch (error) {
        if (error instanceof HttpsError) {
            throw error; // Re-throw HTTP errors
        }
        logger.error("reviewLeaveRequest: Error checking admin permissions:", error);'
        throw new HttpsError('internal', '椹楋拷?绠★拷??锟斤拷??锟斤拷??锟斤拷??锟借��');
    }

    // 3. Request validation
    const { requestId, approved, reason } = request.data;
    
    if (!requestId) {
        logger.error("reviewLeaveRequest: Missing requestId parameter", request.data);'
        throw new HttpsError('invalid-argument', '璜嬶拷??锟絀D?锟斤拷?濉�锟�?');
    }
    '
    if (typeof approved !== 'boolean') {'
        logger.error("reviewLeaveRequest: Invalid 'approved' parameter, must be boolean", request.data);'
        throw new HttpsError('invalid-argument', '璜嬶拷??锟藉��?锟斤拷??锟斤拷??锟界偤甯冿拷???);
    }

    // 4. Process the leave request
    try {'
        const leaveRequestRef = db.collection('leave_requests').doc(requestId);
        const leaveRequestDoc = await leaveRequestRef.get();
        
        if (!leaveRequestDoc.exists) {
            logger.error(`reviewLeaveRequest: Leave request ${requestId} not found`);'
            throw new HttpsError('not-found', '?锟斤拷??锟斤拷?瀹氾拷?璜嬶拷???);
        }
        
        const leaveData = leaveRequestDoc.data();
        
        // Check if request is already processed'
        if (leaveData.status === 'approved' || leaveData.status === 'rejected') {
            logger.warn(`reviewLeaveRequest: Leave request ${requestId} already processed (${leaveData.status})`);'
            throw new HttpsError('failed-precondition', `姝わ拷??锟藉柈宸茶��${leaveData.status === 'approved' ? '?锟斤拷?' : '?锟斤拷?'}`);
        }
        
        // Update the leave request status
        const updateData = {'
            status: approved ? 'approved' : 'rejected',
            reviewedBy: request.auth.uid,
            reviewedByName: adminName,
            reviewTimestamp: admin.firestore.FieldValue.serverTimestamp()
        };
        
        // Add rejection reason if provided and request is rejected
        if (!approved && reason) {
            updateData.rejectionReason = reason;
        }
        
        await leaveRequestRef.update(updateData);
        logger.info(`reviewLeaveRequest: Successfully reviewed request ${requestId}. Approved: ${approved}`);
        
        // 5. Send notification to the employee
        try {
            const userId = leaveData.userId;
            if (!userId) {
                throw new Error("Missing userId in leave request");
            }
            '
            const userDoc = await db.collection('users').doc(userId).get();
            if (!userDoc.exists) {
                throw new Error(`User ${userId} not found`);
            }
            
            const userData = userDoc.data();
            
            const notificationData = {'
                title: approved ? '璜嬶拷?宸叉壒?? : '璜嬶拷?琚�锟�?锟�?,'
                userName: userData.name || '?锟藉伐','
                startDate: formatTimestamp(leaveData.startDate, 'YYYY-MM-DD'),'
                endDate: formatTimestamp(leaveData.endDate, 'YYYY-MM-DD'),'
                reason: approved ? '' : (reason || '?锟斤拷?渚涳拷???),'
                message: `?锟斤拷?璜嬶拷??锟斤拷? (${formatTimestamp(leaveData.startDate, 'YYYY-MM-DD')} ??${formatTimestamp(leaveData.endDate, 'YYYY-MM-DD')}) ${approved ? '宸茶��?锟斤拷?' : '宸茶��?锟斤拷?'}`'
                + (approved ? '' : `\n?锟斤拷??锟斤拷?: ${reason || '?锟斤拷?锟�?}`)
            };
            
            await sendNotification('
                approved ? 'leaveApproved' : 'leaveRejected',
                notificationData,
                { userId: userId }
            );
            
            logger.info(`reviewLeaveRequest: Notification sent to user ${userId} for request ${requestId}`);
        } catch (notifyError) {'
            // Non-critical error - log but don't fail the function
            logger.error(`reviewLeaveRequest: Error sending notification for request ${requestId}:`, notifyError);
        }
        
        // 6. Log the activity
        await logActivity({
            userId: request.auth.uid,
            userName: adminName,'
            feature: 'LeaveAdmin','
            action: approved ? 'ApproveLeave' : 'RejectLeave',
            details: {
                leaveRequestId: requestId,
                employeeId: leaveData.userId,'
                startDate: formatTimestamp(leaveData.startDate, 'YYYY-MM-DD'),'
                endDate: formatTimestamp(leaveData.endDate, 'YYYY-MM-DD'),'
                reason: approved ? '' : (reason || '?锟斤拷?渚涳拷???)
            },
            success: true
        });
        
        return { 
            success: true, '
            message: approved ? '璜嬶拷??锟斤拷?宸叉壒?? : '璜嬶拷??锟斤拷?宸诧拷?锟�? 
        };
        
    } catch (error) {
        logger.error(`reviewLeaveRequest: Error processing request ${requestId}:`, error);
        
        // Log the failed activity
        try {
            await logActivity({
                userId: request.auth.uid,
                userName: adminName,'
                feature: 'LeaveAdmin','
                action: approved ? 'ApproveLeave' : 'RejectLeave',
                details: {
                    leaveRequestId: requestId,
                    error: error.message
                },
                success: false
            });
        } catch (logError) {
            logger.error("Failed to log activity for failed leave review:", logError);
        }
        
        if (error instanceof HttpsError) {
            throw error;
        }'
        throw new HttpsError('internal', '?锟斤拷?璜嬶拷??锟斤拷??锟斤拷??锟借��', error.message);
    }
});

// Ensure helper functions getForbiddenDates and getHolidayDates are defined below
function getForbiddenDates(configData, userData) {
    // ... (implementation)
     let forbidden = configData.forbiddenDates || [];
    const storeForbidden = configData.storeForbiddenDates?.[userData.store] || [];
    return [...new Set([...forbidden, ...storeForbidden])]; 
}

function getHolidayDates(configData) {
    // ... (implementation)
     return configData.holidayDates || [];
}

//=======================================
//        ?锟斤拷?浠伙拷?瑭曚及?锟芥暩 (?锟斤拷??锟斤拷?
//=======================================

/**
 * ?锟斤拷??锟芥暩锛氾拷??锟斤拷?浼帮拷??锟斤拷??锟斤拷??锟斤拷?浠伙拷??? * 瑙哥櫦?锟斤拷?锛氭牴?锟斤拷??锟戒换?锟斤拷? evaluationConfig.triggerType?? *   - ?锟斤拷??锟斤拷???MONTHLY锛屾牴??evaluationConfig.evaluationFrequency (?锟斤拷?/?锟斤拷?)?? * TODO: ?锟斤拷?瑷�锟�?Pub/Sub 涓伙拷???Cloud Scheduler 浣滄キ渚嗗��?锟借Ц?锟芥��?锟芥暩?? */

/**
 * 瑭曚及?锟藉€嬶拷??锟戒换?锟斤拷??锟�?锟斤拷??锟界��?锟斤拷??锟斤拷??锟藉伐?? * @param {object} task - The bonus task object (including id).
 */
async function evaluateSingleTaskForAllEmployees(task) {
    logger.info(`Evaluating task [${task.name}] (${task.id}) for all employees.`);
    try {
        const minLevel = task.minLevel || 0;'
        // MODIFIED: Query 'employees' collection instead of 'users''
        const usersSnapshot = await db.collection('employees') '
                                      .where('level', '>=', minLevel)
                                      // Add other potential filters like isBonusEligible later'
                                      // .where('isBonusEligible', '==', true) // Example
                                      .get();

        if (usersSnapshot.empty) {
            logger.info(`No employees found meeting minimum level ${minLevel} for task ${task.id}.`);
            return;
        }

        logger.info(`Found ${usersSnapshot.size} employees potentially eligible for task ${task.id}.`);

        const evaluationDate = FieldValue.serverTimestamp(); // Use server timestamp for consistency
        const evaluationMonth = getEvaluationMonthString(task.evaluationConfig);
        if (!evaluationMonth) {
            logger.warn(`Could not determine evaluation month for task ${task.id}, skipping.`);
            return;
        }

        const employeePromises = [];
        usersSnapshot.forEach(userDoc => {
            const employee = { id: userDoc.id, ...userDoc.data() };
            employeePromises.push(evaluateTaskForEmployee(task, employee, evaluationMonth, evaluationDate));
        });

        await Promise.all(employeePromises);
        logger.info(`Finished evaluating task [${task.name}] (${task.id}) for all employees.`);

    } catch (error) {
        logger.error(`Error evaluating task ${task.id} for all employees:`, error);
    }
}

/**
 * 瑭曚及?锟斤拷??锟斤拷?浠伙拷?灏嶅柈?锟藉摗宸ワ拷??锟斤拷??锟斤拷??? * @param {object} task - The bonus task object.
 * @param {object} employee - The employee user object.'
 * @param {string} evaluationMonth - The target month string 'YYYY-MM'.
 * @param {Timestamp} evaluationDate - Timestamp of when the evaluation is run.
 */
async function evaluateTaskForEmployee(task, employee, evaluationMonth, evaluationDate) {'
    const progressDocRef = db.collection('employee_bonus_progress').doc(`${employee.id}_${evaluationMonth}`);
    logger.info(`Evaluating task [${task.name}] (${task.id}) for employee [${employee.displayName || employee.id}] (${employee.id}) for month ${evaluationMonth}.`);

    let status = "PENDING";
    let rewardEarned = null;
    const conditionsResult = [];
    let unlockConditionsMet = true; // Assume met initially

    try {
        // 1. 妾㈡煡?锟斤拷?姊濅欢 (Unlock Conditions) - Currently only Tenure
        if (task.unlockConditions?.minTenureDays) {
            const tenureDays = calculateTenureDays(employee.hireDate);
            if (tenureDays === null || tenureDays < task.unlockConditions.minTenureDays) {
                unlockConditionsMet = false;
                status = "INELIGIBLE";
                logger.info(`Employee ${employee.id} ineligible for task ${task.id} due to tenure (${tenureDays} days < ${task.unlockConditions.minTenureDays} required).`);
            }
        }
        // Add checks for other unlock conditions (e.g., store performance) here later

        // 2. 濡傦拷??锟斤拷?姊濅欢婊胯冻锛岋拷?浼版牳蹇冿拷?锟�?(Core Conditions)
        if (unlockConditionsMet && task.conditions && task.conditions.length > 0) {'
            let overallPassed = task.conditionsLogic === 'OR' ? false : true; // Initial state depends on logic
            // 浣跨敤锟�?锟斤拷?锟芥暩瑾跨敤 checkSingleCondition ?锟芥暩
            const conditionPromises = task.conditions.map(condition => {
                // 浣跨敤?锟斤拷??锟芥暩?锟斤拷??锟芥牸锟�?                return checkSingleCondition(employee.id, condition, employee, evaluationDate instanceof Date ? 
                    evaluationDate : new Date());
            });

            const results = await Promise.all(conditionPromises);
            results.forEach(result => {
                conditionsResult.push(result); // Store individual results'
                if (task.conditionsLogic === 'AND') {
                    if (!result.passed) overallPassed = false;
                } else { // OR logic
                    if (result.passed) overallPassed = true;
                }
            });

            if (overallPassed) {
                status = "PASSED";
                rewardEarned = task.rewardValue;
                logger.info(`Employee ${employee.id} PASSED task ${task.id}.`);
            } else {
                status = "FAILED";
                logger.info(`Employee ${employee.id} FAILED task ${task.id}.`);
            }
        } else if (unlockConditionsMet && (!task.conditions || task.conditions.length === 0)) {
            // No core conditions defined, but unlock met - consider it PASSED
            status = "PASSED";
            rewardEarned = task.rewardValue;
             logger.info(`Employee ${employee.id} PASSED task ${task.id} (no core conditions defined).`);
        } else if (!unlockConditionsMet) {
            // Already set to INELIGIBLE above
        }

        // 3. 瑷橈拷?绲愶拷???Firestore
        const taskResult = {
            taskId: task.id,
            taskName: task.name,
            status: status,
            rewardEarned: rewardEarned,
            evaluationDate: evaluationDate, // Record when this specific evaluation ran
            unlockConditionsMet: unlockConditionsMet,
            conditionsResult: conditionsResult // Store snapshot of condition checks
        };

        // Use set with merge:true to add/update the task result within the monthly document
        await progressDocRef.set({
            employeeId: employee.id,'
            employeeName: employee.displayName || employee.name || '?锟界煡濮擄拷?',
            month: evaluationMonth,
            tasks: FieldValue.arrayUnion(taskResult) // Add task result to array, avoids duplicates if run multiple times
        }, { merge: true });

        logger.info(`Saved evaluation result for task ${task.id}, employee ${employee.id}, month ${evaluationMonth}. Status: ${status}`);

    } catch (error) {
        logger.error(`Error evaluating task ${task.id} for employee ${employee.id}:`, error);
        // Optionally log failure to a separate collection or update status to ERROR
    }
}

/**
 * 妾㈡煡?锟藉€嬫牳蹇冿拷?浠讹拷??锟斤拷??锟藉伐?锟藉惁?锟斤拷??? * @param {object} employee - The employee user object.
 * @param {object} condition - The condition object { type, metric, operator, value, params }.'
 * @param {string} evaluationMonth - The target month string 'YYYY-MM' (for time-based lookups).
 * @returns {Promise<object>} - Promise resolving to { condition, dataValue, passed: boolean }
 * @deprecated 浣跨敤?锟斤拷? checkSingleCondition(userId, condition, employeeData, evaluationDate) ?锟戒唬
 */
async function checkSingleCondition(employee, condition, evaluationMonth) {
    logger.warn(`浣跨敤宸诧拷??锟斤拷? checkSingleCondition ?锟芥帴??锟斤拷锟�??锟芥柊瑾跨敤浠ヤ娇?锟芥柊?锟藉嚱?锟姐€俙);
    
    // 寤猴拷?瑭曚及?锟斤拷?锛屼娇??evaluationMonth ?锟斤拷?锟�?    let evaluationDate;
    try {'
        const [year, month] = evaluationMonth.split('-').map(Number);
        evaluationDate = new Date(year, month, 0); // ?锟斤拷??锟斤拷?
    } catch (error) {
        logger.error(`?锟斤拷?锟�?${evaluationMonth} ?锟藉缓瑭曚及?锟斤拷?锛屼娇?锟界暥?锟芥棩?锟芥浛浠�`, error);
        evaluationDate = new Date();
    }
    
    // 寰為€欏€嬪嚱?锟藉懡?锟界┖?锟戒腑?锟斤拷?灏嶅叏灞€?锟斤拷??锟芥暩?锟斤拷???    const globalCheckSingleCondition = global.checkSingleCondition || checkSingleCondition;
    // ?锟斤拷??锟芥�歌�跨敤锛岀洿?锟借��?锟芥柊?锟藉彛
    return await globalCheckSingleCondition(employee.id, condition, employee, evaluationDate);
}

// --- Evaluation Helper Functions ---

/**
 * Calculates tenure in days based on hire date.
 * @param {Timestamp|Date|string} hireDateInput - Employee hire date.
 * @returns {number|null} - Tenure in days, or null if hire date is invalid.
 * @deprecated Please use the more comprehensive version below
 */
function calculateTenureDays(hireDateInput) {
    logger.warn(`浣跨敤宸诧拷??锟斤拷?绨″柈 calculateTenureDays ?锟藉彛?锟斤拷??锟芥柊瑾跨敤浠ヤ娇?锟芥洿瀹屾暣?锟斤拷??锟姐€俙);
    // 瑾跨敤涓嬫柟?锟斤拷??锟斤拷??锟芥暩锛屽偝?锟界暥?锟芥棩?锟斤拷??锟斤拷?浼版棩??    return calculateTenureDaysExtended(hireDateInput, new Date());
}

/**
 * Compares two values using a specified operator.
 * @param {*} actualValue - The actual data value from the employee/system.'
 * @param {string} operator - The comparison operator (e.g., '>=', '<=', '==').
 * @param {*} targetValue - The target value from the condition definition.
 * @returns {boolean} - True if the comparison holds, false otherwise.
 */
function compareValues(actualValue, operator, targetValue) {
    logger.debug(`Comparing values: ${actualValue} ${operator} ${targetValue}`);
    // Basic type coercion for comparison (may need refinement)
    const numActual = Number(actualValue);
    const numTarget = Number(targetValue);
    const useNumeric = !isNaN(numActual) && !isNaN(numTarget);

    try {
        switch (operator) {'
            case '>=':
                return useNumeric ? numActual >= numTarget : actualValue >= targetValue;'
            case '<=':
                return useNumeric ? numActual <= numTarget : actualValue <= targetValue;'
            case '==':'
                // Be careful with type coercion for '=='
                 return useNumeric ? numActual === numTarget : String(actualValue) === String(targetValue);'
            case '!=':
                return useNumeric ? numActual !== numTarget : String(actualValue) !== String(targetValue);'
            case '>':
                return useNumeric ? numActual > numTarget : actualValue > targetValue;'
            case '<':
                return useNumeric ? numActual < numTarget : actualValue < targetValue;
            default:
                logger.warn(`Unsupported operator: ${operator}`);
                return false;
        }
    } catch (error) {
        logger.error("Error during value comparison:", error, { actualValue, operator, targetValue });
        return false;
    }
}

/**
 * Determines the evaluation month string (YYYY-MM) based on config.
 * @param {object} evaluationConfig - The evaluation config object.
 * @returns {string|null} - YYYY-MM string or null.
 */
function getEvaluationMonthString(evaluationConfig) {
    logger.warn(`浣跨敤宸诧拷??锟斤拷? getEvaluationMonthString ?锟斤拷?瀹氱京?锟斤拷??锟芥柊瑾跨敤浠ヤ娇?锟斤拷???066琛岋拷??锟斤拷??锟芥暩?锟絗);'
    // 瑾跨敤?锟斤拷??锟芥暩浠ワ拷??锟斤拷??锟斤拷?    if (typeof global.getEvaluationMonthString === 'function') {
        return global.getEvaluationMonthString(evaluationConfig);
    }
    
    // ?锟斤拷?淇濓拷?瀵︾従?锟借集锛屼互?锟借惉涓€?锟斤拷??锟藉叏灞€?锟芥暩'
    if (!evaluationConfig || evaluationConfig.triggerType !== 'MONTHLY') {
        logger.warn("Cannot get evaluation month: Invalid config or triggerType is not MONTHLY.", { evaluationConfig });
        return null;
    }
    try {
        const currentDate = new Date();
        // If we have a specific month in the config, use it
        if (evaluationConfig.targetMonth) {
            return evaluationConfig.targetMonth;
        }
        
        // Otherwise calculate from the current date'
        const targetMonth = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;
        logger.info(`Using current month for evaluation: ${targetMonth}`);
        return targetMonth;
    } catch (error) {
        logger.error("Error determining evaluation month:", error);
        return null;
    }
}

// =======================================
// == ?锟斤拷?浠伙拷?瑭曚及?锟芥暩 (Cloud Functions) ==
// =======================================

// --- 寮曞叆蹇咃拷???Firebase Admin SDK ---
// (?锟借ō admin, db, logger, FieldValue 宸诧拷??锟斤拷?妗堬拷??锟斤拷?濮嬶拷?)

/**
 * 宸茬敱涓婃柟瀹氱京??compareValues ?锟芥暩?锟戒唬
 * @deprecated 璜嬩娇?锟斤拷??锟斤拷?缇╋拷? compareValues ?锟芥暩
 */
function compareValues(actual, operator, target) {
    logger.warn(`浣跨敤宸诧拷??锟斤拷? compareValues ?锟芥帴??锟斤拷锟�??锟芥柊瑾跨敤浠ヤ娇?锟芥柊?锟藉嚱?锟姐€俙);
    // ?锟斤拷??锟藉埌涓婃柟瀹氱京?锟藉嚱?锟斤拷?淇濓拷??锟芥暩?锟斤拷?涓€??    return compareValuesExtended(actual, operator, target);
}

/**
 * Calculates tenure in days between hire date and a given end date.'
 * @param {admin.firestore.Timestamp | Date | string | null} hireDateInput - The user's hire date.
 * @param {Date} evaluationDate - The date the evaluation is run (defaults to now if invalid).
 * @returns {number|null} Tenure in days, or null if hire date is invalid.
 */
function calculateTenureDaysExtended(hireDateInput, evaluationDate = new Date()) {
     // (姝ゅ嚱?锟藉収瀹癸拷?涔嬶拷??锟斤拷??锟斤拷?锟�?
     let hireDate;
     if (!hireDateInput) return null;

     try {
         if (hireDateInput instanceof Date) {
             hireDate = hireDateInput;
         } else if (hireDateInput.toDate) { // Firestore Timestamp
             hireDate = hireDateInput.toDate();'
         } else if (typeof hireDateInput === 'string') {
              hireDate = new Date(hireDateInput);
         } else {
              logger.warn("Unsupported hireDate format:", hireDateInput);
              return null;
         }

         if (isNaN(hireDate.getTime())) {
             logger.warn("Invalid hireDate after parsing:", hireDateInput);
             return null;
         }

         // Ensure evaluationDate is valid
         if (!evaluationDate || !(evaluationDate instanceof Date) || isNaN(evaluationDate.getTime())) {
             logger.warn("Invalid evaluationDate provided for tenure calculation. Using current time.");
             evaluationDate = new Date();
         }

         // 瑷堬拷??锟斤拷?宸�鐣� (蹇界暐?锟斤拷??锟斤拷?)
         const evalDateOnly = new Date(evaluationDate.getFullYear(), evaluationDate.getMonth(), evaluationDate.getDate());
         const hireDateOnly = new Date(hireDate.getFullYear(), hireDate.getMonth(), hireDate.getDate());

         const diffTime = evalDateOnly.getTime() - hireDateOnly.getTime();
         const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24)); // ?锟斤拷??锟芥暩锟�?         return diffDays >= 0 ? diffDays : 0;
     } catch (error) {
          logger.error("Error calculating tenure days:", error, { hireDateInput, evaluationDate });
          return null;
     }
}

/**
 * Checks an attendance-related condition.'
 * @param {string} userId The employee's ID.'
 * @param {string} metric The specific attendance metric (e.g., 'on_time_rate').
 * @param {string} operator The comparison operator.
 * @param {*} value The target value.'
 * @param {string} timePeriod String indicating the period (e.g., 'LAST_MONTH').
 * @param {Date} evaluationDate Date the evaluation is running.
 * @returns {Promise<{passed: boolean, dataValue: any}>}
 */
async function checkAttendanceCondition(userId, metric, operator, value, timePeriod, evaluationDate) {
    // --- 瑷堬拷??锟斤拷?绡勶拷? ---
    let startDate, endDate;
    const evalYear = evaluationDate.getFullYear();
    const evalMonth = evaluationDate.getMonth(); // 0-indexed

    // Add more timePeriod options if needed'
    if (timePeriod === 'LAST_MONTH') {
        startDate = new Date(evalYear, evalMonth - 1, 1, 0, 0, 0, 0); // First day of last month, start of day
        endDate = new Date(evalYear, evalMonth, 0, 23, 59, 59, 999); // Last day of last month, end of day'
    } else if (timePeriod === 'CURRENT_MONTH') {
         startDate = new Date(evalYear, evalMonth, 1, 0, 0, 0, 0);
         endDate = new Date(evalYear, evalMonth + 1, 0, 23, 59, 59, 999);
    } else {
        logger.warn(`Unsupported timePeriod for attendance: ${timePeriod}`);
        return { passed: false, dataValue: `涓嶆敮?锟斤拷??锟斤拷??锟�?? ${timePeriod}` };
    }

    logger.info(`Checking ATTENDANCE metric: ${metric} for user ${userId} between ${startDate.toISOString()} and ${endDate.toISOString()}`);

    // --- ASSUMPTIONS: Verify these constants match your Firestore structure! ---'
    const CLOCK_RECORDS_COLLECTION = 'clock_records';'
    const SCHEDULE_COLLECTION = 'schedules';'
    const USER_ID_FIELD = 'userId';'
    const TIMESTAMP_FIELD = 'timestamp';'
    const STATUS_FIELD = 'status';                  // Assumed field written by recordClockEvent'
    const ON_TIME_STATUS_VALUE = '婧栵拷?';            // Assumed value written by recordClockEvent'
    const LATE_STATUS_VALUE = '?锟藉埌';              // Assumed value written by recordClockEvent'
    const SCHEDULE_DATE_FIELD = 'date';             // (YYYY-MM-DD string)'
    const SCHEDULE_SHIFT_FIELD = 'shift';'
    const SCHEDULE_DAY_OFF_VALUE = '锟�?;

    try {
        let actualValue = null;
        let passed = false;

        // --- Query clock records and schedules --- 
        // ?锟借��?锟藉崱瑷橈拷?
        const clockRecordsQuery = db.collection(CLOCK_RECORDS_COLLECTION)'
                                  .where(USER_ID_FIELD, '==', userId)'
                                  .where(TIMESTAMP_FIELD, '>=', startDate)'
                                  .where(TIMESTAMP_FIELD, '<=', endDate);
        const clockRecordsSnapshot = await clockRecordsQuery.get();
        const clockRecords = [];
        clockRecordsSnapshot.forEach(doc => clockRecords.push(doc.data()));
        logger.info(`Found ${clockRecords.length} clock records for user ${userId}`);

        // ?锟借��?锟界彮瑷橈拷?
        const scheduleQuery = db.collection(SCHEDULE_COLLECTION)'
                             .where(USER_ID_FIELD, '==', userId)'
                             .where(SCHEDULE_DATE_FIELD, '>=', startDate.toISOString().split('T')[0])'
                             .where(SCHEDULE_DATE_FIELD, '<=', endDate.toISOString().split('T')[0]);
        const scheduleSnapshot = await scheduleQuery.get();
        const scheduleRecords = [];
        scheduleSnapshot.forEach(doc => scheduleRecords.push(doc.data()));
        logger.info(`Found ${scheduleRecords.length} schedule records for user ${userId}`);

        // --- Calculate metrics --- 
        switch (metric) {'
            case 'on_time_rate': {
                let onTimeCount = 0;
                let relevantClockIns = 0;
                const scheduledWorkDaysMap = new Map();
                
                // 寤猴拷??锟界彮宸ワ拷??锟斤拷?锟�?                scheduleRecords.forEach(schedule => {
                    if (schedule[SCHEDULE_SHIFT_FIELD] !== SCHEDULE_DAY_OFF_VALUE) {
                        scheduledWorkDaysMap.set(schedule[SCHEDULE_DATE_FIELD], schedule[SCHEDULE_SHIFT_FIELD]);
                    }
                });

                clockRecords.forEach(record => {
                    try {
                         const recordTimestamp = record[TIMESTAMP_FIELD];
                         if(recordTimestamp && recordTimestamp.toDate) {'
                             const recordDateStr = recordTimestamp.toDate().toISOString().split('T')[0];
                             if (scheduledWorkDaysMap.has(recordDateStr)) {
                                 relevantClockIns++;
                                 // Use the status field recorded by recordClockEvent
                                 if (record[STATUS_FIELD] === ON_TIME_STATUS_VALUE) { 
                                     onTimeCount++;
                                 }
                             }
                         }
                    } catch (e) { logger.warn("Error processing clock record for on_time_rate:", e, record); }
                });

                actualValue = (relevantClockIns > 0) ? (onTimeCount / relevantClockIns) : 1.0; 
                logger.info(`On-time calculation: ${onTimeCount} on-time / ${relevantClockIns} relevant clock-ins = ${actualValue}`);
                passed = compareValues(actualValue, operator, value);
                break;
            }'
            case 'absence_days': {
                const scheduledWorkDaysMap = new Map();
                const clockedDaysMap = new Map();
                
                // 寤猴拷??锟界彮宸ワ拷??锟斤拷?锟�?                scheduleRecords.forEach(schedule => {
                    if (schedule[SCHEDULE_SHIFT_FIELD] !== SCHEDULE_DAY_OFF_VALUE) {
                        scheduledWorkDaysMap.set(schedule[SCHEDULE_DATE_FIELD], true);
                    }
                });
                
                // 寤猴拷?宸诧拷??锟芥棩?锟斤拷?锟�?                clockRecords.forEach(record => {
                    try {
                        const recordTimestamp = record[TIMESTAMP_FIELD];
                        if(recordTimestamp && recordTimestamp.toDate) {'
                            const recordDateStr = recordTimestamp.toDate().toISOString().split('T')[0];
                            clockedDaysMap.set(recordDateStr, true);
                        }
                    } catch (e) { logger.warn("Error processing clock record for absence_days:", e, record); }
                });
                
                // 瑷堬拷?缂哄嫟澶╂暩锛堬拷??锟斤拷??锟斤拷??锟斤拷?澶╂暩锟�?                let absenceDays = 0;
                scheduledWorkDaysMap.forEach((_, dateStr) => {
                    if (!clockedDaysMap.has(dateStr)) {
                        absenceDays++;
                    }
                });
                
                actualValue = absenceDays;
                logger.info(`Absence days calculation: ${actualValue} scheduled work days without clock records`);
                passed = compareValues(actualValue, operator, value);
                break;
            }'
            case 'late_count': {
                let lateCount = 0;
                const scheduledWorkDaysMap = new Map();
                
                // 寤猴拷??锟界彮宸ワ拷??锟斤拷?锟�?                scheduleRecords.forEach(schedule => {
                    if (schedule[SCHEDULE_SHIFT_FIELD] !== SCHEDULE_DAY_OFF_VALUE) {
                        scheduledWorkDaysMap.set(schedule[SCHEDULE_DATE_FIELD], schedule[SCHEDULE_SHIFT_FIELD]);
                    }
                });

                clockRecords.forEach(record => {
                     try {
                         const recordTimestamp = record[TIMESTAMP_FIELD];
                         if(recordTimestamp && recordTimestamp.toDate) {'
                             const recordDateStr = recordTimestamp.toDate().toISOString().split('T')[0];
                             if (scheduledWorkDaysMap.has(recordDateStr)) {
                                 // Use the status field recorded by recordClockEvent
                                 if (record[STATUS_FIELD] === LATE_STATUS_VALUE) { 
                                     lateCount++;
                                 }
                             }
                         }
                    } catch (e) { logger.warn("Error processing clock record for late_count:", e, record); }
                });
                actualValue = lateCount;
                logger.info(`Late count calculation: ${actualValue} late records found on scheduled work days`);
                passed = compareValues(actualValue, operator, value);
                break;
            }
            default:
                logger.warn(`Unsupported attendance metric: ${metric}`);
                return { passed: false, dataValue: `涓嶆敮?锟斤拷??锟藉嫟?锟斤拷?: ${metric}` };
        }

        logger.info(`Attendance check result - Metric: ${metric}, Actual: ${actualValue}, Target: ${value}, Operator: ${operator}, Passed: ${passed}`);
        return { passed: passed, dataValue: actualValue };

    } catch (error) {
        logger.error(`Error checking attendance condition for user ${userId}, metric ${metric}:`, error);
        // Return a clear error value
        return { passed: false, dataValue: `妾㈡煡?锟界櫦?锟介尟锟�? ${error.message}` };
    }
}


/**
 * Checks a sales-related condition.'
 * @param {string} userId The employee's ID.'
 * @param {string | null} storeId The employee's store ID (might be needed).
 * @param {string} metric The specific sales metric.
 * @param {string} operator The comparison operator.
 * @param {*} value The target value.
 * @param {string} timePeriod String indicating the period.
 * @param {Date} evaluationDate Date the evaluation is running.
 * @returns {Promise<{passed: boolean, dataValue: any}>}
 */
async function checkSalesCondition(userId, storeId, metric, operator, value, timePeriod, evaluationDate) {
     // --- 瑷堬拷??锟斤拷?绡勶拷? (YYYY-MM) ---
     let yearMonth;
     const evalYear = evaluationDate.getFullYear();
     const evalMonth = evaluationDate.getMonth(); // 0-indexed
'
     if (timePeriod === 'LAST_MONTH') {
         const lastMonthDate = new Date(evalYear, evalMonth - 1, 1);'
         yearMonth = `${lastMonthDate.getFullYear()}-${String(lastMonthDate.getMonth() + 1).padStart(2, '0')}`;'
     } else if (timePeriod === 'CURRENT_MONTH') {'
          yearMonth = `${evalYear}-${String(evalMonth + 1).padStart(2, '0')}`;
     } else {
         logger.warn(`Unsupported timePeriod for sales: ${timePeriod}`);
         return { passed: false, dataValue: null };
     }

    logger.info(`Checking SALES metric: ${metric} for user ${userId} (Store: ${storeId}) for period ${yearMonth}`);

    // --- ASSUMPTIONS: Collection and Field Names for Sales ---
    // PLEASE VERIFY these against your actual Firestore structure.'
    const SALES_REPORTS_COLLECTION = 'sales_reports'; // ASSUMPTION: Monthly store reports collection name.'
    const SALES_RECORDS_COLLECTION = 'sales_records'; // ASSUMPTION: Individual sales records collection name (if used).'
    const STORE_ID_FIELD = 'store';                 // ASSUMPTION: Field name for store ID in reports/records.'
    const USER_ID_FIELD_SALES = 'userId';         // ASSUMPTION: Field name for user ID in individual sales records.'
    const REPORT_MONTH_FIELD = 'month';             // ASSUMPTION: Field name for month (YYYY-MM) in reports.'
    const TARGET_SALES_FIELD = 'target';         // ASSUMPTION: Field name for target sales in reports.'
    const ACTUAL_SALES_FIELD = 'revenue';         // ASSUMPTION: Field name for actual sales in reports.'
    const TOTAL_SALES_FIELD = 'revenue';           // ASSUMPTION: Field name for total sales in reports (might be same as actual).'
    const SALE_AMOUNT_FIELD = 'amount';               // ASSUMPTION: Field name for amount in individual sales records.'
    const SALE_TIMESTAMP_FIELD = 'timestamp';          // ASSUMPTION: Field name for timestamp in individual sales records.


    try {
        let actualValue = null;
        let passed = false;

        // --- 瑷堬拷??锟借集 ---
        switch (metric) {'
            case 'store_target_rate': {
                 if (!storeId) {
                     logger.warn(`Cannot check store_target_rate for user ${userId}: Missing storeId.`);
                     return { passed: false, dataValue: "缂猴拷?搴楅嫪璩囷拷?" };
                 }
                 // ASSUMPTION: Query sales_reports collection for the store and month.
                 const reportQuery = db.collection(SALES_REPORTS_COLLECTION)'
                                      .where(STORE_ID_FIELD, '==', storeId)'
                                      .where(REPORT_MONTH_FIELD, '==', yearMonth)
                                      .limit(1);
                 const reportSnapshot = await reportQuery.get();

                 if (reportSnapshot.empty) {
                      logger.warn(`No sales report found for store ${storeId}, month ${yearMonth}. Assuming 0% target rate.`);
                      actualValue = 0;
                 } else {
                      const reportData = reportSnapshot.docs[0].data();
                      const target = reportData[TARGET_SALES_FIELD];
                      const actual = reportData[ACTUAL_SALES_FIELD];
                      // Ensure target is a positive number to avoid division by zero or meaningless rates.'
                      if (target && typeof target === 'number' && target > 0 && actual && typeof actual === 'number') {
                           actualValue = actual / target;
                      } else {
                           logger.warn(`Missing, invalid, or zero target/actual sales in report for ${storeId}, ${yearMonth}: Target=${target}, Actual=${actual}. Assuming 0% target rate.`);
                           actualValue = 0;
                      }
                 }
                 passed = compareValues(actualValue, operator, value); // Usually >=
                 break;
             }'
            case 'personal_sales_amount': {
                 // ASSUMPTION: Query individual sales_records collection.'
                 const [year, month] = yearMonth.split('-').map(Number);
                 const startDate = new Date(year, month - 1, 1);
                 const endDate = new Date(year, month, 0, 23, 59, 59, 999);

                 const salesQuery = db.collection(SALES_RECORDS_COLLECTION)'
                                      .where(USER_ID_FIELD_SALES, '==', userId)'
                                      .where(SALE_TIMESTAMP_FIELD, '>=', startDate)'
                                      .where(SALE_TIMESTAMP_FIELD, '<=', endDate);
                 const salesSnapshot = await salesQuery.get();
                 actualValue = 0;
                 salesSnapshot.forEach(doc => {
                      const saleData = doc.data();'
                      if (saleData[SALE_AMOUNT_FIELD] && typeof saleData[SALE_AMOUNT_FIELD] === 'number') {
                          actualValue += saleData[SALE_AMOUNT_FIELD];
                      }
                 });
                 passed = compareValues(actualValue, operator, value); // Usually >=
                 break;
            }'
             case 'store_total_sales': {
                 if (!storeId) {
                      logger.warn(`Cannot check store_total_sales for user ${userId}: Missing storeId.`);
                     return { passed: false, dataValue: "缂猴拷?搴楅嫪璩囷拷?" };
                 }
                 // ASSUMPTION: Query sales_reports collection.
                 const reportQuery = db.collection(SALES_REPORTS_COLLECTION)'
                                      .where(STORE_ID_FIELD, '==', storeId)'
                                      .where(REPORT_MONTH_FIELD, '==', yearMonth)
                                      .limit(1);
                 const reportSnapshot = await reportQuery.get();

                 if (reportSnapshot.empty) {
                      logger.warn(`No sales report found for store ${storeId}, month ${yearMonth}. Assuming 0 total sales.`);
                      actualValue = 0;
                 } else {
                      const reportData = reportSnapshot.docs[0].data();
                      // Use the assumed field name for total sales.
                      actualValue = reportData[TOTAL_SALES_FIELD] ?? 0;
                 }
                 passed = compareValues(actualValue, operator, value); // Usually >=
                 break;
             }'
            case 'average_sale_amount': {
                 // 瑷堬拷??锟芥埗骞筹拷?瑷傚柈?锟斤拷?'
                 const [year, month] = yearMonth.split('-').map(Number);
                 const startDate = new Date(year, month - 1, 1);
                 const endDate = new Date(year, month, 0, 23, 59, 59, 999);

                 const salesQuery = db.collection(SALES_RECORDS_COLLECTION)'
                                      .where(USER_ID_FIELD_SALES, '==', userId)'
                                      .where(SALE_TIMESTAMP_FIELD, '>=', startDate)'
                                      .where(SALE_TIMESTAMP_FIELD, '<=', endDate);
                 const salesSnapshot = await salesQuery.get();
                 
                 if (salesSnapshot.empty) {
                     logger.warn(`No sales records found for user ${userId}, period ${yearMonth}. Assuming 0 average sale amount.`);
                     actualValue = 0;
                 } else {
                     let totalAmount = 0;
                     let recordCount = 0;
                     
                     salesSnapshot.forEach(doc => {
                         const saleData = doc.data();'
                         if (saleData[SALE_AMOUNT_FIELD] && typeof saleData[SALE_AMOUNT_FIELD] === 'number') {
                             totalAmount += saleData[SALE_AMOUNT_FIELD];
                             recordCount++;
                         }
                     });
                     
                     actualValue = recordCount > 0 ? totalAmount / recordCount : 0;
                     logger.info(`Average sale calculation: ${totalAmount} total / ${recordCount} records = ${actualValue}`);
                 }
                 
                 passed = compareValues(actualValue, operator, value);
                 break;
            }'
            case 'sales_count': {'
                 // 瑷堬拷??锟芥埗瀹岋拷??锟介姺?锟芥暩??                 const [year, month] = yearMonth.split('-').map(Number);
                 const startDate = new Date(year, month - 1, 1);
                 const endDate = new Date(year, month, 0, 23, 59, 59, 999);

                 const salesQuery = db.collection(SALES_RECORDS_COLLECTION)'
                                      .where(USER_ID_FIELD_SALES, '==', userId)'
                                      .where(SALE_TIMESTAMP_FIELD, '>=', startDate)'
                                      .where(SALE_TIMESTAMP_FIELD, '<=', endDate);
                 const salesSnapshot = await salesQuery.get();
                 
                 actualValue = salesSnapshot.size;
                 logger.info(`Sales count: ${actualValue} sales records found for user ${userId} in period ${yearMonth}`);
                 
                 passed = compareValues(actualValue, operator, value);
                 break;
            }
            default:
                logger.warn(`Unsupported sales metric: ${metric}`);
                return { passed: false, dataValue: `涓嶆敮?锟斤拷??锟藉敭?锟斤拷?: ${metric}` };
        }

        logger.info(`Sales check result - Metric: ${metric}, Actual: ${actualValue}, Target: ${value}, Operator: ${operator}, Passed: ${passed}`);
        return { passed: passed, dataValue: actualValue };

    } catch (error) {
        logger.error(`Error checking sales condition for user ${userId}, metric ${metric}:`, error);
        return { passed: false, dataValue: `妾㈡煡?锟界櫦?锟介尟锟�? ${error.message}` };
    }
}


/**
 * Main function to check a single condition. Routes based on type.
 * Called by evaluateTaskForEmployee.
 *
 * Determines the evaluation month string (YYYY-MM) based on config.
 * @param {object} evaluationConfig - The evaluation config object from the bonus task.'
 * @returns {string|null} - YYYY-MM string or null if config is invalid or type isn't MONTHLY.
 */
function getEvaluationMonthString(evaluationConfig) {
    logger.warn(`浣跨敤宸诧拷??锟斤拷? getEvaluationMonthString ?锟斤拷?瀹氱京?锟斤拷??锟芥柊瑾跨敤浠ヤ娇?锟斤拷???066琛岋拷??锟斤拷??锟芥暩?锟絗);'
    // 瑾跨敤?锟斤拷??锟芥暩浠ワ拷??锟斤拷??锟斤拷?    if (typeof global.getEvaluationMonthString === 'function') {
        return global.getEvaluationMonthString(evaluationConfig);
    }
    
    // ?锟斤拷?淇濓拷?瀵︾従?锟借集锛屼互?锟借惉涓€?锟斤拷??锟藉叏灞€?锟芥暩'
    if (!evaluationConfig || evaluationConfig.triggerType !== 'MONTHLY') {
        logger.warn("Cannot get evaluation month: Invalid config or triggerType is not MONTHLY.", { evaluationConfig });
        return null;
    }
    try {
        const currentDate = new Date();
        // If we have a specific month in the config, use it
        if (evaluationConfig.targetMonth) {
            return evaluationConfig.targetMonth;
        }
        
        // Otherwise calculate from the current date'
        const targetMonth = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;
        logger.info(`Using current month for evaluation: ${targetMonth}`);
        return targetMonth;
    } catch (error) {
        logger.error("Error determining evaluation month:", error);
        return null;
    }
}

/**
 * Scheduled function to evaluate bonus tasks.
 * Triggered daily, checks internally if tasks are due based on their config.
 */
exports.evaluateBonusTasksScheduled = onSchedule({
    schedule: "every day 03:00", // Runs daily at 3 AM Taipei time
    timeZone: "Asia/Taipei",
    // secrets: [...] // Add secrets needed by condition checks if any (e.g., external API keys)
    timeoutSeconds: 540, // Max timeout for scheduled functions'
    memory: '1GiB' // Adjust memory if needed for processing many users/tasks
}, async (event) => {
    // (姝ゅ嚱?锟藉収瀹癸拷?涔嬶拷??锟斤拷??锟斤拷?锟�??瑾跨敤 evaluateSingleTaskForAllEmployees)
    logger.info("Starting scheduled bonus task evaluation run...");
    const startTime = Date.now();'
    const now = new Date(); // Use a consistent 'now' for checks within this run
    const todayDay = now.getDate(); // Day of the month (1-31)
    let tasksEvaluatedCount = 0;

    // Log start of the system task'
    await logActivity({ userId: 'system', feature: 'ScheduledTask', action: 'evaluateBonusTasksScheduledStart', details: `Run started at ${now.toISOString()}`, success: true });

    try {'
        // ASSUMPTION: Bonus tasks are stored in 'bonus_tasks' collection.'
        const tasksSnapshot = await db.collection('bonus_tasks')'
                                      .where('isActive', '==', true) // Only evaluate active tasks'
                                      .where('evaluationConfig.triggerType', '==', 'MONTHLY') // Currently only supports monthly triggers
                                      .get();

        if (tasksSnapshot.empty) {
            logger.info("No active monthly bonus tasks found to evaluate today.");
            // Log completion even if no tasks found
            const duration = Date.now() - startTime;'
            await logActivity({ userId: 'system', feature: 'ScheduledTask', action: 'evaluateBonusTasksScheduledComplete', details: `Run finished in ${duration}ms. No active monthly tasks found.`, success: true });
            return; // Exit if no tasks
        }

        logger.info(`Found ${tasksSnapshot.size} active monthly bonus tasks.`);

        const evaluationPromises = [];

        tasksSnapshot.forEach(taskDoc => {
            const task = { id: taskDoc.id, ...taskDoc.data() };
            const evalConfig = task.evaluationConfig;

            // Basic validation of task data
            if (!evalConfig || !evalConfig.evaluationFrequency) {
                 logger.warn(`Task ${task.id} [${task.name}] is missing evaluationConfig or evaluationFrequency, skipping.`);
                 return; // Skip task if essential config is missing
            }

            // Determine if this task should be evaluated today based on its frequency setting
            let shouldEvaluateToday = false;'
            if (evalConfig.evaluationFrequency === 'START_OF_MONTH') {
                 // Evaluate if today is the 1st day of the month
                if (todayDay === 1) {
                    shouldEvaluateToday = true;
                }'
            } else if (evalConfig.evaluationFrequency === 'END_OF_MONTH') {
                // Evaluate if today is the *last* day of the current month
                const lastDayOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0).getDate();
                if (todayDay === lastDayOfMonth) {
                    shouldEvaluateToday = true;
                }
            } else {
                logger.warn(`Task ${task.id} [${task.name}] has unsupported evaluationFrequency: ${evalConfig.evaluationFrequency}, skipping.`);
                return; // Skip if frequency is unknown
            }

            // If today is the evaluation day for this task, add its evaluation to the promises
            if (shouldEvaluateToday) {
                logger.info(`Task [${task.name}] (${task.id}) is scheduled for evaluation today (Frequency: ${evalConfig.evaluationFrequency}). Queueing evaluation.`);
                // Queue the function that evaluates this task for all employees
                evaluationPromises.push(evaluateSingleTaskForAllEmployees(task));
                tasksEvaluatedCount++;
            } else {
                 logger.info(`Task [${task.name}] (${task.id}) is not scheduled for evaluation today (Frequency: ${evalConfig.evaluationFrequency}, Today: ${todayDay}).`);
            }
        });

        // Wait for all queued task evaluations to complete
        if (evaluationPromises.length > 0) {
             logger.info(`Waiting for ${evaluationPromises.length} task evaluations to complete...`);
            await Promise.all(evaluationPromises);
             logger.info(`All ${evaluationPromises.length} scheduled task evaluations completed.`);
        } else {
             logger.info("No tasks were due for evaluation today.");
        }

        const duration = Date.now() - startTime;
        logger.info(`Scheduled bonus task evaluation run finished in ${duration}ms. Evaluated ${tasksEvaluatedCount} tasks.`);
        // Log successful completion'
        await logActivity({ userId: 'system', feature: 'ScheduledTask', action: 'evaluateBonusTasksScheduledComplete', details: `Run finished in ${duration}ms. Processed ${tasksEvaluatedCount} tasks scheduled for today.`, success: true });


    } catch (error) {
        const duration = Date.now() - startTime;
        logger.error("Critical error during scheduled bonus task evaluation run:", error);
        // Log failure'
        await logActivity({ userId: 'system', feature: 'ScheduledTask', action: 'evaluateBonusTasksScheduledError', details: `Run failed after ${duration}ms: ${error.message}`, success: false });
        // Re-throwing the error might be appropriate depending on desired function behavior on failure
        // throw error;
    }
});

// --- Make sure to export the new scheduled function ---'
// (If you use a central module.exports = {}, add 'evaluateBonusTasksScheduled' there.
// Since you use exports.funcName = ..., the line above already does the export.)

// --- ?锟藉崱?锟斤拷??锟芥暩 (HTTPS Callable) ---
exports.recordClockEvent = onCall({
    secrets: [LINE_OA_TOKEN_PARAM, TELEGRAM_BOT_TOKEN_PARAM], // Add secrets if needed by notifications inside'
    region: 'asia-east2' // Specify your function region
}, async (request) => {'
    logger.info("recordClockEvent received:", { data: request.data, auth: request.auth ? request.auth.uid : 'No auth' });

    // 1. 椹楋拷??锟芥埗韬�浠�
    if (!request.auth) {
        logger.warn("recordClockEvent: Authentication required.");'
        throw new HttpsError('unauthenticated', '?锟借�侊拷?璀夎韩浠斤拷??锟斤拷???);
    }
    
    // 娆婏拷?妾㈡煡 - ?锟斤拷??锟斤拷?Level 1 (?锟介€氬摗锟�? 娆婏拷?
    const requiredLevel = 1;
    if (request.auth.token.level === undefined || request.auth.token.level < requiredLevel) {
        logger.warn(`recordClockEvent: Insufficient permission level ${request.auth.token.level}`);'
        throw new HttpsError('permission-denied', '娆婏拷?涓嶈冻锛岀劇娉曪拷???);
    }
    
    const userId = request.auth.uid;

    // --- 姝ワ拷?涓€锛氱嵅?锟借ō瀹氾拷?搴楋拷?璩囷拷? ---
    let settingsData = {};
    let storeData = null;
    let parsedRadii = {};
    let parsedHours = {};
    const selectedStoreId = request.data?.storeId; // Get store ID from request
    const userLocation = request.data?.location; // Get location from request

    if (!selectedStoreId) {
        logger.warn(`recordClockEvent: Missing storeId in request data for user ${userId}.`);'
        throw new HttpsError('invalid-argument', '?锟藉崱璜嬶拷?涓�缂哄皯锟�?搴楋拷?锟�?);
    }
    // Location is optional for check if radius is unlimited, but needed otherwise
    if (!userLocation || userLocation.latitude == null || userLocation.longitude == null) {
         logger.warn(`recordClockEvent: Missing location data in request for user ${userId}. Radius check might fail if required.`);'
         // We'll check later if the radius requires location
    }


    try {
        // CORRECTED: Read from store_config instead of clockinConfig'
        const settingsRef = db.collection('settings').doc('store_config');
        // REMOVED: No longer fetching storeRef separately'
        // const storeRef = db.collection('stores').doc(selectedStoreId); 

        const settingsSnap = await settingsRef.get();

        if (settingsSnap.exists) {
            settingsData = settingsSnap.data();
            // --- Store List Parsing (Server-side) ---
            if (settingsData.storeListString) {
                 const parsedStores = parseStoreListStringServer(settingsData.storeListString); 
                 // Find the data for the selected store
                 storeData = parsedStores.find(store => store.id === selectedStoreId); 
                 if (storeData) {
                      logger.info(`Found location data for selected store ${selectedStoreId} from storeListString.`);
                      // Check if lat/lon exist (should be handled by parser)
                      if (storeData.latitude == null || storeData.longitude == null) {
                           logger.error(`Parsed store data for ${selectedStoreId} is missing latitude/longitude.`);'
                           throw new HttpsError('internal', `?锟斤拷??锟斤拷??锟斤拷???(${selectedStoreId}) 缂猴拷?浣嶇疆璩囷拷?`);
                      }
                 } else {
                      logger.error(`Selected storeId ${selectedStoreId} not found in parsed storeListString.`);'
                      throw new HttpsError('not-found', `?锟界郴绲辫ō瀹氫腑?锟斤拷??锟芥��?锟斤拷?(${selectedStoreId})?锟斤拷?缃�锟�?瑷娿€俙);
                 }
            } else {'
                 logger.error("'storeListString' field missing in settings/store_config. Cannot verify location.");'
                 throw new HttpsError('failed-precondition', '绯荤当缂猴拷?蹇咃拷??锟斤拷?搴楋拷?琛ㄨō瀹氾拷??锟斤拷?椹楋拷?浣嶇疆');
            }
            // --- End Store List Parsing ---

            parsedRadii = parseGeofenceRadiiServer(settingsData.storeGeofenceRadius);
            parsedHours = parseOperatingHoursServer(settingsData.storeOperatingHours);
            logger.info(`Fetched and parsed clockin settings for store ${selectedStoreId}.`);
        } else {
            // Changed warning message to reflect the new source
            logger.warn("Main settings document (settings/store_config) not found. Assuming no restrictions.");
            // If settings doc is missing, we also lack storeListString, so throw error.'
            throw new HttpsError('failed-precondition', '?锟斤拷??锟戒富瑕佽ō瀹氾拷?锟�?settings/store_config)锛岀劇娉曢€诧拷??锟藉崱椹楋拷?');
        }

    } catch (error) {
        logger.error(`Error fetching settings or store data for ${selectedStoreId}:`, error);
        if (error instanceof HttpsError) throw error;'
        throw new HttpsError('internal', '璁€?锟斤拷??锟借ō瀹氾拷?搴楋拷?璩囷拷??锟界櫦?锟介尟锟�?);
    }
    // --- End 瑷�锟�?璁€??---


    // --- 姝ワ拷?浜岋拷?浼猴拷??锟界��椹楋拷? --- 
    // 1. 浣嶇疆椹楋拷?
    const radiusLimit = parsedRadii[selectedStoreId] ?? UNLIMITED_RADIUS_SERVER;
    if (radiusLimit !== UNLIMITED_RADIUS_SERVER) {
        if (!userLocation || userLocation.latitude == null || userLocation.longitude == null) {
             logger.warn(`recordClockEvent: Geofence check failed for ${userId} at ${selectedStoreId} - Location data missing from request.`);'
             throw new HttpsError('invalid-argument', '?锟藉崱绡勶拷??锟借�侊拷?璀夛拷?浣嗭拷?姹備腑缂猴拷??锟斤拷?浣嶇疆璩囷拷?');
        }
        const distance = calculateDistance(
            userLocation.latitude,
            userLocation.longitude,
            storeData.latitude,
            storeData.longitude
        );
        logger.info(`Geofence check for ${userId} at ${selectedStoreId}: Distance=${distance.toFixed(1)}m, Limit=${radiusLimit}m`);
        if (distance > radiusLimit) {
            logger.warn(`recordClockEvent: Geofence check failed for ${userId}. Distance ${distance.toFixed(1)}m > Limit ${radiusLimit}m.`);
            // Use storeData.name if available, otherwise storeId
            const storeDisplayName = storeData?.name || selectedStoreId;'
            throw new HttpsError('failed-precondition', `?锟界洰?锟介洟"${storeDisplayName}"(${distance.toFixed(0)}锟�?瓒呭嚭?锟借ū?锟斤拷???${radiusLimit}锟�?`);
        }
    } else {
         logger.info(`Geofence check skipped for ${userId} at ${selectedStoreId} (unlimited radius).`);
    }

    // 2. ?锟芥キ?锟斤拷?椹楋拷?
    const storeOperatingHoursList = parsedHours[selectedStoreId]; // Get the list of ranges for this store
    if (storeOperatingHoursList && storeOperatingHoursList.length > 0) { // Only check if hours are defined
        if (!isWithinOperatingHoursServer(storeOperatingHoursList)) {
            logger.warn(`recordClockEvent: Operating hours check failed for ${userId} at ${selectedStoreId}.`);'
             const hoursString = storeOperatingHoursList.map(r => `${String(r.start.hours).padStart(2,'0')}:${String(r.start.minutes).padStart(2,'0')}-${String(r.end.hours).padStart(2,'0')}:${String(r.end.minutes).padStart(2,'0')}`).join(', ');
             const storeDisplayName = storeData?.name || selectedStoreId;'
            throw new HttpsError('failed-precondition', `?锟斤拷??锟斤拷?涓嶅湪"${storeDisplayName}"?锟芥キ?锟斤拷????锟借ū:${hoursString})`);
        }
        logger.info(`Operating hours check passed for ${userId} at ${selectedStoreId}.`);
    } else {
        logger.info(`Operating hours check skipped for ${userId} at ${selectedStoreId} (no hours defined).`);
    }
    // --- End 浼猴拷??锟界��椹楋拷? ---

    // 3. ?锟斤拷??锟芥埗璩囷拷? (?锟介伕锛岀敤?锟介’绀猴拷?瑷橈拷?)'
    let userName = '?锟界煡?锟芥埗';
    try {
        const userRecord = await auth.getUser(userId);
        userName = userRecord.displayName || userRecord.email || userId; // Use display name, email, or UID'
        // ?锟借€咃拷? Firestore ??'employees' ??'users' 琛ㄤ腑?锟斤拷??锟借┏绱帮拷???'
        // const employeeDoc = await db.collection('employees').doc(userId).get();
        // if (employeeDoc.exists) {
        //     userName = employeeDoc.data().name || userName;
        // }
    } catch (error) {
        logger.error(`recordClockEvent: Error fetching user data for ${userId}:`, error);
        // Decide if this is critical. If not, continue with default userName.
    }

    // 4. 姹猴拷??锟藉崱?锟斤拷?椤烇拷?'
    let determinedAction = 'clockIn'; // 榛橈拷?涓婄彮
    try {'
        const lastRecordSnapshot = await db.collection('clock_records')'
            .where('userId', '==', userId)'
            .orderBy('timestamp', 'desc')
            .limit(1)
            .get();

        if (!lastRecordSnapshot.empty) {
            const lastRecord = lastRecordSnapshot.docs[0].data();'
            if (lastRecord.action === 'clockIn') {'
                determinedAction = 'clockOut'; // 濡傦拷?涓婏拷?绛嗘槸涓婄彮锛岄€欐�″氨鏄�涓嬬彮
            }
            // 濡傦拷?涓婏拷?绛嗘槸涓嬬彮锛岄€欐�′粛鐒朵笂鐝�(determinedAction 涓嶏拷?)
        }
        logger.info(`recordClockEvent: Determined action for ${userId}: ${determinedAction}`);
    } catch (error) {
        logger.error(`recordClockEvent: Error fetching last clock record for ${userId}:`, error);'
        throw new HttpsError('internal', '璁€?锟斤拷?娆★拷??锟斤拷??锟藉嚭?锟斤拷??锟斤拷?纰猴拷??锟斤拷?');
    }

    // 5. 婧栵拷??锟藉崱瑷橈拷??锟斤拷?
    const serverTimestamp = FieldValue.serverTimestamp(); // Use server timestamp for the record
    const clockRecordData = {
        userId: userId,
        userName: userName, // Use fetched username'
        action: determinedAction, // 'clockIn' or 'clockOut'
        timestamp: serverTimestamp, // IMPORTANT: Use server time'
        source: 'web_app', // Mark the source
        storeId: selectedStoreId, // --- ADDED: Record the store ID --- 
        location: request.data.location || null, // Optional location data from client
        // validatedLocationId: request.data.validatedLocationId || null // This was likely meant for client-side info, server validation is done above'
        // status field will be added below if it's a clock-in
    };

    // 6. 濡傦拷??锟斤拷??锟斤拷??锟斤拷??锟借│?锟芥柗涓︼拷?瑷橈拷???婧栵拷?/?锟藉埌)'
    if (determinedAction === 'clockIn') {
        try {
            // ?锟斤拷??锟斤拷??锟斤拷??锟斤拷?绗︿覆 YYYY-MM-DD ?锟斤拷?
            const now = new Date();'
            const dateStr = now.toISOString().split('T')[0]; // e.g., "2025-04-14"
            
            // 锟�?Firestore ?锟斤拷??锟藉ぉ?锟界彮锟�?'
            const scheduleRef = db.collection('schedules').doc(dateStr);
            const scheduleDoc = await scheduleRef.get();
            
            // 瑷�缃�榛橈拷??锟�?锟界偤"?锟斤拷???'
            let clockStatus = '?锟斤拷???;
            let scheduledTime = null;
            
            if (scheduleDoc.exists) {
                const scheduleData = scheduleDoc.data();
                
                // 灏嬫壘姝ょ敤?锟界暥澶╋拷??锟界彮
                // 娉�锟�?锛氶€欒！?锟斤拷?妲嬶拷?璩存柤瀵︼拷??锟界彮琛�锟�?妲嬶拷??锟借兘?锟借�佹牴?锟藉��?锟藉��?锟借��??
                if (scheduleData.assignments && scheduleData.assignments[selectedStoreId]) {
                    // ?锟借ō?锟斤拷???assignments[storeId][userId] ??assignments[storeId][position][userId]
                    // 浠ワ拷??锟借集?锟芥槸绀猴拷?锛岋拷?瑕佹牴?锟藉��?锟斤拷??锟借〃绲愶拷?瑾挎暣
                    let userSchedule = null;
                    
                    // ?锟芥帴绱�锟�? (濡傦拷??锟借〃绲愶拷???assignments[storeId][userId])
                    if (scheduleData.assignments[selectedStoreId][userId]) {
                        userSchedule = scheduleData.assignments[selectedStoreId][userId];
                    } else {
                        // ?锟借│?锟斤拷??锟芥�锋瘡鍊嬭伔浣嶆壘?锟界敤??(濡傦拷??锟借〃绲愶拷???assignments[storeId][position][userId])
                        const positions = Object.keys(scheduleData.assignments[selectedStoreId]);
                        for (const position of positions) {
                            const positionData = scheduleData.assignments[selectedStoreId][position];
                            if (positionData && positionData[userId]) {
                                userSchedule = positionData[userId];
                                break;
                            }
                        }
                    }
                    
                    // 濡傦拷??锟藉埌?锟界彮
                    if (userSchedule) {
                        // ?锟斤拷??锟斤拷?涓婄彮?锟斤拷?
                        scheduledTime = userSchedule.startTime; // ?锟借ō绲愶拷?涓�锟�? startTime 娆勶拷?
                        
                        // 瑷堬拷??锟藉埌?锟藉惁
                        if (scheduledTime) {
                            // 锟�???锟斤拷??锟斤拷??锟斤拷???(?锟借ō?锟斤拷???"HH:MM")'
                            const [scheduledHour, scheduledMinute] = scheduledTime.split(':').map(Number);
                            
                            // ?锟藉缓?锟斤拷?涓婄彮?锟斤拷???Date 灏嶈薄
                            const scheduledDate = new Date(now);
                            scheduledDate.setHours(scheduledHour, scheduledMinute, 0, 0);
                            
                            // 瑷堬拷?瀵︼拷??锟藉崱?锟斤拷??锟斤拷?瀹氾拷??锟斤拷?宸�锟�?锛堬拷??锟斤拷?
                            const diffMinutes = Math.floor((now.getTime() - scheduledDate.getTime()) / (1000 * 60));
                            
                            // 瀹氱京瀵�锟�??锟斤拷? (渚嬶拷?锟�?0?锟斤拷?)
                            const graceMinutes = 10;
                            
                            // ?锟斤拷??锟藉崱?锟�??
                            if (diffMinutes <= graceMinutes) {'
                                clockStatus = '婧栵拷?';
                            } else {'
                                clockStatus = '?锟藉埌';
                                // ?锟戒互瑷橈拷??锟藉埌?锟斤拷??锟芥暩
                                clockRecordData.lateMinutes = diffMinutes;
                            }
                            
                            // 瑷橈拷??锟斤拷??锟斤拷???
                            clockRecordData.scheduledTime = scheduledTime;
                        }
                    }
                }
            }
            
            // 瑷�缃�?锟�??
            clockRecordData.status = clockStatus;
            
        } catch (error) {
            logger.error(`Error checking schedule for user ${userId}:`, error);
            // ?锟斤拷??锟借��?锟借ō榛橈拷??锟�?锟借€岋拷??锟斤拷??锟芥暣?锟藉嚱?锟藉け??'
            clockRecordData.status = '?锟界煡?锟�??;
            clockRecordData.scheduleError = error.message;
        }'
    } else if (determinedAction === 'clockOut') {
        // 涓嬬彮?锟藉崱?锟借集
        try {
            // ?锟芥壘?锟藉ぉ?锟斤拷??锟斤拷??锟斤拷???
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            '
            const clockInRecordsQuery = await db.collection('clock_records')'
                .where('userId', '==', userId)'
                .where('action', '==', 'clockIn')'
                .where('timestamp', '>=', admin.firestore.Timestamp.fromDate(today))'
                .orderBy('timestamp', 'desc')
                .limit(1)
                .get();
                
            if (!clockInRecordsQuery.empty) {
                const clockInRecord = clockInRecordsQuery.docs[0].data();
                const clockInTime = clockInRecord.timestamp.toDate();
                
                // 瑷堬拷?宸ワ拷??锟芥暩 (灏忥拷?)
                const workHours = (now.getTime() - clockInTime.getTime()) / (1000 * 60 * 60);
                clockRecordData.workHours = parseFloat(workHours.toFixed(2));
                
                // 濡傦拷??锟斤拷??锟斤拷?瑷婏拷??锟戒互瑷堬拷??锟藉惁?锟介€€
                // 姝わ拷??锟借集?锟芥牴?锟斤拷?姹傦拷??锟斤拷?
                if (clockInRecord.scheduledTime) {
                    // ?锟斤拷??锟斤拷??锟斤拷??锟界彮锟�?'
                    const dateStr = today.toISOString().split('T')[0];'
                    const scheduleDoc = await db.collection('schedules').doc(dateStr).get();
                    
                    if (scheduleDoc.exists) {
                        // ?锟斤拷??锟借〃?锟芥柗?锟藉惁?锟介€€
                        // 瀵︼拷??锟借集?锟芥焙?锟界彮琛�锟�?锟�?
                        // ?锟借！?锟芥槸绀猴拷?'
                        clockRecordData.status = '锟�?锟斤拷'; // 榛橈拷??锟�??
                    }
                }
            } else {
                // 娌掞拷??锟藉埌?锟藉ぉ?锟斤拷??锟斤拷??锟斤拷???'
                clockRecordData.status = '?锟藉父涓嬬彮';
                logger.warn(`User ${userId} clocked out without a matching clock-in record for today.`);
            }
        } catch (error) {
            logger.error(`Error processing clock-out for user ${userId}:`, error);'
            clockRecordData.status = '?锟斤拷??锟介尟';
        }
    }

    // 7. 瀵�鍏�?锟藉崱瑷橈拷???Firestore
    try {'
        const clockRecordRef = await db.collection('clock_records').add(clockRecordData);
        logger.info(`Successfully recorded ${determinedAction} event for ${userId} with ID: ${clockRecordRef.id}`);
        
        // 杩旓拷??锟斤拷?绲愶拷??锟斤拷??锟斤拷???ID
        return {
            success: true,
            recordId: clockRecordRef.id,
            action: determinedAction,
            status: clockRecordData.status || null,
            timestamp: new Date().toISOString() // 绲︼拷?绔�锟�??锟斤拷??锟斤拷???
        };
    } catch (error) {
        logger.error(`Failed to record clock event for ${userId}:`, error);'
        throw new HttpsError('internal', `?锟藉崱瑷橈拷?淇濓拷?澶憋拷?: ${error.message}`);
    }
});

// --- ??锟�?????锟�?璺濋洟 (Haversine) ---
function calculateDistance(lat1, lon1, lat2, lon2) {
    if (lat1 == null || lon1 == null || lat2 == null || lon2 == null) {
        return Infinity; // Cannot calculate if coordinates are missing
    }
    const R = 6371e3; // metres
    const ?1 = lat1 * Math.PI / 180; // ?, 位 in radians
    const ?2 = lat2 * Math.PI / 180;
    const ?? = (lat2 - lat1) * Math.PI / 180;
    const ?位 = (lon2 - lon1) * Math.PI / 180;

    const a = Math.sin(?? / 2) * Math.sin(?? / 2) +
        Math.cos(?1) * Math.cos(?2) *
        Math.sin(?位 / 2) * Math.sin(?位 / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    return R * c; // in metres
}

// --- ??锛氳В??寰戣ō锟�?杓斿姪???(Server-side version) ---
function parseGeofenceRadiiServer(radiiString) {
    const radii = {};'
    if (!radiiString || typeof radiiString !== 'string') return radii;
'
    radiiString.split(';').forEach(part => {
        part = part.trim();
        if (!part) return;
        const match = part.match(/^([^0-9]+)(\d+)?$/);
        if (match) {
            const storeName = match[1].trim();
            const radiusValue = match[2] ? parseInt(match[2], 10) : UNLIMITED_RADIUS_SERVER;
            if (storeName) {
                 radii[storeName] = isNaN(radiusValue) ? UNLIMITED_RADIUS_SERVER : radiusValue;
            }
        } else if (/^[^0-9]+$/.test(part)) {
             const storeName = part.trim();
             if(storeName) radii[storeName] = UNLIMITED_RADIUS_SERVER;
        }
    });
    return radii;
}

// --- ??锛氳В??锟�?瑷�锟�??杓斿姪???(Server-side version) ---
function parseOperatingHoursServer(hoursString) {
    const hours = {};'
    if (!hoursString || typeof hoursString !== 'string') return hours;
'
    hoursString.split(';').forEach(part => {
        part = part.trim();
        if (!part) return;
        const firstDigitIndex = part.search(/\d/);'
        let storeName = '';'
        let timeRangesStr = '';
        if (firstDigitIndex > 0) {
             storeName = part.substring(0, firstDigitIndex).trim();
             timeRangesStr = part.substring(firstDigitIndex).trim();
        } else if (firstDigitIndex === -1 && /^[^,;-]+$/.test(part)){
             storeName = part.trim();'
             timeRangesStr = '';
        } else {
             return;
        }
        if (!storeName) return;
        const timeRanges = [];
        if (timeRangesStr) {'
            timeRangesStr.split(',').forEach(rangeStr => {
                rangeStr = rangeStr.trim();'
                const times = rangeStr.split('-');
                if (times.length === 2) {
                    const startStr = times[0].trim();
                    const endStr = times[1].trim();
                    if (/^\d{4}$/.test(startStr) && /^\d{4}$/.test(endStr)) {
                        try {
                             const startH = parseInt(startStr.substring(0, 2), 10);
                             const startM = parseInt(startStr.substring(2, 4), 10);
                             const endH = parseInt(endStr.substring(0, 2), 10);
                             const endM = parseInt(endStr.substring(2, 4), 10);
                             if (startH >= 0 && startH < 24 && startM >= 0 && startM < 60 &&
                                 endH >= 0 && endH < 24 && endM >= 0 && endM < 60) {
                                timeRanges.push({ start: { hours: startH, minutes: startM }, end: { hours: endH, minutes: endM } });
                             } else { logger.warn(`Invalid time range values in "${rangeStr}" for store "${storeName}"`); }
                        } catch (e) { logger.warn(`Error parsing time range "${rangeStr}" for store "${storeName}":`, e); }
                    } else { logger.warn(`Invalid HHMM format in "${rangeStr}" for store "${storeName}"`); }'
                } else { logger.warn(`Invalid time range format (no '-') in "${rangeStr}" for store "${storeName}"`); }
            });
        }
         hours[storeName] = timeRanges;
    });
    return hours;
}

// --- ??锛氭��??锟藉惁???锟�???(Server-side version, uses JS Date) ---
function isWithinOperatingHoursServer(storeHoursList) {
     if (!storeHoursList || storeHoursList.length === 0) {
         return true; // If no hours defined, assume always open
     }
'
     const now = new Date(); // Server's current time
     const currentMinutes = now.getHours() * 60 + now.getMinutes();

     for (const range of storeHoursList) {
         const startMinutes = range.start.hours * 60 + range.start.minutes;
         let endMinutes = range.end.hours * 60 + range.end.minutes;
         if (endMinutes < startMinutes) { // Overnight range
             if (currentMinutes >= startMinutes || currentMinutes < endMinutes) {
                 return true;
             }
         } else { // Normal range
             if (currentMinutes >= startMinutes && currentMinutes < endMinutes) {
                 return true;
             }
         }
     }
     return false; // Not within any range
}

// --- End of New Helpers ---

// --- ADDED: Server-side parser for storeListString --- 
function parseStoreListStringServer(storeString) {
     const locations = [];'
     if (!storeString || typeof storeString !== 'string') return locations;'
     storeString.split(';').forEach(part => {
          part = part.trim();
          if (!part) return;'
          const eqIndex = part.indexOf('=');
          if (eqIndex === -1) return;
          const namePart = part.substring(0, eqIndex).trim();
          const coordsPart = part.substring(eqIndex + 1).trim();
          const nameMatch = namePart.match(/^([^0-9]+)/);
          const storeName = nameMatch ? nameMatch[1].trim() : namePart;'
          const coords = coordsPart.split(',');
          if (coords.length === 2) {
               const lat = parseFloat(coords[0].trim());
               const lon = parseFloat(coords[1].trim());
               if (!isNaN(lat) && !isNaN(lon) && storeName) {
                    locations.push({ id: storeName, name: storeName, latitude: lat, longitude: lon });
               }
          }
     });
     return locations;
}
// --- End of Added Helper ---

/**
 * Main function to check a single condition. Routes based on type.
 * Called by evaluateTaskForEmployee.
 *
 * Determines the evaluation month string (YYYY-MM) based on config.
 * @param {object} evaluationConfig - The evaluation config object from the bonus task.'
 * @returns {string|null} - YYYY-MM string or null if config is invalid or type isn't MONTHLY.
 */
function getEvaluationMonthString(evaluationConfig) {
    logger.warn(`浣跨敤宸诧拷??锟斤拷? getEvaluationMonthString ?锟斤拷?瀹氱京?锟斤拷??锟芥柊瑾跨敤浠ヤ娇?锟斤拷???066琛岋拷??锟斤拷??锟芥暩?锟絗);'
    // 瑾跨敤?锟斤拷??锟芥暩浠ワ拷??锟斤拷??锟斤拷?    if (typeof global.getEvaluationMonthString === 'function') {
        return global.getEvaluationMonthString(evaluationConfig);
    }
    
    // ?锟斤拷?淇濓拷?瀵︾従?锟借集锛屼互?锟借惉涓€?锟斤拷??锟藉叏灞€?锟芥暩'
    if (!evaluationConfig || evaluationConfig.triggerType !== 'MONTHLY') {
        logger.warn("Cannot get evaluation month: Invalid config or triggerType is not MONTHLY.", { evaluationConfig });
        return null;
    }
    try {
        const currentDate = new Date();
        // If we have a specific month in the config, use it
        if (evaluationConfig.targetMonth) {
            return evaluationConfig.targetMonth;
        }
        
        // Otherwise calculate from the current date'
        const targetMonth = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;
        logger.info(`Using current month for evaluation: ${targetMonth}`);
        return targetMonth;
    } catch (error) {
        logger.error("Error determining evaluation month:", error);
        return null;
    }
}

/**
 * Function to check a single condition. Routes based on type.
 * Called by evaluateTaskForEmployee.
 * @param {string} userId - The employee ID
 * @param {object} condition - The condition to check
 * @param {object} taskData - Additional task data
 * @returns {object} Result containing condition, passed flag, and dataValue
 */
function checkCondition(userId, condition, taskData) {
    if (!condition || !condition.type) {
        logger.error(`Invalid condition for user ${userId}:`, condition);'
        return { condition, passed: false, dataValue: null, error: 'Invalid condition format' };
    }

    let result;
    try {
        switch (condition.type) {'
            case 'ATTENDANCE':'
                result = checkAttendanceCondition(userId, condition.metric, condition.operator, condition.value, condition.timePeriod || 'LAST_MONTH', taskData.evaluationDate || new Date());
                break;'
            case 'SALES':
                // 寰瀟askData涓�鐛插彇storeId锛岄渶纰轰繚鍝″伐鏁告摎涓�鏈塻tore娆勪綅
                const storeId = taskData?.store || null;'
                result = checkSalesCondition(userId, storeId, condition.metric, condition.operator, condition.value, condition.timePeriod || 'LAST_MONTH', taskData.evaluationDate || new Date());
                break;
            default:
                logger.warn(`Unsupported condition type "${condition.type}" for user ${userId}`);'
                result = { condition, passed: false, dataValue: null, error: '涓嶆敮鎻寸殑姊濅欢椤炲瀷' };
        }
    } catch (error) {
        logger.error(`Error checking condition for user ${userId}:`, error, { condition });
        result = { condition, passed: false, dataValue: null, error: error.message };
    }
    
    logger.info(`姊濅欢妾㈡煡绲愭灉 - 浣跨敤鑰�: ${userId}, 椤炲瀷: ${condition.type}, 鎸囨��: ${condition.metric}, 閫氶亷: ${result.passed}, 鏁稿€�: ${result.dataValue}`);
    return { 
        condition, 
        passed: result.passed, 
        dataValue: result.dataValue, 
        error: result.error 
    };
}

// 鐐轰簡鍚戝緦鍏煎�癸紝淇濈暀鑸婂嚱鏁稿悕绋�
const checkSingleCondition = checkCondition;

/**
 * Scheduled function to calculate monthly payrolls.
 * Triggered at the end of each month to process all active employees.
 */
exports.calculatePayrollScheduled = onSchedule({
    schedule: "0 1 1 * *", // Runs at 1:00 AM on the 1st day of each month
    timeZone: "Asia/Taipei",
    timeoutSeconds: 540, // Max timeout for scheduled functions'
    memory: '1GiB' // Adjust memory if needed
}, async (event) => {
    logger.info("Starting scheduled payroll calculation run...");
    const startTime = Date.now();
    
    try {
        // 瑷堢畻涓婂€嬫湀鐨刌YYY-MM鏍煎紡
        const now = new Date();
        const lastMonth = new Date(now.getFullYear(), now.getMonth(), 0); // Last day of previous month'
        const targetMonth = `${lastMonth.getFullYear()}-${String(lastMonth.getMonth() + 1).padStart(2, '0')}`;
        
        logger.info(`Calculating payroll for month: ${targetMonth}`);
        await runPayrollCalculation(targetMonth);
        
        const duration = Date.now() - startTime;
        logger.info(`Payroll calculation completed in ${duration}ms for month ${targetMonth}`);
        await logActivity({ '
            userId: 'system', '
            feature: 'Payroll', '
            action: 'calculatePayrollScheduledComplete', 
            details: `Calculated payroll for month ${targetMonth} in ${duration}ms`, 
            success: true 
        });
    } catch (error) {
        const duration = Date.now() - startTime;
        logger.error("Critical error during payroll calculation:", error);
        await logActivity({ '
            userId: 'system', '
            feature: 'Payroll', '
            action: 'calculatePayrollScheduledError', 
            details: `Failed after ${duration}ms: ${error.message}`, 
            success: false 
        });
    }
}); // 姝ｇ⒑闁夊悎calculatePayrollScheduled鍑芥暩

/**
 * Main function to calculate payroll for all employees for a specific month.'
 * @param {string} targetMonth - The target month in format 'YYYY-MM'.
 * @returns {Promise<void>}
 */
async function runPayrollCalculation(targetMonth) {
    // 锟�???锟斤拷??锟戒唤'
    const [year, month] = targetMonth.split('-').map(Number);
    if (!year || !month || month < 1 || month > 12) {
        logger.error(`Invalid target month format: ${targetMonth}`);
        throw new Error(`Invalid target month format: ${targetMonth}`);
    }
    
    // 瑷�锟�??锟戒唤?锟斤拷?濮嬶拷?绲愶拷??锟斤拷?
    const startDate = new Date(year, month - 1, 1, 0, 0, 0, 0); // First day of month
    const endDate = new Date(year, month, 0, 23, 59, 59, 999); // Last day of month
    
    logger.info(`Calculating payroll for period: ${startDate.toISOString()} to ${endDate.toISOString()}`);
    
    // 1. ?锟斤拷??锟斤拷??锟界疆
    const payrollConfig = await getPayrollConfig();
    if (!payrollConfig) {
        throw new Error("Failed to retrieve payroll configuration");
    }
    '
    // 2. ?锟斤拷??锟�?锟芥椿韬嶅摗锟�?    const employeesSnapshot = await db.collection('employees')'
        .where('isActive', '==', true)
        .get();
    
    if (employeesSnapshot.empty) {
        logger.info("No active employees found.");
        return;
    }
    
    logger.info(`Found ${employeesSnapshot.size} active employees for payroll calculation.`);
    
    // 3. ?锟芥��?锟斤拷?姣忓€嬪摗锟�?    const batchSize = 10; // ?锟斤拷??锟斤拷??锟藉摗宸ユ暩??    const employees = [];
    employeesSnapshot.forEach(doc => {
        employees.push({ id: doc.id, ...doc.data() });
    });
    
    for (let i = 0; i < employees.length; i += batchSize) {
        const batch = employees.slice(i, i + batchSize);
        await Promise.all(batch.map(employee => 
            calculateEmployeePayroll(employee, targetMonth, startDate, endDate, payrollConfig)
        ));
        logger.info(`Processed ${Math.min(i + batchSize, employees.length)} of ${employees.length} employees`);
    }
}

/**
 * Get payroll configuration from Firestore.
 * @returns {Promise<object|null>} - Payroll configuration or null if not found.
 */
async function getPayrollConfig() {
    try {'
        const configDoc = await db.collection('settings').doc('payroll_config').get();
        if (!configDoc.exists) {
            logger.warn("Payroll configuration not found, using defaults");
            return {
                defaultHourlyRate: 200, // ?锟借ō?锟借柂 (TWD)
                overtimeMultiplier: 1.33, // ?锟界彮璨诲€嶏拷?
                laborInsuranceRate: 0.2, // ?锟斤拷?璨伙拷? (20%)
                healthInsuranceRate: 0.0469 // ?锟斤拷?璨伙拷? (4.69%)
            };
        }
        return configDoc.data();
    } catch (error) {
        logger.error("Error retrieving payroll configuration:", error);
        return null;
    }
}

/**
 * Calculate payroll for a single employee.
 * @param {object} employee - Employee data.'
 * @param {string} targetMonth - Target month in format 'YYYY-MM'.
 * @param {Date} startDate - Start date of the month.
 * @param {Date} endDate - End date of the month.
 * @param {object} payrollConfig - Payroll configuration.
 * @returns {Promise<void>}
 */
async function calculateEmployeePayroll(employee, targetMonth, startDate, endDate, payrollConfig) {
    const employeeId = employee.id;
    const employeeName = employee.displayName || employee.name || employeeId;
    logger.info(`Calculating payroll for employee: ${employeeName} (${employeeId}) for ${targetMonth}`);
    
    try {
        // 1. ?锟斤拷??锟藉嫟?锟斤拷?
        const attendanceSummary = await calculateAttendanceSummary(employeeId, startDate, endDate);
        
        // 2. ?锟斤拷?浼戯拷??锟斤拷?
        const leaveSummary = await calculateLeaveSummary(employeeId, startDate, endDate);
        
        // 3. ?锟斤拷??锟斤拷??锟斤拷?
        const bonusSummary = await calculateBonusSummary(employeeId, targetMonth);
        
        // 4. 瑷堬拷??锟斤拷?
        // ?锟芥湰宸ワ拷?
        const baseHourlyRate = employee.hourlyRate || payrollConfig.defaultHourlyRate;
        const baseSalaryPay = attendanceSummary.regularHours * baseHourlyRate;
        
        // ?锟界彮锟�?        const overtimeRate = baseHourlyRate * payrollConfig.overtimeMultiplier;
        const overtimePay = attendanceSummary.overtimeHours * overtimeRate;
        
        // 绺藉伐锟�?        const totalSalary = baseSalaryPay + overtimePay + bonusSummary.totalBonus;
        
        // ??锟斤拷?锟界洰 (?锟斤拷??锟藉仴淇濓拷?)
        const laborInsurance = totalSalary * payrollConfig.laborInsuranceRate;
        const healthInsurance = totalSalary * payrollConfig.healthInsuranceRate;
        const totalDeductions = laborInsurance + healthInsurance;
        
        // 娣ㄥ伐锟�?        const netSalary = totalSalary - totalDeductions;
        
        // 5. ?锟斤拷?瑷堬拷?绲愶拷?
        await savePayrollRecord(employeeId, targetMonth, {
            employeeId,
            employeeName,
            targetMonth,
            calculatedAt: new Date(),
            attendance: attendanceSummary,
            leave: leaveSummary,
            bonus: bonusSummary,
            salary: {
                baseHourlyRate,
                baseSalaryPay,
                overtimePay,
                totalSalary,
                deductions: {
                    laborInsurance,
                    healthInsurance,
                    totalDeductions
                },
                netSalary
            }
        });
        
        logger.info(`Completed payroll calculation for ${employeeName} (${employeeId}): ${netSalary} TWD`);
    } catch (error) {
        logger.error(`Error calculating payroll for employee ${employeeId}:`, error);
        throw error;
    }
}

/**
 * Save payroll record to Firestore.
 * @param {string} employeeId - Employee ID.'
 * @param {string} targetMonth - Target month in format 'YYYY-MM'.
 * @param {object} payrollData - Calculated payroll data.
 * @returns {Promise<void>}
 */
async function savePayrollRecord(employeeId, targetMonth, payrollData) {
    try {'
        const payrollRef = db.collection('payrolls').doc(`${employeeId}_${targetMonth}`);
        await payrollRef.set(payrollData, { merge: true });
        logger.info(`Saved payroll record for employee ${employeeId} for month ${targetMonth}`);
    } catch (error) {
        logger.error(`Error saving payroll record for employee ${employeeId}:`, error);
        throw error;
    }
}

/**
 * Calculate attendance summary for an employee.
 * @param {string} employeeId - Employee ID.
 * @param {Date} startDate - Start date of the month.
 * @param {Date} endDate - End date of the month.
 * @returns {Promise<Object>} - Attendance summary.
 */
async function calculateAttendanceSummary(employeeId, startDate, endDate) {
    try {
        logger.info(`Calculating attendance summary for employee ${employeeId} from ${startDate.toISOString()} to ${endDate.toISOString()}`);
        
        // ?锟借��?锟藉嫟瑷橈拷?'
        const clockRecordsQuery = db.collection('clock_records')'
                                 .where('userId', '==', employeeId)'
                                 .where('timestamp', '>=', startDate)'
                                 .where('timestamp', '<=', endDate);
        const clockRecordsSnapshot = await clockRecordsQuery.get();
        const clockRecords = [];
        clockRecordsSnapshot.forEach(doc => clockRecords.push(doc.data()));
        
        // ?锟借��?锟界彮瑷橈拷?'
        const scheduleQuery = db.collection('schedules')'
                           .where('userId', '==', employeeId)'
                           .where('date', '>=', startDate.toISOString().split('T')[0])'
                           .where('date', '<=', endDate.toISOString().split('T')[0]);
        const scheduleSnapshot = await scheduleQuery.get();
        const scheduleRecords = [];
        scheduleSnapshot.forEach(doc => scheduleRecords.push(doc.data()));
        
        // 瑷堬拷??锟斤拷?
        let regularHours = 0;
        let overtimeHours = 0;
        let lateCount = 0;
        let absenceDays = 0;
        let onTimeCount = 0;
        let totalWorkDays = 0;
        
        // 寤猴拷??锟界彮宸ワ拷??锟斤拷?锟�?        const scheduledWorkDaysMap = new Map();
        const clockedDaysMap = new Map();
        
        scheduleRecords.forEach(schedule => {'
            if (schedule.shift !== '锟�?) {
                totalWorkDays++;
                scheduledWorkDaysMap.set(schedule.date, {
                    shift: schedule.shift,
                    store: schedule.store
                });
            }
        });
        
        // ?锟斤拷??锟藉崱瑷橈拷?
        clockRecords.forEach(record => {
            try {
                const recordTimestamp = record.timestamp;
                if (recordTimestamp && recordTimestamp.toDate) {
                    const recordDate = recordTimestamp.toDate();'
                    const recordDateStr = recordDate.toISOString().split('T')[0];
                    
                    if (!clockedDaysMap.has(recordDateStr)) {
                        clockedDaysMap.set(recordDateStr, []);
                    }
                    clockedDaysMap.get(recordDateStr).push(record);
                    
                    // 瑷堬拷??锟藉埌?锟斤拷???                    if (scheduledWorkDaysMap.has(recordDateStr)) {'
                        // ?锟芥柗?锟藉埌?锟斤拷???                        if (record.status === '?锟藉埌') {
                            lateCount++;'
                        } else if (record.status === '婧栵拷?') {
                            onTimeCount++;
                        }
                        
                        // 瑷堬拷?宸ワ拷?锛堬拷?瑷�锟�??锟界彮锟�?灏忥拷?锟�?                        const shiftHours = 8; // ?锟芥湰宸ワ拷?锛屽彲浠ユ牴?锟界彮娆★拷??锟借��??                        regularHours += shiftHours;
                        
                        // 瑷堬拷??锟界彮?锟斤拷?锛堬拷??锟斤拷?锟�?                        if (record.overtimeHours) {
                            overtimeHours += parseFloat(record.overtimeHours);
                        }
                    }
                }
            } catch (e) {
                logger.warn(`Error processing clock record for attendance summary: ${e.message}`, e);
            }
        });
        
        // 瑷堬拷?缂哄嫟澶╂暩
        scheduledWorkDaysMap.forEach((shiftInfo, dateStr) => {
            if (!clockedDaysMap.has(dateStr)) {
                absenceDays++;
            }
        });
        
        // 瑷堬拷??锟藉嫟??        const onTimeRate = totalWorkDays > 0 ? onTimeCount / totalWorkDays : 0;
        
        // 妲嬪缓涓︼拷??锟斤拷?锟�?        const summary = {
            totalWorkDays,
            regularHours,
            overtimeHours,
            lateCount,
            absenceDays,
            onTimeCount,
            onTimeRate,
            period: {
                startDate: startDate.toISOString(),
                endDate: endDate.toISOString()
            }
        };
        
        logger.info(`Completed attendance summary calculation for ${employeeId}: ${JSON.stringify(summary)}`);
        return summary;
    } catch (error) {
        logger.error(`Error calculating attendance summary for employee ${employeeId}:`, error);
        // 杩旓拷??锟借ō?锟戒互?锟斤拷?绯荤当宕╂桨
        return {
            totalWorkDays: 0,
            regularHours: 0,
            overtimeHours: 0,
            lateCount: 0,
            absenceDays: 0,
            onTimeCount: 0,
            onTimeRate: 0,
            period: {
                startDate: startDate.toISOString(),
                endDate: endDate.toISOString()
            },
            error: error.message
        };
    }
}

/**
 * Calculate leave summary for an employee.
 * @param {string} employeeId - Employee ID.
 * @param {Date} startDate - Start date of the month.
 * @param {Date} endDate - End date of the month.
 * @returns {Promise<Object>} - Leave summary.
 */
async function calculateLeaveSummary(employeeId, startDate, endDate) {
    try {
        logger.info(`Calculating leave summary for employee ${employeeId} from ${startDate.toISOString()} to ${endDate.toISOString()}`);
        '
        const startDateStr = startDate.toISOString().split('T')[0];'
        const endDateStr = endDate.toISOString().split('T')[0];'
        const monthStr = startDateStr.substring(0, 7); // 'YYYY-MM'
        
        // ?锟借�㈣珛锟�?瑷橈拷?'
        const leaveRequestsQuery = db.collection('leave_requests')'
                                .where('employeeId', '==', employeeId)'
                                .where('month', '==', monthStr);
        const leaveRequestsSnapshot = await leaveRequestsQuery.get();
        
        // 濡傦拷?娌掞拷?璜嬶拷?瑷橈拷?锛岋拷??锟斤拷?瑷�锟�?        if (leaveRequestsSnapshot.empty) {
            return {
                totalLeaveDays: 0,
                leaveTypes: {},
                leaveDates: [],
                period: {
                    startDate: startDate.toISOString(),
                    endDate: endDate.toISOString()
                }
            };
        }
        
        // ?锟斤拷?璜嬶拷?瑷橈拷?
        let totalLeaveDays = 0;
        const leaveTypes = {};
        const leaveDates = [];
        
        leaveRequestsSnapshot.forEach(doc => {
            const leaveRequest = doc.data();
            const selectedDates = leaveRequest.selected_dates || [];
            
            // ?锟斤拷?绠楀湪?锟斤拷??锟戒唤?锟斤拷?璜嬶拷??锟斤拷?
            const validDates = selectedDates.filter(dateStr => 
                dateStr >= startDateStr && dateStr <= endDateStr
            );
            
            totalLeaveDays += validDates.length;
            leaveDates.push(...validDates);
            
            // 绲憋拷?璜嬶拷?椤烇拷?'
            const leaveType = leaveRequest.leave_type || '涓€?锟斤拷?';
            leaveTypes[leaveType] = (leaveTypes[leaveType] || 0) + validDates.length;
        });
        
        // 妲嬪缓涓︼拷??锟斤拷?锟�?        const summary = {
            totalLeaveDays,
            leaveTypes,
            leaveDates,
            period: {
                startDate: startDate.toISOString(),
                endDate: endDate.toISOString()
            }
        };
        
        logger.info(`Completed leave summary calculation for ${employeeId}: ${JSON.stringify(summary)}`);
        return summary;
    } catch (error) {
        logger.error(`Error calculating leave summary for employee ${employeeId}:`, error);
        // 杩旓拷??锟借ō?锟戒互?锟斤拷?绯荤当宕╂桨
        return {
            totalLeaveDays: 0,
            leaveTypes: {},
            leaveDates: [],
            period: {
                startDate: startDate.toISOString(),
                endDate: endDate.toISOString()
            },
            error: error.message
        };
    }
}

/**
 * Calculate bonus summary for an employee.
 * @param {string} employeeId - Employee ID.'
 * @param {string} targetMonth - Target month in format 'YYYY-MM'.
 * @returns {Promise<Object>} - Bonus summary.
 */
async function calculateBonusSummary(employeeId, targetMonth) {
    try {
        logger.info(`Calculating bonus summary for employee ${employeeId} for month ${targetMonth}`);
        
        // ?锟借��?锟斤拷?瑷橈拷?
        const progressDocId = `${employeeId}_${targetMonth}`;'
        const progressDoc = await db.collection('employee_bonus_progress').doc(progressDocId).get();
        
        // 濡傦拷?娌掞拷??锟斤拷?瑷橈拷?锛岋拷??锟斤拷?瑷�锟�?        if (!progressDoc.exists) {
            return {
                totalBonus: 0,
                bonusItems: [],
                targetMonth
            };
        }
        
        // ?锟斤拷??锟斤拷?瑷橈拷?
        const progressData = progressDoc.data();
        const tasks = progressData.tasks || [];
        let totalBonus = 0;
        const bonusItems = [];
        
        tasks.forEach(taskResult => {'
            if (taskResult.status === 'PASSED' && typeof taskResult.rewardEarned === 'number') {
                totalBonus += taskResult.rewardEarned;
                bonusItems.push({
                    taskId: taskResult.taskId,
                    taskName: taskResult.taskName,
                    reward: taskResult.rewardEarned,
                    evaluationDate: taskResult.evaluationDate
                });
            }
        });
        
        // 妲嬪缓涓︼拷??锟斤拷?锟�?        const summary = {
            totalBonus,
            bonusItems,
            targetMonth
        };
        
        logger.info(`Completed bonus summary calculation for ${employeeId}: ${JSON.stringify(summary)}`);
        return summary;
    } catch (error) {
        logger.error(`Error calculating bonus summary for employee ${employeeId}:`, error);
        // 杩旓拷??锟借ō?锟戒互?锟斤拷?绯荤当宕╂桨
        return {
            totalBonus: 0,
            bonusItems: [],
            targetMonth,
            error: error.message
        };
    }
}

/**
 * Compares two values using a specified operator.
 * @param {*} actual - The actual data value from the employee/system.'
 * @param {*} operator - The comparison operator (e.g., '>=', '<=', '==').
 * @param {*} target - The target value from the condition definition.
 * @returns {boolean} - True if the comparison holds, false otherwise.
 */
function compareValuesExtended(actual, operator, target) {
    logger.debug(`Comparing values: ${actual} ${operator} ${target}`);
    // Basic type coercion for comparison (may need refinement)
    const numActual = Number(actual);
    const numTarget = Number(target);
    const useNumeric = !isNaN(numActual) && !isNaN(numTarget);

    try {
        switch (operator) {'
            case '>=':
                return useNumeric ? numActual >= numTarget : actual >= target;'
            case '<=':
                return useNumeric ? numActual <= numTarget : actual <= target;'
            case '==':'
                // Be careful with type coercion for '=='
                 return useNumeric ? numActual === numTarget : String(actual) === String(target);'
            case '!=':
                return useNumeric ? numActual !== numTarget : String(actual) !== String(target);'
            case '>':
                return useNumeric ? numActual > numTarget : actual > target;'
            case '<':
                return useNumeric ? numActual < numTarget : actual < target;
            default:
                logger.warn(`Unsupported operator: ${operator}`);
                return false;
        }
    } catch (error) {
        logger.error("Error during value comparison:", error, { actual, operator, target });
        return false;
    }
}

// ?锟斤拷?淇濓拷??锟斤拷??锟藉�癸紝娣�?锟藉垾??
const compareValues_extended = compareValuesExtended;

// --- 鏁告摎鍒嗘瀽鑸囨暩鎿氱磤閷勬ā绲� --- 

/**
 * 鐛插彇鍒嗘瀽鏁告摎 - 閵峰敭鍜屾垚鏈�鏁告摎鍒嗘瀽
 * @param {Object} data - 璜嬫眰鍙冩暩
 * @param {string} data.startDate - 鍒嗘瀽闁嬪�嬫棩鏈� (YYYY-MM-DD)
 * @param {string} data.endDate - 鍒嗘瀽绲愭潫鏃ユ湡 (YYYY-MM-DD)
 * @param {string} [data.storeId] - 鎸囧畾鐨勫垎搴桰D (鍙�閬�)'
 * @param {string} [data.analysisType] - 鍒嗘瀽椤炲瀷 (sales, cost, profit, all) - 闋愯ō鐐�'all'
 * @returns {Object} - 鍒嗘瀽绲愭灉鏁告摎
 */
exports.getAnalysisData = onCall(
    {
        maxInstances: 5,
    },
    async (request) => {
        // 1. 娆婇檺妾㈡煡
        if (!request.auth) {'
            throw new HttpsError('unauthenticated', '闇€瑕佺敤鎴惰韩浠介�楄瓑');
        }

        // 妾㈡煡鐢ㄦ埗娆婇檺 (闇€瑕佺�＄悊鍝℃瑠闄�)
        try {'
            const userDoc = await db.collection('employees').doc(request.auth.uid).get();
            if (!userDoc.exists) {'
                throw new HttpsError('permission-denied', '鎵句笉鍒扮敤鎴惰硣鏂�');
            }
            const userData = userDoc.data();
            
            // 瑷橀寗鐢ㄦ埗璩囪▕鐢ㄦ柤鏃ヨ獙
            const userId = request.auth.uid;'
            const userName = userData.name || 'Unknown';
            const userLevel = userData.level || 0;
            
            // 鍙�鍏佽ū娆婇檺绛夌礆 >= 9 鐨勭敤鎴惰í鍟�
            if (userData.level < 9) {
                // 瑷橀寗鏈�鎺堟瑠瑷�鍟�
                await logActivity({
                    userId: userId,
                    userName: userName,
                    userLevel: userLevel,'
                    feature: 'Analysis','
                    action: 'AccessAttempt','
                    details: { reason: 'Insufficient permission level' },
                    success: false
                });'
                throw new HttpsError('permission-denied', '闇€瑕佺�＄悊鍝℃瑠闄� (绛夌礆 9+)');
            }

            // 2. 鍙冩暩椹楄瓑'
            const { startDate, endDate, storeId, analysisType = 'all' } = request.data;

            if (!startDate || !endDate) {'
                throw new HttpsError('invalid-argument', '蹇呴爤鎻愪緵闁嬪�嬪拰绲愭潫鏃ユ湡');
            }

            // 纰轰繚鏃ユ湡鏍煎紡姝ｇ⒑ (YYYY-MM-DD)
            const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
            if (!dateRegex.test(startDate) || !dateRegex.test(endDate)) {'
                throw new HttpsError('invalid-argument', '鏃ユ湡鏍煎紡蹇呴爤鐐� YYYY-MM-DD');
            }

            // 杞夋彌鏃ユ湡瀛楃�︿覆鐐� Date 灏嶈薄鐢ㄦ柤鏌ヨ��
            const startDateObj = new Date(startDate);
            const endDateObj = new Date(endDate);
            endDateObj.setHours(23, 59, 59, 999); // 瑷�缃�绲愭潫鏃ユ湡鐐虹暥澶╃祼鏉�

            if (isNaN(startDateObj.getTime()) || isNaN(endDateObj.getTime())) {'
                throw new HttpsError('invalid-argument', '鐒℃晥鐨勬棩鏈熸牸寮�');
            }

            if (startDateObj > endDateObj) {'
                throw new HttpsError('invalid-argument', '闁嬪�嬫棩鏈熶笉鑳芥櫄鏂肩祼鏉熸棩鏈�');
            }

            // 鍒嗘瀽椤炲瀷椹楄瓑'
            const validTypes = ['sales', 'cost', 'profit', 'attendance', 'all'];
            if (!validTypes.includes(analysisType)) {'
                throw new HttpsError('invalid-argument', `鍒嗘瀽椤炲瀷 ${analysisType} 鐒℃晥`);
            }

            // 瑷橀寗闁嬪�嬪垎鏋�
            await logActivity({
                userId, 
                userName,
                userLevel,'
                feature: 'Analysis','
                action: 'DataFetch',
                details: { startDate, endDate, storeId, analysisType },
                success: true
            });

            // 3. 鏁告摎鐛插彇
            const results = {
                summary: {},
                salesTrend: {},
                costBreakdown: {},
                profitMargins: {},
                attendanceStats: {}
            };

            // 瀹氱京甯哥敤鐨勬棩鏈熻綁鎻涙牸寮忓寲鍑芥暩
            const formatDate = (date) => {
                const d = new Date(date);'
                return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
            };

            // 鑱氬悎鍑芥暩 - 鎸夋棩鏈熷尟绺�
            const aggregateByDate = (items, dateField, valueField, valueModifier = null) => {
                const result = {};
                items.forEach(item => {
                    const date = formatDate(item[dateField]);
                    const value = valueModifier ? valueModifier(item) : (item[valueField] || 0);
                    result[date] = (result[date] || 0) + value;
                });
                return result;
            };

            // 鐛插彇閵峰敭鏁告摎'
            if (['sales', 'profit', 'all'].includes(analysisType)) {'
                let salesQuery = db.collection('sales_reports')'
                    .where('reportDate', '>=', startDateObj)'
                    .where('reportDate', '<=', endDateObj);

                if (storeId) {'
                    salesQuery = salesQuery.where('storeId', '==', storeId);
                }

                const salesSnapshot = await salesQuery.get();
                const salesData = salesSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                // 绺介姺鍞�椤�
                const totalSales = salesData.reduce((sum, sale) => sum + (sale.totalAmount || 0), 0);
                results.summary.totalSales = totalSales;'
                results.summary.averageDailySales = salesData.length > 0 ? totalSales / (Object.keys(aggregateByDate(salesData, 'reportDate', 'totalAmount')).length || 1) : 0;
                
                // 鎸夋棩鍖�绺介姺鍞�椤�'
                results.salesTrend = aggregateByDate(salesData, 'reportDate', 'totalAmount');

                // 鍙�閬革細鎸夐姺鍞�椤炲瀷绱板垎
                const salesByCategory = {};
                salesData.forEach(sale => {
                    if (sale.items && Array.isArray(sale.items)) {
                        sale.items.forEach(item => {'
                            const category = item.category || '鏈�鍒嗛��';
                            salesByCategory[category] = (salesByCategory[category] || 0) + (item.amount || 0);
                        });
                    }
                });
                results.salesByCategory = salesByCategory;
            }

            // 鐛插彇鎴愭湰鏁告摎'
            if (['cost', 'profit', 'all'].includes(analysisType)) {'
                let costQuery = db.collection('orders')'
                    .where('orderDate', '>=', startDateObj)'
                    .where('orderDate', '<=', endDateObj);

                if (storeId) {'
                    costQuery = costQuery.where('storeId', '==', storeId);
                }

                const costSnapshot = await costQuery.get();
                const costData = costSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                // 绺芥垚鏈�
                const totalCost = costData.reduce((sum, cost) => {
                    // 瑷堢畻瑷傚柈绺芥垚鏈� (姣忓€嬪搧闋呯殑鍠�鍍� * 鏁搁噺)
                    let orderCost = 0;
                    if (cost.items && Array.isArray(cost.items)) {
                        orderCost = cost.items.reduce((itemSum, item) => itemSum + ((item.price || 0) * (item.quantity || 0)), 0);
                    }
                    return sum + orderCost;
                }, 0);
                
                results.summary.totalCost = totalCost;
                
                // 鎸夋棩鍖�绺芥垚鏈�'
                results.costBreakdown = aggregateByDate(costData, 'orderDate', null, (cost) => {
                    if (cost.items && Array.isArray(cost.items)) {
                        return cost.items.reduce((sum, item) => sum + ((item.price || 0) * (item.quantity || 0)), 0);
                    }
                    return 0;
                });

                // 鍒╂饯瑷堢畻 (濡傛灉鏈夐姺鍞�鏁告摎)'
                if (['profit', 'all'].includes(analysisType) && results.summary.totalSales !== undefined) {
                    results.summary.totalProfit = results.summary.totalSales - totalCost;
                    results.summary.profitMargin = results.summary.totalSales > 0 ? (results.summary.totalProfit / results.summary.totalSales) * 100 : 0;

                    // 鎸夋棩瑷堢畻鍒╂饯
                    const dailyProfits = {};
                    const allDates = new Set([...Object.keys(results.salesTrend), ...Object.keys(results.costBreakdown)]);
                    
                    allDates.forEach(date => {
                        const daySales = results.salesTrend[date] || 0;
                        const dayCost = results.costBreakdown[date] || 0;
                        dailyProfits[date] = daySales - dayCost;
                    });
                    
                    results.profitMargins = dailyProfits;
                }
            }

            // 鐛插彇鍑哄嫟鏁告摎 (濡傛灉闇€瑕�)'
            if (['attendance', 'all'].includes(analysisType)) {'
                let attendanceQuery = db.collection('clock_records')'
                    .where('timestamp', '>=', startDateObj)'
                    .where('timestamp', '<=', endDateObj);

                if (storeId) {'
                    attendanceQuery = attendanceQuery.where('storeId', '==', storeId);
                }

                const attendanceSnapshot = await attendanceQuery.get();
                const attendanceData = attendanceSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                // 鍑哄嫟绲辫▓
                const employeeAttendance = {};
                attendanceData.forEach(record => {'
                    const employeeId = record.userId || 'unknown';
                    if (!employeeAttendance[employeeId]) {
                        employeeAttendance[employeeId] = {
                            clockIns: 0,
                            clockOuts: 0,
                            totalHours: 0,
                            lateDays: 0
                        };
                    }
                    '
                    if (record.type === 'CLOCK_IN') {
                        employeeAttendance[employeeId].clockIns++;
                        // 妾㈡煡鏄�鍚﹂伈鍒�
                        if (record.isLate) {
                            employeeAttendance[employeeId].lateDays++;
                        }'
                    } else if (record.type === 'CLOCK_OUT') {
                        employeeAttendance[employeeId].clockOuts++;
                        
                        // 瑷堢畻宸ヤ綔鏅傛暩 (濡傛灉鏈夐厤灏嶇殑鎵撳崱瑷橀寗)
                        if (record.pairRecordId) {
                            const clockInRecord = attendanceData.find(r => r.id === record.pairRecordId);
                            if (clockInRecord && clockInRecord.timestamp) {
                                const startTime = clockInRecord.timestamp instanceof Date ? 
                                    clockInRecord.timestamp : clockInRecord.timestamp.toDate();
                                const endTime = record.timestamp instanceof Date ? 
                                    record.timestamp : record.timestamp.toDate();
                                
                                const hoursWorked = (endTime - startTime) / (1000 * 60 * 60);
                                employeeAttendance[employeeId].totalHours += hoursWorked;
                            }
                        }
                    }
                });
                
                results.attendanceStats = employeeAttendance;
                
                // 绺介珨鍑哄嫟绲辫▓
                const totalEmployees = Object.keys(employeeAttendance).length;
                const totalHours = Object.values(employeeAttendance).reduce((sum, emp) => sum + emp.totalHours, 0);
                const totalLateDays = Object.values(employeeAttendance).reduce((sum, emp) => sum + emp.lateDays, 0);
                
                results.summary.totalEmployees = totalEmployees;
                results.summary.totalWorkHours = totalHours;
                results.summary.averageHoursPerEmployee = totalEmployees > 0 ? totalHours / totalEmployees : 0;
                results.summary.totalLateDays = totalLateDays;
            }

            // 瑷橀寗鍒嗘瀽瀹屾垚
            await logActivity({
                userId, 
                userName,
                userLevel,'
                feature: 'Analysis','
                action: 'DataAnalysisComplete',
                details: { 
                    startDate, 
                    endDate, 
                    storeId, 
                    analysisType,
                    resultSummary: {
                        totalSales: results.summary.totalSales,
                        totalCost: results.summary.totalCost,
                        totalProfit: results.summary.totalProfit
                    }
                },
                success: true
            });

            return {
                success: true,
                data: results
            };
            
        } catch (error) {'
            logger.error('鍒嗘瀽鏁告摎鐛插彇澶辨晽:', error);
            
            // 鍢楄│瑷橀寗閷�瑾�
            try {
                if (request.auth) {
                    await logActivity({
                        userId: request.auth.uid,'
                        feature: 'Analysis','
                        action: 'DataFetchError',
                        details: { 
                            error: error.message, 
                            params: request.data 
                        },
                        success: false,
                        errorMessage: error.message
                    });
                }
            } catch (logError) {'
                logger.error('瑷橀寗鍒嗘瀽閷�瑾ゅけ鏁�:', logError);
            }
            
            // 鎷嬪嚭閬╃暥鐨勯尟瑾�
            if (error instanceof HttpsError) {
                throw error;
            } else {'
                throw new HttpsError('internal', `鏁告摎鍒嗘瀽閬庣▼涓�鍑虹従閷�瑾�: ${error.message}`);
            }
        }
    }
);

/**
 * 鐢㈢敓绯荤当娲诲嫊鏃ヨ獙锛堟脯瑭︾敤锛�
 * 姝ゅ嚱鏁稿彲浠ョ敱绠＄悊鑰呭懠鍙�渚嗙敓鎴愮郴绲辨椿鍕曟棩瑾岋紝鐢ㄦ柤娓�瑭﹀拰闁嬬櫦
 */
exports.generateSystemLog = onCall(async (data, context) => {
    // 妾㈡煡鍛煎彨鑰呮瑠闄� - 鍙�鍏佽ū绠＄悊鍝′娇鐢�
    if (!context.auth) {'
        throw new HttpsError('unauthenticated', '闇€瑕佺櫥鍏ユ墠鑳戒娇鐢ㄦ�ゅ姛鑳�');
    }

    try {
        // 鐛插彇瑾跨敤鑰呯殑鐢ㄦ埗绱氬垾'
        const userSnapshot = await db.collection('employees').where('uid', '==', context.auth.uid).limit(1).get();
        if (userSnapshot.empty) {'
            throw new HttpsError('permission-denied', '鎵句笉鍒版偍鐨勭敤鎴惰硣鏂�');
        }
        
        const userData = userSnapshot.docs[0].data();
        const userLevel = userData.level || 0;
        
        // 鍙�鍏佽ū绠＄悊鍝★紙绱氬垾 >= 8锛変娇鐢ㄦ�ゅ姛鑳�
        if (userLevel < 8) {'
            throw new HttpsError('permission-denied', '鎮ㄦ矑鏈夋瑠闄愬煼琛屾�ゆ搷浣�');
        }
        
        // 纰轰繚璜嬫眰鍖呭惈鎵€闇€鐨勬暩鎿�
        if (!data || !data.feature || !data.action) {'
            throw new HttpsError('invalid-argument', '璜嬫彁渚涘繀瑕佺殑鏃ヨ獙璩囪▕ (feature, action)');
        }
        
        // 婧栧倷鏃ヨ獙姊濈洰
        const logEntry = {
            timestamp: admin.firestore.FieldValue.serverTimestamp(),'
            userId: data.userId || 'system','
            userName: data.userName || '绯荤当娓�瑭�',
            feature: data.feature,
            action: data.action,'
            details: data.details || { message: '閫欐槸涓€姊濇脯瑭︽棩瑾�', isTest: true },
            success: data.success === undefined ? true : Boolean(data.success),
            isTestEntry: true // 妯欒�樼偤娓�瑭︽�濈洰
        };
        
        // 瀵�鍏ョ郴绲辨椿鍕曟棩瑾岄泦鍚�'
        const logRef = await db.collection('system_activity_logs').add(logEntry);
        
        // 瑷橀寗绠＄悊鍝″煼琛屾�ゆ搷浣滅殑娲诲嫊
        await logActivity({
            userId: context.auth.uid,
            userName: userData.name,'
            feature: 'SystemAdmin','
            action: 'GenerateTestLog',
            details: {
                generatedLogId: logRef.id,
                logData: logEntry
            },
            success: true
        });
        
        return {
            success: true,'
            message: '娓�瑭︽棩瑾屽凡鎴愬姛鐢熸垚',
            logId: logRef.id
        };
    } catch (error) {'
        logger.error('鐢熸垚娓�瑭︽棩瑾屾檪鍑洪尟:', error);
        
        // 瑷橀寗閷�瑾�
        if (context.auth) {
            await logActivity({
                userId: context.auth.uid,'
                feature: 'SystemAdmin','
                action: 'GenerateTestLogError',
                details: { error: error.message },
                success: false
            });
        }
        
        if (error instanceof HttpsError) {
            throw error;
        } else {'
            throw new HttpsError('internal', `鐢熸垚娓�瑭︽棩瑾屾檪鐧肩敓閷�瑾�: ${error.message}`);
        }
    }
});

/**
 * 娓呴櫎娓�瑭︾郴绲辨棩瑾�
 * 姝ゅ嚱鏁稿厑瑷辩�＄悊鍝℃竻闄ゆ�欒�樼偤娓�瑭︾殑绯荤当鏃ヨ獙姊濈洰
 */
exports.clearTestSystemLogs = onCall(async (data, context) => {
    // 妾㈡煡鍛煎彨鑰呮瑠闄� - 鍙�鍏佽ū绠＄悊鍝′娇鐢�
    if (!context.auth) {'
        throw new HttpsError('unauthenticated', '闇€瑕佺櫥鍏ユ墠鑳戒娇鐢ㄦ�ゅ姛鑳�');
    }

    try {
        // 鐛插彇瑾跨敤鑰呯殑鐢ㄦ埗绱氬垾'
        const userSnapshot = await db.collection('employees').where('uid', '==', context.auth.uid).limit(1).get();
        if (userSnapshot.empty) {'
            throw new HttpsError('permission-denied', '鎵句笉鍒版偍鐨勭敤鎴惰硣鏂�');
        }
        
        const userData = userSnapshot.docs[0].data();
        const userLevel = userData.level || 0;
        
        // 鍙�鍏佽ū绯荤当绠＄悊鍝★紙绱氬垾 >= 9锛変娇鐢ㄦ�ゅ姛鑳�
        if (userLevel < 9) {'
            throw new HttpsError('permission-denied', '鎮ㄦ矑鏈夋瑠闄愬煼琛屾�ゆ搷浣滐紝闇€瑕佺郴绲辩�＄悊鍝℃瑠闄�');
        }
        
        // 鏌ヨ�㈡墍鏈夋脯瑭︽棩瑾屾�濈洰'
        const testLogsSnapshot = await db.collection('system_activity_logs')'
            .where('isTestEntry', '==', true)
            .get();
        
        if (testLogsSnapshot.empty) {
            return {
                success: true,'
                message: '娌掓湁鎵惧埌娓�瑭︽棩瑾屾�濈洰',
                count: 0
            };
        }
        
        // 鍒�闄ゆ墍鏈夋脯瑭︽棩瑾屾�濈洰
        const batch = db.batch();
        testLogsSnapshot.docs.forEach(doc => {
            batch.delete(doc.ref);
        });
        await batch.commit();
        
        // 瑷橀寗绠＄悊鍝″煼琛屾�ゆ竻鐞嗘搷浣�
        await logActivity({
            userId: context.auth.uid,
            userName: userData.name,'
            feature: 'SystemAdmin','
            action: 'ClearTestLogs',
            details: {
                count: testLogsSnapshot.size
            },
            success: true
        });
        
        return {
            success: true,'
            message: '娓�瑭︽棩瑾屽凡鎴愬姛娓呴櫎',
            count: testLogsSnapshot.size
        };
    } catch (error) {'
        logger.error('娓呴櫎娓�瑭︽棩瑾屾檪鍑洪尟:', error);
        
        // 瑷橀寗閷�瑾�
        if (context.auth) {
            await logActivity({
                userId: context.auth.uid,'
                feature: 'SystemAdmin','
                action: 'ClearTestLogsError',
                details: { error: error.message },
                success: false
            });
        }
        
        if (error instanceof HttpsError) {
            throw error;
        } else {'
            throw new HttpsError('internal', `娓呴櫎娓�瑭︽棩瑾屾檪鐧肩敓閷�瑾�: ${error.message}`);
        }
    }
});

/**
 * 鐢㈢敓钖�璩囬爯娓�娓�瑭﹁硣鏂�
 * 姝ゅ嚱鏁稿彲浠ョ敱绠＄悊鑰呭懠鍙�渚嗙敓鎴愮敤鏂兼脯瑭﹁柂璩囬爯娓�鍔熻兘鐨勬�峰彶钖�璩囪硣鏂�
 */
exports.generateSalaryPredictionTestData = onCall('
    { memory: '1GiB', timeoutSeconds: 180 },
    async (request, context) => {
        // 妾㈡煡鍛煎彨鑰呮瑠闄� - 鍙�鍏佽ū绠＄悊鍝′娇鐢�
        if (!context.auth) {'
            throw new HttpsError('unauthenticated', '闇€瑕佺櫥鍏ユ墠鑳戒娇鐢ㄦ�ゅ姛鑳�');
        }

        try {
            // 鐛插彇瑾跨敤鑰呯殑鐢ㄦ埗绱氬垾'
            const userSnapshot = await db.collection('employees').where('uid', '==', context.auth.uid).limit(1).get();
            if (userSnapshot.empty) {'
                throw new HttpsError('permission-denied', '鎵句笉鍒版偍鐨勭敤鎴惰硣鏂�');
            }
            
            const userData = userSnapshot.docs[0].data();
            const userLevel = userData.level || 0;
            
            // 鍙�鍏佽ū绠＄悊鍝★紙绱氬垾 >= 8锛変娇鐢ㄦ�ゅ姛鑳�
            if (userLevel < 8) {'
                throw new HttpsError('permission-denied', '鎮ㄦ矑鏈夋瑠闄愬煼琛屾�ゆ搷浣�');
            }
            
            // 纰轰繚璜嬫眰鍖呭惈鎵€闇€鐨勬暩鎿�
            if (!request.data || !request.data.employeeId || !request.data.storeId || !request.data.months) {'
                throw new HttpsError('invalid-argument', '璜嬫彁渚涘繀瑕佺殑璩囪▕ (employeeId, storeId, months)');
            }
            
            const { employeeId, storeId, months, trend, variance } = request.data;
            '
            if (typeof months !== 'number' || months < 1 || months > 24) {'
                throw new HttpsError('invalid-argument', '鏈堜唤鏁搁噺蹇呴爤鍦�1-24涔嬮枔');
            }
            
            // 鐛插彇鍝″伐璩囨枡浠ョ⒑瀹氬叾鍩烘湰钖�璩囩瓑绱�'
            const employeeDoc = await db.collection('employees').doc(employeeId).get();
            if (!employeeDoc.exists) {'
                throw new HttpsError('not-found', '鎵句笉鍒版寚瀹氱殑鍝″伐');
            }
            
            const employeeData = employeeDoc.data();
            
            // 鐛插彇鍟嗗簵璩囨枡浠ョ⒑瀹氬叾鍩烘湰璁婃暩'
            const storeDoc = await db.collection('stores').doc(storeId).get();
            if (!storeDoc.exists) {'
                throw new HttpsError('not-found', '鎵句笉鍒版寚瀹氱殑鍟嗗簵');
            }
            
            const storeData = storeDoc.data();
            
            // 瀹氱京鍩烘湰钖�璩囩瘎鍦嶏紙渚濇摎鍝″伐绱氬垾锛�
            const getBaseSalaryRange = (level) => {
                const ranges = {
                    1: { min: 25000, max: 30000 },  // 鍩哄堡鍝″伐
                    2: { min: 28000, max: 33000 },  // 璩囨繁鍝″伐
                    3: { min: 30000, max: 36000 },  // 绲勯暦
                    4: { min: 35000, max: 42000 },  // 鍓�搴楅暦
                    5: { min: 40000, max: 48000 },  // 搴楅暦
                    6: { min: 45000, max: 55000 },  // 鍗€鍩熺稉鐞�
                    7: { min: 55000, max: 70000 },  // 鐕熼亱绺界洠
                    8: { min: 70000, max: 90000 },  // 鍓�绺界稉鐞�
                    9: { min: 90000, max: 120000 }  // 绺界稉鐞�
                };
                return ranges[level] || { min: 25000, max: 30000 };
            };
            
            // 鍙栧緱鐣跺墠鏃ユ湡涓﹁▓绠楄捣濮嬫湀浠�
            const currentDate = new Date();
            const currentYear = currentDate.getFullYear();
            const currentMonth = currentDate.getMonth() + 1;
            
            // 寤虹珛娓�瑭﹁硣鏂�
            const salaryRecords = [];
            const baseSalaryRange = getBaseSalaryRange(employeeData.level || 1);
            let baseSalary = Math.floor(Math.random() * (baseSalaryRange.max - baseSalaryRange.min + 1)) + baseSalaryRange.min;
            
            // 瑷�瀹氳定鍕�锛�0=骞崇┅, 1=涓婂崌, -1=涓嬮檷
            const trendFactor = trend === undefined ? (Math.random() > 0.5 ? 1 : -1) : trend;
            // 瑷�瀹氳畩鐣板害锛氶爯瑷�0.05锛岀瘎鍦�0.01-0.2
            const varianceFactor = variance === undefined ? 0.05 : Math.max(0.01, Math.min(0.2, variance));
            
            for (let i = 0; i < months; i++) {
                // 瑷堢畻骞存湀
                let recordMonth = currentMonth - i - 1;
                let recordYear = currentYear;
                
                if (recordMonth <= 0) {
                    recordMonth += 12;
                    recordYear -= 1;
                }
                
                // 鐢熸垚鍑哄嫟鐜囷紙80-100%锛�
                const attendanceRate = 0.8 + (Math.random() * 0.2);
                
                // 鐢熸垚绺炬晥瑭曞垎锛�60-100鍒嗭級
                const performanceScore = 60 + (Math.random() * 40);
                
                // 鏍规摎瓒ㄥ嫝瑾挎暣鍩烘湰钖�璩�
                baseSalary += Math.floor(trendFactor * (baseSalary * 0.005 * (1 + Math.random() * 0.5)));
                
                // 寮曞叆璁婄暟
                const actualBaseSalary = Math.floor(baseSalary * (1 + (Math.random() - 0.5) * 2 * varianceFactor));
                
                // 瑷堢畻閵峰敭閬旀垚鐜囷紙70-130%锛�
                const salesAchievement = 0.7 + (Math.random() * 0.6);
                
                // 瑷堢畻鍔犵彮鏅傛暩锛�0-30灏忔檪锛�
                const overtimeHours = Math.floor(Math.random() * 30);
                
                // 瑷堢畻鍏ㄥ嫟鐛庨噾
                const perfectAttendanceBonus = attendanceRate >= 0.98 ? 2000 : 0;
                
                // 瑷堢畻绺炬晥鐛庨噾锛堜緷绺炬晥瑭曞垎锛�
                const performanceBonus = Math.floor((performanceScore - 60) / 40 * 5000);
                
                // 瑷堢畻閵峰敭鐛庨噾
                const salesBonus = Math.floor((salesAchievement - 0.7) / 0.6 * 8000);
                
                // 瑷堢畻鍔犵彮璨�
                const overtimePay = Math.floor(overtimeHours * (actualBaseSalary / 160) * 1.5);
                
                // 瑷堢畻璜嬪亣鎵ｆ�撅紙鍩烘柤鍑哄嫟鐜囷級
                const leavesDeduction = Math.floor((1 - attendanceRate) * actualBaseSalary);
                
                // 瑷堢畻绺界崕閲�
                const totalBonus = perfectAttendanceBonus + performanceBonus + salesBonus + overtimePay;
                
                // 瑷堢畻绺芥墸娆�
                const totalDeduction = leavesDeduction;
                
                // 瑷堢畻绺借柂璩�
                const totalSalary = actualBaseSalary + totalBonus - totalDeduction;
                
                // 鐢熸垚娓�瑭﹁柂璩囪�橀寗
                const salaryRecord = {
                    employeeId,
                    employeeName: employeeData.name,
                    employeeLevel: employeeData.level || 1,
                    storeId,
                    storeName: storeData.name,
                    year: recordYear,
                    month: recordMonth,
                    baseSalary: actualBaseSalary,
                    bonuses: {
                        perfectAttendance: perfectAttendanceBonus,
                        performance: performanceBonus,
                        sales: salesBonus,
                        overtime: overtimePay
                    },
                    deductions: {
                        leaves: leavesDeduction
                    },
                    totalSalary,
                    metrics: {
                        attendanceRate,
                        performanceScore,
                        salesAchievement,
                        overtimeHours
                    },
                    isTestData: true,
                    createdBy: context.auth.uid,
                    createdAt: admin.firestore.FieldValue.serverTimestamp()
                };
                
                salaryRecords.push(salaryRecord);
            }
            
            // 瀵�鍏ユ脯瑭﹁柂璩囪�橀寗
            const batch = db.batch();
            for (const record of salaryRecords) {
                const docId = `${record.employeeId}_${record.year}_${record.month}_test`;'
                batch.set(db.collection('salary_records').doc(docId), record);
            }
            await batch.commit();
            
            // 瑷橀寗绠＄悊鍝″煼琛屾�ゆ搷浣滅殑娲诲嫊
            await logActivity({
                userId: context.auth.uid,
                userName: userData.name,'
                feature: 'SalaryPrediction','
                action: 'GenerateTestData',
                details: {
                    employeeId,
                    storeId,
                    months,
                    recordCount: salaryRecords.length
                },
                success: true
            });
            
            return {
                success: true,'
                message: '娓�瑭﹁柂璩囪硣鏂欏凡鎴愬姛鐢熸垚',
                recordCount: salaryRecords.length,
                months,
                employeeId,
                storeId
            };
        } catch (error) {'
            logger.error('鐢熸垚娓�瑭﹁柂璩囪硣鏂欐檪鍑洪尟:', error);
            
            // 瑷橀寗閷�瑾�
            if (context.auth) {
                await logActivity({
                    userId: context.auth.uid,'
                    feature: 'SalaryPrediction','
                    action: 'GenerateTestDataError',
                    details: { error: error.message },
                    success: false
                });
            }
            
            if (error instanceof HttpsError) {
                throw error;
            } else {'
                throw new HttpsError('internal', `鐢熸垚娓�瑭﹁柂璩囪硣鏂欐檪鐧肩敓閷�瑾�: ${error.message}`);
            }
        }
    }
);

/**
 * 娓呴櫎钖�璩囬爯娓�娓�瑭﹁硣鏂�
 * 姝ゅ嚱鏁稿厑瑷辩�＄悊鍝℃竻闄ゆ�欒�樼偤娓�瑭︾殑钖�璩囪�橀寗
 */
exports.clearSalaryPredictionTestData = onCall('
    { memory: '512MiB', timeoutSeconds: 120 },
    async (request, context) => {
        // 妾㈡煡鍛煎彨鑰呮瑠闄� - 鍙�鍏佽ū绠＄悊鍝′娇鐢�
        if (!context.auth) {'
            throw new HttpsError('unauthenticated', '闇€瑕佺櫥鍏ユ墠鑳戒娇鐢ㄦ�ゅ姛鑳�');
        }

        try {
            // 鐛插彇瑾跨敤鑰呯殑鐢ㄦ埗绱氬垾'
            const userSnapshot = await db.collection('employees').where('uid', '==', context.auth.uid).limit(1).get();
            if (userSnapshot.empty) {'
                throw new HttpsError('permission-denied', '鎵句笉鍒版偍鐨勭敤鎴惰硣鏂�');
            }
            
            const userData = userSnapshot.docs[0].data();
            const userLevel = userData.level || 0;
            
            // 鍙�鍏佽ū绯荤当绠＄悊鍝★紙绱氬垾 >= 8锛変娇鐢ㄦ�ゅ姛鑳�
            if (userLevel < 8) {'
                throw new HttpsError('permission-denied', '鎮ㄦ矑鏈夋瑠闄愬煼琛屾�ゆ搷浣滐紝闇€瑕佺郴绲辩�＄悊鍝℃瑠闄�');
            }
            
            // 婧栧倷鏌ヨ�㈠弮鏁�
            const filters = {};
            if (request.data) {
                if (request.data.employeeId) filters.employeeId = request.data.employeeId;
                if (request.data.storeId) filters.storeId = request.data.storeId;
                if (request.data.year) filters.year = request.data.year;
                if (request.data.month) filters.month = request.data.month;
            }
            
            // 鏌ヨ�㈡墍鏈夋脯瑭﹁柂璩囪�橀寗'
            let query = db.collection('salary_records').where('isTestData', '==', true);
            
            // 娣诲姞椤嶅�栫殑閬庢烤姊濅欢
            for (const [field, value] of Object.entries(filters)) {'
                query = query.where(field, '==', value);
            }
            
            const testRecordsSnapshot = await query.get();
            
            if (testRecordsSnapshot.empty) {
                return {
                    success: true,'
                    message: '娌掓湁鎵惧埌娓�瑭﹁柂璩囪�橀寗',
                    count: 0
                };
            }
            
            // 鍒�闄ゆ墍鏈夋脯瑭﹁柂璩囪�橀寗
            const batch = db.batch();
            testRecordsSnapshot.docs.forEach(doc => {
                batch.delete(doc.ref);
            });
            await batch.commit();
            
            // 瑷橀寗绠＄悊鍝″煼琛屾�ゆ竻鐞嗘搷浣�
            await logActivity({
                userId: context.auth.uid,
                userName: userData.name,'
                feature: 'SalaryPrediction','
                action: 'ClearTestData',
                details: {
                    count: testRecordsSnapshot.size,
                    filters
                },
                success: true
            });
            
            return {
                success: true,'
                message: '娓�瑭﹁柂璩囪硣鏂欏凡鎴愬姛娓呴櫎',
                count: testRecordsSnapshot.size,
                filters
            };
        } catch (error) {'
            logger.error('娓呴櫎娓�瑭﹁柂璩囪硣鏂欐檪鍑洪尟:', error);
            
            // 瑷橀寗閷�瑾�
            if (context.auth) {
                await logActivity({
                    userId: context.auth.uid,'
                    feature: 'SalaryPrediction','
                    action: 'ClearTestDataError',
                    details: { error: error.message },
                    success: false
                });
            }
            
            if (error instanceof HttpsError) {
                throw error;
            } else {'
                throw new HttpsError('internal', `娓呴櫎娓�瑭﹁柂璩囪硣鏂欐檪鐧肩敓閷�瑾�: ${error.message}`);
            }
        }
    }
);

/**
 * 鍚屾�ラ洟绶氭墦鍗¤�橀寗
 * 姝ゅ嚱鏁歌檿鐞嗗緸瀹㈡埗绔�涓婂偝鐨勯洟绶氭墦鍗℃暩鎿氾紝鍦ㄧ恫绲℃仮寰╁緦閫茶�屽悓姝�
 */
exports.syncOfflineClockRecords = functions.https.onCall(async (data, context) => {
    // 椹楄瓑鐢ㄦ埗韬�浠�
    if (!context.auth) {
        throw new functions.https.HttpsError('
            'unauthenticated','
            '闇€瑕佺櫥鍏ユ墠鑳藉悓姝ラ洟绶氭墦鍗¤�橀寗'
        );
    }
    
    const userId = context.auth.uid;'
    const userData = await admin.firestore().collection('users').doc(userId).get();
    
    if (!userData.exists) {
        throw new functions.https.HttpsError('
            'not-found','
            '鎵句笉鍒扮敤鎴惰硣鏂�'
        );
    }
    
    // 鎻愬彇涓﹂�楄瓑闆㈢窔瑷橀寗鏁告摎
    const { offlineRecords } = data;
    if (!offlineRecords || !Array.isArray(offlineRecords)) {
        throw new functions.https.HttpsError('
            'invalid-argument','
            '闆㈢窔瑷橀寗鏁告摎鏍煎紡鐒℃晥'
        );
    }
    
    // 瑙ｆ瀽闆㈢窔瑷橀寗
    const processedRecords = [];
    const errorRecords = [];
    const batch = admin.firestore().batch();
    
    for (const record of offlineRecords) {
        try {
            // 椹楄瓑瑷橀寗鏍煎紡
            if (!record.timestamp || !record.storeId || !record.action) {
                throw new Error(`瑷橀寗缂哄皯蹇呰�佹瑒浣�: ${JSON.stringify(record)}`);
            }
            
            // 灏囧瓧绗︿覆鏅傞枔鎴宠綁鎻涚偤Firestore鏅傞枔鎴�
            const recordTimestamp = admin.firestore.Timestamp.fromDate(new Date(record.timestamp));
            
            // 妾㈡煡鏄�鍚︾偤澶�鑸婄殑瑷橀寗锛堝�傝秴閬�7澶╋級
            const now = admin.firestore.Timestamp.now();
            const sevenDaysInSeconds = 7 * 24 * 60 * 60;
            
            if ((now.seconds - recordTimestamp.seconds) > sevenDaysInSeconds) {
                throw new Error(`瑷橀寗閬庢湡锛堣秴閬�7澶╋級: ${record.timestamp}`);
            }
            
            // 妾㈡煡鏄�鍚﹀凡瀛樺湪鐩镐技鏅傞枔鐨勮�橀寗锛�5鍒嗛悩鍏э級
            const startTime = new Date(recordTimestamp.toDate().getTime() - 5 * 60 * 1000);
            const endTime = new Date(recordTimestamp.toDate().getTime() + 5 * 60 * 1000);
            
            const existingRecords = await admin.firestore()'
                .collection('clock_records')'
                .where('userId', '==', userId)'
                .where('timestamp', '>=', admin.firestore.Timestamp.fromDate(startTime))'
                .where('timestamp', '<=', admin.firestore.Timestamp.fromDate(endTime))
                .get();
            
            if (!existingRecords.empty) {
                throw new Error(`宸插瓨鍦ㄧ浉浼兼檪闁撶殑瑷橀寗: ${record.timestamp}`);
            }
            
            // 娣诲姞鏂拌�橀寗'
            const recordId = admin.firestore().collection('clock_records').doc().id;
            const clockRecord = {
                id: recordId,
                userId: userId,'
                userName: userData.data().name || userData.data().displayName || '',
                timestamp: recordTimestamp,
                storeId: record.storeId,
                action: record.action,
                synced: true,'
                syncedFrom: 'offline',
                syncTimestamp: admin.firestore.FieldValue.serverTimestamp(),
                location: record.location || null,
                deviceInfo: record.deviceInfo || null,
                offlineCreated: true
            };
            
            // 灏囪�橀寗娣诲姞鍒版壒铏曠悊'
            batch.set(admin.firestore().collection('clock_records').doc(recordId), clockRecord);
            
            // 鏇存柊鐢ㄦ埗鐨勬渶寰屾墦鍗＄媭鎱�
            const userUpdate = {};'
            if (record.action === 'clockIn') {'
                userUpdate.clockStatus = 'in';
                userUpdate.lastClockIn = recordTimestamp;'
            } else if (record.action === 'clockOut') {'
                userUpdate.clockStatus = 'out';
                userUpdate.lastClockOut = recordTimestamp;
            }
            '
            batch.update(admin.firestore().collection('users').doc(userId), userUpdate);
            
            // 娣诲姞鍒版垚鍔熻檿鐞嗗垪琛�
            processedRecords.push({
                original: record,
                processed: recordId,
                timestamp: recordTimestamp.toDate()
            });
            
        } catch (error) {
            console.error(`铏曠悊闆㈢窔瑷橀寗鏅傚嚭閷�:`, error);
            // 娣诲姞鍒伴尟瑾ゅ垪琛�
            errorRecords.push({
                original: record,
                error: error.message
            });
        }
    }
    
    // 濡傛灉鏈夋垚鍔熻檿鐞嗙殑瑷橀寗锛屾彁浜ゆ壒铏曠悊
    if (processedRecords.length > 0) {
        await batch.commit();
        
        // 瑷橀寗鍚屾�ユ搷浣�'
        await admin.firestore().collection('system_logs').add({'
            type: 'offline_sync',
            userId: userId,'
            userName: userData.data().name || userData.data().displayName || '',
            timestamp: admin.firestore.FieldValue.serverTimestamp(),
            processedCount: processedRecords.length,
            errorCount: errorRecords.length,'
            details: 'Offline clock records synced'
        });
    }
    
    // 杩斿洖铏曠悊绲愭灉
    return {'
        status: 'success',
        processed: processedRecords.length,
        errors: errorRecords.length,
        details: {
            processedRecords,
            errorRecords
        }
    };
});

/**
 * 鐢熸垚钖�璩囬爯娓�娓�瑭︽暩鎿�
 * 鍍呬緵绯荤当绠＄悊鍝′娇鐢�锛岀敤鏂肩敘鐢熸脯瑭︾敤鐨勮柂璩囪�橀寗
 */
exports.generateSalaryPredictionTestData = functions.https.onCall(
    async (data, context) => {
        // 纰轰繚浣跨敤鑰呭凡鐧诲叆
        if (!context.auth) {
            throw new functions.https.HttpsError('
                'unauthenticated','
                '闇€瑕佺櫥鍏ユ墠鑳戒娇鐢ㄦ�ゅ姛鑳�'
            );
        }

        try {
            // 妾㈡煡浣跨敤鑰呮瑠闄� (鍍呯�＄悊鍝″彲浣跨敤)'
            const userDoc = await admin.firestore().collection('users').doc(context.auth.uid).get();
            if (!userDoc.exists) {'
                throw new functions.https.HttpsError('not-found', '鎵句笉鍒颁娇鐢ㄨ€呰硣鏂�');
            }

            const userData = userDoc.data();
            if (!userData.level || userData.level < 8) {
                throw new functions.https.HttpsError('
                    'permission-denied', '
                    '鍍呯郴绲辩�＄悊鍝″彲浣跨敤姝ゅ姛鑳�'
                );
            }

            // 椹楄瓑蹇呰�佸弮鏁�
            const { employeeId, storeId, months, trendType, fluctuation } = data;
            if (!employeeId || !storeId || !months || months < 1 || months > 24) {
                throw new functions.https.HttpsError('
                    'invalid-argument','
                    '鍙冩暩鐒℃晥锛岃珛纰轰繚鎻愪緵鍝″伐ID銆佸晢搴桰D鍜屾湀鏁�(1-24)'
                );
            }

            // 鐛插彇鍝″伐璩囨枡'
            const employeeDoc = await admin.firestore().collection('users').doc(employeeId).get();
            if (!employeeDoc.exists) {'
                throw new functions.https.HttpsError('not-found', '鎵句笉鍒版寚瀹氬摗宸�');
            }
            const employeeData = employeeDoc.data();

            // 鐛插彇鍟嗗簵璩囨枡'
            const storeDoc = await admin.firestore().collection('stores').doc(storeId).get();
            if (!storeDoc.exists) {'
                throw new functions.https.HttpsError('not-found', '鎵句笉鍒版寚瀹氬晢搴�');
            }

            // 瑷�瀹氬熀鏈�钖�璩囩瘎鍦� (鏍规摎绛夌礆)
            let baseSalaryRange = { min: 24000, max: 28000 }; // 榛樿獚鍊�
            
            if (employeeData.level) {
                switch (employeeData.level) {
                    case 1: // 涓€鑸�鍝″伐
                        baseSalaryRange = { min: 24000, max: 28000 };
                        break;'
                    case 2: // 璩囨繁鍝″伐
}
}
}
}
}