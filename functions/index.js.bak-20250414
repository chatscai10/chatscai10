// functions/index.js - 測試??(修正 checkMissedClockIn ??v2，並?�入詳細 Log)

// --- 引入 ---
const { onRequest, onCall, HttpsError } = require("firebase-functions/v2/https");
const { onDocumentCreated, onDocumentUpdated } = require("firebase-functions/v2/firestore");
const { onSchedule } = require("firebase-functions/v2/scheduler"); // <--- 確�?引入 v2 scheduler
const { defineString, defineSecret } = require("firebase-functions/params");
const { logger } = require("firebase-functions");
const functions = require("firebase-functions"); // 保�? v1 SDK (?�能?��?輔助?�數仍�?�?
const admin = require("firebase-admin");
const axios = require("axios");
const line = require('@line/bot-sdk');
const TelegramBot = require('node-telegram-bot-api');
const { getMessaging } = require("firebase-admin/messaging");
const cors = require('cors')({ origin: true }); // <-- 引入並�?�?CORS
// ADDED: Import FieldValue for timestamp operations
const { FieldValue } = require("firebase-admin/firestore");

// --- ?��???Firebase Admin SDK ---
try {
    if (!admin.apps.length) {
        admin.initializeApp();
        logger.info("Firebase Admin SDK Initialized.");
    }
} catch (e) { logger.error("Firebase Admin Init Error:", e); }
const db = admin.firestore();
const auth = admin.auth();

// --- ?�數定義 ---
const LINE_CHANNEL_ID_PARAM = defineString("LINE_CHANNEL_ID");
const LINE_OA_TOKEN_PARAM = defineSecret("LINE_OA_TOKEN");
const TELEGRAM_BOT_TOKEN_PARAM = defineSecret("TELEGRAM_BOT_TOKEN");

// --- API Clients 變數�?? ---
let lineClient = null;
let telegramBot = null;

// --- 常�?定義 ---
const NOTIFICATION_CONFIG_PATH = 'settings/notification_config';
const USER_NOTIFICATION_PREFS_PATH = 'user_notification_preferences';
const MAX_NOTIFICATION_ATTEMPTS = 3; // ?�試次數
const NOTIFICATION_RETRY_DELAY = 5000; // ?�試?��?(ms)

// --- 輔助?�數 ---

/**
 * ?��??�並?��? Line Client
 */
function getLineClient() {
  if (!lineClient) {
    try {
      const lineConfig = {
        channelId: LINE_CHANNEL_ID_PARAM.value(),
        channelAccessToken: LINE_OA_TOKEN_PARAM.value()
      };
      if (!lineConfig.channelId || !lineConfig.channelAccessToken) {
        logger.error("LINE Channel ID or Access Token parameter is missing.");
        return null;
      }
      lineClient = new line.Client(lineConfig);
    } catch (error) {
      logger.error(`Error initializing LINE client: ${error.message}`);
      return null;
    }
  }
  return lineClient;
}

/**
 * ?��??�並?��? Telegram Bot
 */
function getTelegramBot() {
  if (!telegramBot) {
    try {
      const token = TELEGRAM_BOT_TOKEN_PARAM.value();
      if (!token) {
        logger.error("Telegram Bot Token parameter is missing.");
        return null;
      }
      telegramBot = new TelegramBot(token, { polling: false });
    } catch (error) {
      logger.error(`Error initializing Telegram bot: ${error.message}`);
      return null;
    }
  }
  return telegramBot;
}

/**
 * ?��??��??�戳 (輔助?�數)
 */
function formatTimestamp(timestamp, format = 'YYYY-MM-DD HH:mm') {
    if (!timestamp) return 'N/A';
    try {
        const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
        // 簡單?�格式�?，可以考慮引入 date-fns ??moment.js
        const year = date.getFullYear();
        const month = (date.getMonth() + 1).toString().padStart(2, '0');
        const day = date.getDate().toString().padStart(2, '0');
        const hours = date.getHours().toString().padStart(2, '0');
        const minutes = date.getMinutes().toString().padStart(2, '0');
        if (format === 'YYYY-MM-DD HH:mm') {
            return `${year}-${month}-${day} ${hours}:${minutes}`;
        } else if (format === 'YYYY-MM-DD') {
            return `${year}-${month}-${day}`;
        }
        return date.toLocaleString();
    } catch (e) {
        logger.warn("Error formatting timestamp:", e);
        return 'Invalid Date';
    }
}

/**
 * 統�??�通知?�送函??- ?��?多平?��?模板
 * @param {string} type - ?�知類�? (e.g., 'leave', 'schedule', 'clockin_reminder')
 * @param {object} data - 要替?�模?��??��??��? (e.g., { userName: '...', date: '...', message: '...' })
 * @param {object} [options={}] - ?��??��?
 * @param {string} [options.userId] - ?��??�人?�戶ID (?�於?�人?�知)
 * @param {boolean} [options.skipGlobal=false] - ?�否跳�??�送全局?�知
 * @param {boolean} [options.skipPersonal=false] - ?�否跳�??�送個人?�知
 * @param {boolean} [options.isAdminTarget=false] - ?�否?�送到管�??�目標ID
 * @param {number} [attempt=1] - ?��??�試次數
 */
async function sendNotification(type, data, options = {}, attempt = 1) {
    logger.info(`Attempt ${attempt}: Preparing notification type: ${type}`, { data, options });

    try {
        // ?��??��??�知設�?
        const configDoc = await db.collection('settings').doc(NOTIFICATION_CONFIG_PATH).get();
        if (!configDoc.exists) {
            logger.warn('Notification config not found, aborting sendNotification.');
            return { success: false, error: 'Notification config not found' };
        }
        const config = configDoc.data();
        const templates = config.templates || {};
        const defaultTemplate = templates[type] || {
            line: `${type} notification: ${data.message || JSON.stringify(data)}`,
            telegram: `${type} notification: ${data.message || JSON.stringify(data)}`,
            // email: { subject: `${type} notification`, body: `${data.message || JSON.stringify(data)}` }
        };

        // ?��?變數?��?
        const replacePlaceholders = (text, contextData) => {
            if (!text) return '';
            return text.replace(/\${([^}]+)}/g, (match, key) => {
                return contextData[key] !== undefined ? contextData[key] : match;
            });
        };

        const results = {
            globalLine: { sent: false, skipped: false },
            globalTelegram: { sent: false, skipped: false },
            // globalEmail: { sent: false, skipped: false },
            personalLine: { sent: false, skipped: false },
            personalTelegram: { sent: false, skipped: false },
            // personalEmail: { sent: false, skipped: false },
        };

        const lineClientInstance = getLineClient();
        const telegramBotInstance = getTelegramBot();
        // const emailTransporterInstance = getEmailTransporter();

        // --- ?�送全局?�知 ---
        if (!options.skipGlobal) {
            // ?��? LINE ?�知
            const lineTargetId = options.isAdminTarget ? config.line?.adminTargetId : config.line?.targetId;
            if (config.line?.enabled && lineTargetId && (!config.line.notifyOn || config.line.notifyOn[type])) {
                if (lineClientInstance) {
                    try {
                        const lineMessage = replacePlaceholders(defaultTemplate.line, data);
                        await lineClientInstance.pushMessage(lineTargetId, { type: 'text', text: lineMessage });
                        results.globalLine = { sent: true };
                        logger.info(`Global LINE notification sent for type: ${type} to ${lineTargetId}`);
                    } catch (error) {
                        results.globalLine = { sent: false, error: error.message };
                        logger.error(`Error sending global LINE notification: ${error.message}`);
                    }
                } else {
                    results.globalLine = { sent: false, error: 'LINE client init failed' };
                }
            } else {
                results.globalLine.skipped = true;
            }

            // ?��? Telegram ?�知
            const telegramTargetId = options.isAdminTarget ? config.telegram?.adminChatId : config.telegram?.chatId;
            if (config.telegram?.enabled && telegramTargetId && (!config.telegram.notifyOn || config.telegram.notifyOn[type])) {
                if (telegramBotInstance) {
                    try {
                        const telegramMessage = replacePlaceholders(defaultTemplate.telegram, data);
                        await telegramBotInstance.sendMessage(telegramTargetId, telegramMessage);
                        results.globalTelegram = { sent: true };
                        logger.info(`Global Telegram notification sent for type: ${type} to ${telegramTargetId}`);
                    } catch (error) {
                        results.globalTelegram = { sent: false, error: error.message };
                        logger.error(`Error sending global Telegram notification: ${error.message}`);
                    }
                } else {
                    results.globalTelegram = { sent: false, error: 'Telegram bot init failed' };
                }
            } else {
                results.globalTelegram.skipped = true;
            }

            // TODO: Add Global Email Notification
        } else {
             results.globalLine.skipped = true;
             results.globalTelegram.skipped = true;
             // results.globalEmail.skipped = true;
        }

        // --- ?�送個人?�知 ---
        if (options.userId && !options.skipPersonal) {
            let userData = null;
            let prefs = null;

            try {
                // MODIFIED: Query 'employees' collection instead of 'users' for userData
                // ASSUMPTION: The userId passed in options IS the document ID in 'employees' OR we need to query by authUid again.
                // Let's assume for notification purposes, the document ID IS the user ID (needs verification if options.userId comes from Auth UID).
                const userDoc = await db.collection('employees').doc(options.userId).get(); 
                const prefsDoc = await db.collection(USER_NOTIFICATION_PREFS_PATH).doc(options.userId).get();

                // MODIFIED: Check userDoc.exists property
                if (userDoc.exists) { 
                    userData = userDoc.data();
                } else {
                     logger.warn(`User data not found for personal notification: ${options.userId}`);
                     options.skipPersonal = true; // Skip if user data missing
                }

                if (prefsDoc.exists) {
                    prefs = prefsDoc.data();
                } else {
                    // Use default preferences if not set (e.g., allow LINE by default)
                    prefs = { platforms: { line: true }, subscriptions: {} }; // Assuming all types allowed if no specific subscription found
                    logger.info(`User preferences not found for ${options.userId}, using defaults.`);
                }

            } catch (fetchError) {
                 logger.error(`Failed to fetch user data or preferences for ${options.userId}:`, fetchError);
                 options.skipPersonal = true; // Skip if data fetching fails
            }


            if (!options.skipPersonal && userData) {
                // 檢查?�戶?�否訂閱此�??�知
                const isSubscribed = (prefs.subscriptions && prefs.subscriptions[type] !== false);

                if (isSubscribed) {
                    // 檢查?�否?��??��???                    let inQuietHours = false;
                    if (prefs.quiet_hours?.enabled && prefs.quiet_hours.start && prefs.quiet_hours.end) {
                       try {
                            const now = new Date();
                            const currentHour = now.getHours();
                            const currentMinute = now.getMinutes();
                            const currentTimeMinutes = currentHour * 60 + currentMinute;

                            const startParts = prefs.quiet_hours.start.split(':');
                            const endParts = prefs.quiet_hours.end.split(':');

                            const startTimeMinutes = parseInt(startParts[0]) * 60 + parseInt(startParts[1]);
                            const endTimeMinutes = parseInt(endParts[0]) * 60 + parseInt(endParts[1]);

                            if (!isNaN(startTimeMinutes) && !isNaN(endTimeMinutes)) {
                                if (startTimeMinutes <= endTimeMinutes) {
                                    inQuietHours = currentTimeMinutes >= startTimeMinutes && currentTimeMinutes < endTimeMinutes; // End is exclusive
                                } else { // Handles overnight quiet hours (e.g., 22:00 to 07:00)
                                    inQuietHours = currentTimeMinutes >= startTimeMinutes || currentTimeMinutes < endTimeMinutes;
                                }
                             } else {
                                logger.warn(`Invalid quiet hours format for user ${options.userId}: ${prefs.quiet_hours.start}-${prefs.quiet_hours.end}`);
                             }
                       } catch (quietHoursError) {
                           logger.error(`Error checking quiet hours for user ${options.userId}:`, quietHoursError);
                           inQuietHours = false; // Default to not in quiet hours if error
                       }
                    }

                    if (!inQuietHours) {
                        const personalDataContext = { ...data, name: userData.name || '使用者' };

                        // ?人 LINE ?知
                        if (prefs.platforms?.line !== false && userData.lineUserId) {
                            if (lineClientInstance) {
                                try {
                                    const personalLineMessage = replacePlaceholders(defaultTemplate.line, personalDataContext);
                                    await lineClientInstance.pushMessage(userData.lineUserId, { type: 'text', text: personalLineMessage });
                                    results.personalLine = { sent: true };
                                    logger.info(`Personal LINE notification sent to user: ${options.userId}`);
                                } catch (error) {
                                    results.personalLine = { sent: false, error: error.message };
                                    logger.error(`Error sending personal LINE notification to ${options.userId}: ${error.message}`);
                                }
                             } else {
                                results.personalLine = { sent: false, error: 'LINE client init failed' };
                            }
                        } else {
                           results.personalLine.skipped = true;
                        }

                        // ?人 Telegram ?知
                        if (prefs.platforms?.telegram === true && userData.telegramChatId) {
                             if (telegramBotInstance) {
                                try {
                                    const personalTelegramMessage = replacePlaceholders(defaultTemplate.telegram, personalDataContext);
                                    await telegramBotInstance.sendMessage(userData.telegramChatId, personalTelegramMessage);
                                    results.personalTelegram = { sent: true };
                                    logger.info(`Personal Telegram notification sent to user: ${options.userId}`);
                                } catch (error) {
                                    results.personalTelegram = { sent: false, error: error.message };
                                    logger.error(`Error sending personal Telegram notification to ${options.userId}: ${error.message}`);
                                }
                             } else {
                                 results.personalTelegram = { sent: false, error: 'Telegram bot init failed' };
                             }
                        } else {
                            results.personalTelegram.skipped = true;
                        }

                        // TODO: Add Personal Email Notification

                    } else {
                        results.personalLine.skipped = true; results.personalLine.reason = 'Quiet hours';
                        results.personalTelegram.skipped = true; results.personalTelegram.reason = 'Quiet hours';
                        // results.personalEmail.skipped = true; results.personalEmail.reason = 'Quiet hours';
                        logger.info(`Skipped personal notification to user ${options.userId} due to quiet hours`);
                    }
                } else {
                     results.personalLine.skipped = true; results.personalLine.reason = 'Not subscribed';
                     results.personalTelegram.skipped = true; results.personalTelegram.reason = 'Not subscribed';
                     // results.personalEmail.skipped = true; results.personalEmail.reason = 'Not subscribed';
                    logger.info(`Skipped personal notification to user ${options.userId} as they are not subscribed to ${type}`);
                }
            } else {
                 results.personalLine.skipped = true; results.personalLine.reason = 'User data missing or skipPersonal flag';
                 results.personalTelegram.skipped = true; results.personalTelegram.reason = 'User data missing or skipPersonal flag';
                 // results.personalEmail.skipped = true; results.personalEmail.reason = 'User data missing or skipPersonal flag';
                 if (!userData) logger.warn(`Personal notification skipped because user data was missing for ${options.userId}`);
            }
        } else {
             results.personalLine.skipped = true; results.personalLine.reason = 'No userId provided or skipPersonal flag';
             results.personalTelegram.skipped = true; results.personalTelegram.reason = 'No userId provided or skipPersonal flag';
             // results.personalEmail.skipped = true; results.personalEmail.reason = 'No userId provided or skipPersonal flag';
        }

        // Check if any notification failed and needs retry
        const needsRetry = Object.values(results).some(res => res.sent === false && res.error && !res.skipped);

        if (needsRetry && attempt < MAX_NOTIFICATION_ATTEMPTS) {
            logger.warn(`Notification attempt ${attempt} had failures for type ${type}, retrying in ${NOTIFICATION_RETRY_DELAY}ms...`, { results });
            await new Promise(resolve => setTimeout(resolve, NOTIFICATION_RETRY_DELAY));
            // Only retry failed parts? Or retry all? Simpler to retry all for now.
            return sendNotification(type, data, options, attempt + 1);
        } else if (needsRetry) {
            logger.error(`Notification type ${type} failed after ${MAX_NOTIFICATION_ATTEMPTS} attempts.`, { data, options, results });
        }

        return { success: !needsRetry, results };

    } catch (error) {
        logger.error(`Critical error in sendNotification (Attempt ${attempt}) for type ${type}: ${error.message}`, { error });
        if (attempt < MAX_NOTIFICATION_ATTEMPTS) {
            logger.warn(`Retrying critical error in ${NOTIFICATION_RETRY_DELAY}ms...`);
            await new Promise(resolve => setTimeout(resolve, NOTIFICATION_RETRY_DELAY));
            return sendNotification(type, data, options, attempt + 1);
        } else {
            logger.error(`Notification type ${type} failed critically after ${MAX_NOTIFICATION_ATTEMPTS} attempts.`);
            return { success: false, error: `Critical error after ${MAX_NOTIFICATION_ATTEMPTS} attempts: ${error.message}`, results: {} };
        }
    }
}

// ?��??�修?��???verifyLineToken??async function verifyLineToken(idToken) {
    logger.info("Entering verifyLineToken function.");
    if (!idToken) {
        logger.error("verifyLineToken called with null or empty idToken.");
        throw new functions.https.HttpsError('invalid-argument', 'ID Token 不可?�空');
    }

    let channelId;
    try {
        channelId = LINE_CHANNEL_ID_PARAM.value();
    } catch (e) {
        logger.error("Failed to get LINE_CHANNEL_ID from params inside verifyLineToken:", e);
        throw new functions.https.HttpsError('internal', '無法讀取LINE Channel ID 設定，請檢查環境變數或Secret Manager 設置', { detail: e.message });
    }
    if (!channelId) {
        logger.error("LINE Login Channel ID is configured but value is empty inside verifyLineToken.");
        throw new functions.https.HttpsError('internal', 'LINE Login Channel ID 設定值為空');
    }

    const params = new URLSearchParams();
    params.append('id_token', idToken);
    params.append('client_id', channelId);

    try {
        const response = await axios.post('https://api.line.me/oauth2/v2.1/verify', params, {
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            timeout: 15000
        });

        if (response.data && response.data.aud !== channelId) {
            logger.error("Token verification failed: Audience mismatch.", {
                expectedAud: channelId,
                actualAud: response.data.aud,
                lineUserId: response.data.sub
            });
            throw new Error(`Token audience (aud: ${response.data.aud}) does not match configured Channel ID (${channelId}).`);
        }

        return response.data;

    } catch (error) {
        let errorDetails = {
            message: error.message,
            requestConfig: {
                url: error.config?.url,
                method: error.config?.method,
                headers: error.config?.headers,
            }
        };
        let logMessage = "Error during LINE verify API call";
        let lineErrorMsg = error.message;
        let statusCode = 'UNKNOWN';

        if (axios.isAxiosError(error)) {
            logMessage = "Axios error during LINE verify API call";
            statusCode = error.response?.status || 'Network/Timeout';
            errorDetails.axiosError = {
                status: statusCode,
                statusText: error.response?.statusText,
                responseData: error.response?.data // ** ?�常?��? **
            };
            lineErrorMsg = error.response?.data?.error_description || error.response?.data?.message || error.message;
        }

        logger.error(logMessage, errorDetails);
        throw new Error(`??LINE 驗�?伺�??�通信失�???Token ?��? (Status: ${statusCode} - ${lineErrorMsg})`);
    }
}

// ?��???findOrCreateUser ?�數??async function findOrCreateUser(lineUserId, lineDisplayName, linePictureUrl) {
    logger.info(`findOrCreateUser started for LINE User ID: ${lineUserId}`);
    let authUid = null;
    let employeeData = null;
    let employeeDocId = null;
    let isNewUser = false;
    const employeesRef = db.collection('employees');

    // 1. ?�試??lineUserId 尋找 Firestore 中�??�工記�?
    const querySnapshot = await employeesRef.where('lineUserId', '==', lineUserId).limit(1).get();

    if (!querySnapshot.empty) {
        // --- ?�到?��??�工記�? ---
        const doc = querySnapshot.docs[0];
        employeeDocId = doc.id;
        employeeData = doc.data();
        authUid = employeeData.authUid; // ?��?記�?中�? Firebase Auth UID

        // 確�? employeeData ?�基?��?�?(?�容?��???
        if (!employeeData.name) employeeData.name = lineDisplayName;
        if (employeeData.level === undefined) employeeData.level = 0;
        if (employeeData.isActive === undefined) employeeData.isActive = true; // ?�設?�到就�?設是 active

        if (authUid) {
            // --- ??Auth UID，檢??Auth 帳�??�否存在且�?步�?�?---
            try {
                const userRecord = await auth.getUser(authUid);
                let updatePayload = {};
                if (lineDisplayName && userRecord.displayName !== lineDisplayName) {
                    updatePayload.displayName = lineDisplayName;
                }
                if (linePictureUrl && userRecord.photoURL !== linePictureUrl) {
                    updatePayload.photoURL = linePictureUrl;
                }
                if (Object.keys(updatePayload).length > 0) {
                    await auth.updateUser(authUid, updatePayload);
                }
                // ?�步 Firestore (如�? Firestore ?��??��?較�?)
                let firestoreUpdatePayload = {};
                if(employeeData.name !== lineDisplayName) firestoreUpdatePayload.name = lineDisplayName;
                if(employeeData.pictureUrl !== linePictureUrl) firestoreUpdatePayload.pictureUrl = linePictureUrl || null;
                if(Object.keys(firestoreUpdatePayload).length > 0) {
                    await employeesRef.doc(employeeDocId).update(firestoreUpdatePayload);
                    employeeData = { ...employeeData, ...firestoreUpdatePayload };
                }

            } catch (error) {
                if (error.code === 'auth/user-not-found') {
                    logger.warn(`Auth user ${authUid} linked to ${employeeDocId} not found. Attempting to recreate/relink...`);
                    try {
                        await auth.createUser({
                            uid: authUid,
                            displayName: lineDisplayName,
                            photoURL: linePictureUrl
                        });
                    } catch (recreateError) {
                        logger.warn(`Recreating Auth user with old UID ${authUid} failed. Creating NEW Auth user...`, recreateError);
                        try {
                            const newUserRecord = await auth.createUser({
                                displayName: lineDisplayName,
                                photoURL: linePictureUrl
                            });
                            const newAuthUid = newUserRecord.uid;
                            await employeesRef.doc(employeeDocId).update({ authUid: newAuthUid });
                            authUid = newAuthUid;
                            employeeData.authUid = newAuthUid;
                        } catch (finalCreateError) {
                            logger.error(`Failed to create new Auth user after previous one was missing for ${employeeDocId}:`, finalCreateError);
                            throw new functions.https.HttpsError('internal', '用戶認證關聯時發生錯誤');
                        }
                    }
                } else {
                    logger.error(`Error fetching auth user ${authUid} for employee ${employeeDocId}:`, error);
                    throw error;
                }
            }
        } else {
            logger.warn(`Firestore record ${employeeDocId} exists but is missing authUid. Creating and linking Auth user...`);
            try {
                const newUserRecord = await auth.createUser({
                    displayName: lineDisplayName,
                    photoURL: linePictureUrl
                });
                authUid = newUserRecord.uid;
                await employeesRef.doc(employeeDocId).update({ authUid: authUid });
                employeeData.authUid = authUid;
            } catch (linkError) {
                logger.error(`Error creating/linking Auth user for existing record ${employeeDocId}:`, linkError);
                throw new functions.https.HttpsError('internal', '關聯認證到現有記錄時出錯');
            }
        }

    } else {
        // --- ?新使用??Firestore ??Auth ????---
        isNewUser = true;
        logger.info(`New user detected with LINE User ID: ${lineUserId}. Creating Firestore record and Auth user.`);
        try {
            // 1. ?�建 Firebase Auth 帳�?
            const newUserRecord = await auth.createUser({
                displayName: lineDisplayName,
                photoURL: linePictureUrl
            });
            authUid = newUserRecord.uid;

            // 2. 準�? Firestore ?�工資�?
            employeeData = {
                authUid: authUid,
                lineUserId: lineUserId,
                name: lineDisplayName,
                pictureUrl: linePictureUrl || null,
                level: 0,
                registrationTimestamp: admin.firestore.FieldValue.serverTimestamp(),
                isActive: true,
                store: null,
                phone: null,
            };

            // 3. ?�建 Firestore ?�工記�?
            const docRef = await employeesRef.add(employeeData);
            employeeDocId = docRef.id;

        } catch (error) {
            logger.error("New user creation failed (Auth or Firestore):", error);
            if (authUid && !employeeDocId) {
                logger.warn(`Deleting orphaned Auth user ${authUid} because Firestore record creation failed.`);
                await auth.deleteUser(authUid).catch(delErr => logger.error(`Failed to delete orphaned Auth user ${authUid}:`, delErr));
            }
            throw new functions.https.HttpsError('internal', '建立用戶資料失敗！');
        }
    }

    if (!authUid || !employeeData || !employeeDocId) {
        logger.error("User data incomplete after findOrCreate process. This should not happen.", { authUid, employeeDocId, hasData: !!employeeData });
        throw new functions.https.HttpsError('internal', '無法完整地建立用戶資訊');
    }

    // --- ADDED: Set Custom Claim for level --- 
    const userLevel = employeeData.level ?? 0; // Get level from employeeData, default to 0 if missing
    try {
        await admin.auth().setCustomUserClaims(authUid, { level: userLevel });
        logger.info(`Successfully set custom claim level=${userLevel} for user ${authUid}`);
    } catch (claimError) {
        logger.error(`Failed to set custom claim level=${userLevel} for user ${authUid}:`, claimError);
        // Decide if this should be a critical error. For now, log and continue.
        // Depending on the application, maybe throw an error here.
    }
    // --- END: Set Custom Claim --- 

    employeeData.id = employeeDocId; // Add docId to returned data
    return { authUid, employeeData, employeeDocId, isNewUser };
}

// --- 輔助?�數 mapHttpsErrorCodeToHttpStatus 保�?不�? ---
function mapHttpsErrorCodeToHttpStatus(code) {
    // ... (mapHttpsErrorCodeToHttpStatus ?�數?�輯保�?不�?) ...
    switch (code) {
        case 'unauthenticated': return 401;
        case 'permission-denied': return 403;
        case 'invalid-argument': return 400;
        case 'not-found': return 404;
        case 'already-exists': return 409;
        case 'failed-precondition': return 400;
        case 'aborted': return 409;
        case 'out-of-range': return 400;
        case 'unavailable': return 503;
        case 'deadline-exceeded': return 504;
        case 'internal':
        case 'unknown':
        default: return 500;
    }
}

// ===========================================
// == 導出?�數 ==
// ===========================================

/**
 * 記�?活�??��???Firestore
 * @param {object} logData - ?��??��?
 * @param {string} logData.userId - ?��??��??�用??Firebase Auth UID (??'system' �?��系統?��?)
 * @param {string} [logData.userName] - ?��??��??�用?��? (?�選，用?�顯示方�?
 * @param {string} logData.feature - ?�能模�? (e.g., 'Auth', 'EmployeeAdmin', 'ClockIn', 'ScheduledTask')
 * @param {string} logData.action - ?��??�具體�?�?(e.g., 'LoginSuccess', 'LoginFail', 'CreateEmployee', 'UpdateEmployee', 'DeleteEmployee', 'RunCheckMissedClockIn')
 * @param {string|object} [logData.details] - ?��?詳�? (?�以?�簡?��?訊息字串，�??�含?��??�數?��?對象，�?如更?��?後�???
 * @param {boolean} [logData.success] - ?��??�否?��? (?�選)
 */
async function logActivity(logData) {
    try {
        const logEntry = {
            timestamp: admin.firestore.FieldValue.serverTimestamp(), // ?��?記�??��???            userId: logData.userId || 'anonymous', // 記�??�戶 ID，若?��???anonymous
            userName: logData.userName || null, // 記�??�戶??(?�選)
            feature: logData.feature || 'Unknown', // ?�能模�?
            action: logData.action || 'UnknownAction', // ?��??��?
            details: logData.details || null, // ?��?詳�?
            success: logData.success === undefined ? null : Boolean(logData.success) // ?��?結�? (?�選)
        };

        await db.collection('activity_logs').add(logEntry);
        // logger.info("Activity logged successfully:", logEntry); // ?�以?��?註解以在?��?中查??    } catch (error) {
        logger.error("Failed to write activity log:", { error: error.message, logData });
        // ?�常記�?失�?不�??�斷主�?�?    }
}

/**
 * LIFF?�入?��??�數 (Cloud Function v2 onRequest)
 * ?��?來自?�端 fetch ??POST 請�?，�???LINE ID Token?? * 驗�? Token，查?��??�建?�戶，�???Firebase ?��?�?Token 返�?給�?端�? */
exports.handleLiffLogin = onRequest(
    {
        // Optional: configure CORS, memory, timeout, secrets, etc.
        // MODIFIED: Removed LINE_CHANNEL_ID_PARAM from secrets array as it's not a secret
        // secrets: [LINE_CHANNEL_ID_PARAM], // <--- REMOVED THIS LINE
        maxInstances: 10,
        // CORS is now handled manually using the cors middleware
    },
    (req, res) => {
        // --- 使用 CORS 中�?�?--- 
        cors(req, res, async () => {
            logger.info("handleLiffLogin (onRequest) function invoked.", { method: req.method });
            let userIdForLog = 'anonymous'; // Default log user
            let userNameForLog = null;
            let logDetails = {};
            let loginSuccess = false;

            try {
                // 0. 檢查請�??��???Body
                if (req.method !== 'POST') {
                    logDetails = { error: 'Method Not Allowed', method: req.method };
                    throw new Error('Method Not Allowed'); // Trigger catch block for logging
                }
                if (!req.body || !req.body.idToken) {
                    logDetails = { error: 'Missing idToken in request body', bodyKeys: Object.keys(req.body || {}) };
                    throw new Error('Request body missing idToken'); // Trigger catch block for logging
                }
                const lineIdToken = req.body.idToken;
                logger.info("Received idToken in request body.");

                // 1. 驗�? LINE ID Token
                logger.info("Calling verifyLineToken with received token...");
                const lineProfile = await verifyLineToken(lineIdToken);
                logger.info("LINE Token verified successfully.", { lineUserId: lineProfile.sub });
                userNameForLog = lineProfile.name; // Get name from LINE profile early
                logDetails.lineUserId = lineProfile.sub;

                const { sub: lineUserId, name: lineDisplayName, picture: linePictureUrl } = lineProfile;

                // 2. ?�找?�創建用??(Firestore & Auth)
                logger.info("Calling findOrCreateUser...");
                const { authUid, employeeData, employeeDocId, isNewUser } = await findOrCreateUser(lineUserId, lineDisplayName, linePictureUrl);
                userIdForLog = authUid; // Now we have the Firebase Auth UID
                userNameForLog = employeeData.name || lineDisplayName; // Use name from employee data if available
                logDetails.authUid = authUid;
                logDetails.employeeDocId = employeeDocId;
                logDetails.isNewUser = isNewUser;
                logger.info("findOrCreateUser completed.", { authUid, employeeDocId, isNewUser });

                // 3. 檢查?�戶?�??                if (!employeeData.isActive) {
                    logger.warn(`Login attempt by inactive user: ${authUid} (Employee: ${employeeDocId})`);
                    logDetails.error = 'Inactive user login attempt';
                    throw new Error('Inactive user'); // Trigger catch block for logging
                }

                // 4. ?��? Firebase ?��?�?Token
                logger.info(`Creating Firebase custom token for UID: ${authUid}`);
                const firebaseToken = await auth.createCustomToken(authUid);
                logger.info("Firebase custom token created successfully.");
                loginSuccess = true; // Mark login as successful before sending response

                // 5. 準�??�傳資�? (確�??�含 level ??store)
                const roles = {
                    level: employeeData.level ?? 0, // Default to 0 if missing
                    store: employeeData.store || null
                };

                // Optionally trigger a welcome notification for new users
                if (isNewUser) {
                    logger.info(`Sending welcome notification for new user ${authUid}`);
                    sendNotification('newUserWelcome',
                        { userName: lineDisplayName || '?�用?? },
                        { userId: authUid } // Send personal welcome
                    ).catch(e => logger.error("Failed to send welcome notification:", e));
                    logDetails.sentWelcomeNotification = true;
                }

                // 6. ?��??��? (Log before sending)
                logger.info("Sending successful login response back to client.");
                // Log successful login attempt
                await logActivity({
                    userId: userIdForLog,
                    userName: userNameForLog,
                    feature: 'Auth',
                    action: 'LoginSuccess',
                    details: logDetails,
                    success: true
                });
                return res.status(200).send({
                    success: true,
                    firebaseToken: firebaseToken,
                    userInfo: {
                        authUid: authUid,
                        employeeDocId: employeeDocId,
                        name: employeeData.name || lineDisplayName,
                        pictureUrl: employeeData.pictureUrl || linePictureUrl || null,
                        roles: roles, // Pass roles object
                        isNewUser: isNewUser,
                        phone: employeeData.phone || null // Include phone if available
                    }
                });

            } catch (error) {
                logger.error("Error processing handleLiffLogin request:", {
                    errorMessage: error.message,
                    // stack: error.stack,
                });

                // Log failed login attempt
                // Add error message to details
                logDetails.error = error.message;
                await logActivity({
                    userId: userIdForLog, // Might still be 'anonymous' if error happened early
                    userName: userNameForLog,
                    feature: 'Auth',
                    action: 'LoginFail',
                    details: logDetails,
                    success: false
                });

                // ?��??�誤類�?返�?不�???HTTP ?�?�碼
                let statusCode = 500;
                let errorCode = 'internal';
                let errorMessage = `?�入?��??�發?�未?��??�錯�? ${error.message}`;

                if (error.message === 'Method Not Allowed') {
                    statusCode = 405; errorCode = 'method-not-allowed'; errorMessage = 'Method Not Allowed';
                } else if (error.message === 'Request body missing idToken') {
                    statusCode = 400; errorCode = 'invalid-argument'; errorMessage = '請�?中缺�?LINE ID Token';
                } else if (error.message === 'Inactive user') {
                    statusCode = 403; errorCode = 'permission-denied'; errorMessage = '?��?帳�?已被?�用，�??�繫管�??��?;
                } else if (error.message.includes('LINE Token 驗�?失�?') || error.message.includes('??LINE 驗�?伺�??�通信失�?') || error.message.includes('Token audience')) {
                    statusCode = 401; errorCode = 'unauthenticated'; errorMessage = `LINE Token 驗�?失�??�無?? ${error.message}`;
                } else if (error.message.includes('?�戶資�??��??�誤') || error.message.includes('?�建?�用?��??��?失�?') || error.message.includes('?�聯?��?證到?��?記�??�出??) || error.message.includes('?��?完整?��??�建立用?��?�?)) {
                    statusCode = 500; errorCode = 'internal'; errorMessage = `伺�??��??�用?��??��??��??�誤: ${error.message}`;
                } else if (error instanceof HttpsError) {
                    statusCode = mapHttpsErrorCodeToHttpStatus(error.code); errorCode = error.code; errorMessage = error.message;
                }

                return res.status(statusCode).send({
                    success: false,
                    error: { code: errorCode, message: errorMessage }
                });
            }
        }); // <-- End of CORS middleware wrapper
    }
);

/**
 * ?��??�單?�觸?�通知
 */
exports.sendLeaveNotification = onDocumentCreated('leave_requests/{docId}', async (event) => {
    const leaveRequest = event.data.data();
    const docId = event.params.docId;
    if (!leaveRequest || !leaveRequest.userId) {
         logger.warn("Leave request created without data or userId", { docId });
         return;
    }

    try {
        const userDoc = await db.collection('users').doc(leaveRequest.userId).get();
        if (!userDoc.exists) {
            logger.warn(`User not found for leave request: ${leaveRequest.userId} (Doc: ${docId})`);
            return;
        }

        const userData = userDoc.data();
        const notificationData = {
            title: '?��??�申�?,
            userName: userData.name || '?�工',
            userId: leaveRequest.userId,
            startDate: formatTimestamp(leaveRequest.startDate, 'YYYY-MM-DD'),
            endDate: formatTimestamp(leaveRequest.endDate, 'YYYY-MM-DD'),
            reason: leaveRequest.reason || '?�說??,
            leaveDocId: docId,
            message: `${userData.name || '?�工'} ?��?了�? ${formatTimestamp(leaveRequest.startDate, 'YYYY-MM-DD')} ??${formatTimestamp(leaveRequest.endDate, 'YYYY-MM-DD')} ?��??�。\n?��?: ${leaveRequest.reason || '?�說??}`
        };

        // Send to global admin target
        await sendNotification('leave', notificationData, { isAdminTarget: true });
        logger.info(`Leave notification sent for doc ${docId}`);

    } catch (error) {
        logger.error(`Error in sendLeaveNotification for doc ${docId}: ${error.message}`, { error });
    }
});

/**
 * ?�人註�?完�?後觸?�通知 (??level > 0 ??
 */
exports.sendRegistrationCompleteNotification = onDocumentUpdated('users/{userId}', async (event) => {
    const beforeData = event.data.before.data();
    const afterData = event.data.after.data();
    const userId = event.params.userId;

    // 檢查?�否?��? level 0 變為 > 0
    if (beforeData && beforeData.level === 0 && afterData && afterData.level > 0) {
        logger.info(`User ${userId} registration approved (Level ${beforeData.level} -> ${afterData.level}). Sending notification.`);

        const notificationData = {
             title: '?�人註�?完�?',
             userName: afterData.name || '?�員�?,
             userId: userId,
             store: afterData.store || '?��???,
             approvedLevel: afterData.level,
             message: `?�員�?${afterData.name || '?�知'} (${afterData.store || '?��??��?�?}) ?�註?�已審核?��?，�?級設??${afterData.level}?�`
        };

        try {
            // ?�送全局?�知給管?�員
            await sendNotification('registerComplete', notificationData, { isAdminTarget: true });

            // ?��?也發?�個人?�知給該?�工
            await sendNotification('registrationApproved', {
                 title: '註�?審核?��?',
                 name: afterData.name || '?�工',
                 message: `?��?！您?�帳?�註?�已審核?��??�您?�在?�以使用系統?��??��??��??�`
            }, { userId: userId });

        } catch (error) {
             logger.error(`Error sending registration complete notification for user ${userId}: ${error.message}`, { error });
        }
    }
});

/**
 * ?�班變更?�觸?�通知
 * ??�� 'schedule_changes' ?��??�新?�件
 */
exports.sendScheduleChangeNotification = onDocumentCreated('schedule_changes/{docId}', async (event) => {
    const change = event.data.data();
    const docId = event.params.docId;
    if (!change || !change.userId || !change.date) {
         logger.warn("Schedule change created without required data", { docId });
         return;
    }

    try {
        const userDoc = await db.collection('users').doc(change.userId).get();
        if (!userDoc.exists) {
            logger.warn(`User not found for schedule change: ${change.userId} (Doc: ${docId})`);
            return;
        }

        const userData = userDoc.data();
        const notificationData = {
            title: '?�班變更?�知',
            userName: userData.name || '?�工',
            userId: change.userId,
            date: change.date, // Assuming date is stored as YYYY-MM-DD string
            oldShift: change.oldShift || '?��???,
            newShift: change.newShift || '?��??�班',
            store: userData.store || 'N/A',
            changer: change.changerName || '系統', // Who made the change
            note: change.note || '',
            message: `?��??��??�】\n?�工: ${userData.name || '?�知'} (${userData.store || 'N/A'})\n?��?: ${change.date}\n?�班?? ${change.oldShift || '?��???}\n?�班?? ${change.newShift || '?��??�班'}\n?��??? ${change.changerName || '系統'}\n${change.note ? '?�註: ' + change.note : ''}`
        };

        // ?�送個人?�知給相?�員�?        await sendNotification('scheduleChangePersonal', notificationData, { userId: change.userId });

        // ?��?設�?決�??�否?�送全局?�知 (?�能不�?要�??�者發給�??��?)
        // Example: sendNotification('scheduleChangeGlobal', notificationData, { skipPersonal: true });

        logger.info(`Schedule change notification sent for user ${change.userId} (Doc: ${docId})`);

    } catch (error) {
        logger.error(`Error in sendScheduleChangeNotification for doc ${docId}: ${error.message}`, { error });
    }
});

/**
 * ?�到?��??��?觸發?�知
 */
exports.sendOrderNotification = onDocumentCreated('orders/{docId}', async (event) => {
    const order = event.data.data();
    const docId = event.params.docId;
    if (!order || !order.userId || !order.store) {
         logger.warn("Order created without required data", { docId });
         return;
    }

     try {
        const userDoc = await db.collection('users').doc(order.userId).get();
        if (!userDoc.exists) {
            logger.warn(`User not found for order: ${order.userId} (Doc: ${docId})`);
            return;
        }
        const userData = userDoc.data();

        const orderItemsSummary = order.items?.map(item => `${item.name} x${item.quantity}`).join(', ') || '?��???;
        const totalAmount = order.totalAmount ? `總�?: ${order.totalAmount}` : '';

        const notificationData = {
             title: `?�叫貨單 (${order.store})`,
             store: order.store,
             orderUser: userData.name || order.userId,
             orderTime: formatTimestamp(order.timestamp),
             itemsSummary: orderItemsSummary,
             totalAmount: totalAmount,
             orderDocId: docId,
             message: `?�新?�貨?�】\n?��? ${order.store}\n填寫�? ${userData.name || order.userId}\n?��?: ${formatTimestamp(order.timestamp)}\n?��?: ${orderItemsSummary}\n${totalAmount}\n${order.notes ? '?�註: ' + order.notes : ''}`
        };

        // ?�送全局?�知 (?�能給�??��??�管?�員)
        await sendNotification('newOrder', notificationData, { isAdminTarget: true }); // Example: send to admin target

        logger.info(`New order notification sent for doc ${docId}`);

    } catch (error) {
        logger.error(`Error in sendOrderNotification for doc ${docId}: ${error.message}`, { error });
    }
});
// TODO: Implement updateProductSoldCount function
// This function should trigger on order creation (or completion)
// and update the sold count for each product item in the order.
// Example trigger: onDocumentCreated('orders/{docId}') or onDocumentUpdated if checking status.
// It needs to read order items and update corresponding documents in the 'products' collection.
/**
 * 定�?檢查?��??�員工並?�送�??? * Runs every weekday (Monday to Friday) at 9:00 AM Asia/Taipei.
 */
exports.checkMissedClockIn = onSchedule({
    schedule: '0 9 * * 1-5', // ?��??�週�?上�?9�?    timeZone: 'Asia/Taipei',
    // secrets: [LINE_OA_TOKEN_PARAM, TELEGRAM_BOT_TOKEN_PARAM] // Secrets needed by sendNotification
}, async (event) => {
    logger.info("Running scheduled job: checkMissedClockIn");
    const systemLogDetails = { executionTime: event.timestamp };
    let successCount = 0;
    let failureCount = 0;

    try {
        // 1. ?��?今天?�班�?(?�設?�表存儲??'schedules' ?��?，�?檔ID??'YYYY-MM-DD')
        const scheduleDoc = await db.collection('schedules').doc(new Date().toISOString().split('T')[0]).get();
        if (!scheduleDoc.exists) {
            logger.info(`No schedule found for today (${new Date().toISOString().split('T')[0]}). Skipping clock-in check.`);
            return;
        }
        const scheduleData = scheduleDoc.data();
        const scheduledEmployees = scheduleData.shifts || {}; // Assuming shifts is an object { userId: shiftInfo, ... }

        // 2. ?��?今天已�??��??�工
        const clockInSnapshot = await db.collection('clockin_records')
            .where('date', '==', new Date().toISOString().split('T')[0])
            .get();
        const clockedInUserIds = new Set(clockInSnapshot.docs.map(doc => doc.data().userId));

        // 3. ?�出今天?�班但未?�卡?�員�?        const missedClockInUserIds = [];
        for (const userId in scheduledEmployees) {
            // 檢查?�否?�班 (shiftInfo 不為 null ?�空) �??��???            if (scheduledEmployees[userId] && !clockedInUserIds.has(userId)) {
                missedClockInUserIds.push(userId);
            }
        }

        if (missedClockInUserIds.length === 0) {
            logger.info("All scheduled employees have clocked in today.");
            return;
        }

        logger.info(`Found ${missedClockInUserIds.length} employees who missed clock-in today:`, missedClockInUserIds);

        // 4. ?�送�??�通知
        for (const userId of missedClockInUserIds) {
            try {
                const userDoc = await db.collection('users').doc(userId).get();
                if (userDoc.exists) {
                    const userData = userDoc.data();
                    const notificationData = {
                        title: '?�卡?��?',
                        name: userData.name || '?�工',
                        date: new Date().toISOString().split('T')[0],
                        message: `?��??��?今天??${new Date().toISOString().split('T')[0]}，您尚未完�??�卡?��??�快?�卡！`
                    };
                    // ?�送個人?�知
                    await sendNotification('clockinReminder', notificationData, { userId: userId });
                } else {
                    logger.warn(`User ${userId} found in schedule but user document does not exist.`);
                }
            } catch (userError) {
                logger.error(`Error processing or notifying user ${userId} for missed clock-in: ${userError.message}`);
            }
        }

        logger.info("Finished sending clock-in reminders.");
        successCount = 1; // Replace with actual count if iterating
        systemLogDetails.result = "Check completed (example: found X missed clock-ins)";
        await logActivity({ userId: 'system', feature: 'ScheduledTask', action: 'RunCheckMissedClockIn', details: systemLogDetails, success: true });
        logger.info("checkMissedClockIn finished successfully.");

    } catch (error) {
        logger.error("Error during checkMissedClockIn execution:", error);
        failureCount = 1;
        systemLogDetails.error = error.message;
        await logActivity({ userId: 'system', feature: 'ScheduledTask', action: 'RunCheckMissedClockIn', details: systemLogDetails, success: false });
    }
});

// TODO: Add other scheduled tasks like generating salary reports, etc.
// TODO: Add Backup Scheduled Task (`scheduledFirestoreBackup` from previous response)

// --- Other potential triggers or functions ---

// Example: Function to handle leave request approval/rejection and notify user
exports.handleLeaveStatusChange = onDocumentUpdated('leave_requests/{docId}', async (event) => {
    const beforeData = event.data.before.data();
    const afterData = event.data.after.data();
    const docId = event.params.docId;
    const userId = afterData.userId;

    // Check if status changed and the user ID exists
    if (!userId || beforeData.status === afterData.status || !afterData.status) {
        return; // No status change or missing data
    }

    logger.info(`Leave request ${docId} status changed from ${beforeData.status} to ${afterData.status} for user ${userId}`);

    try {
        const userDoc = await db.collection('users').doc(userId).get();
        if (!userDoc.exists) {
             logger.warn(`User ${userId} not found for leave status notification.`);
             return;
        }
        const userData = userDoc.data();

        let notificationType = '';
        let notificationData = {
             title: '請�??��??�?�更??,
             name: userData.name || '?�工',
             startDate: formatTimestamp(afterData.startDate, 'YYYY-MM-DD'),
             endDate: formatTimestamp(afterData.endDate, 'YYYY-MM-DD'),
             status: afterData.status === 'approved' ? '已批?? : (afterData.status === 'rejected' ? '已�?�? : afterData.status),
             reason: afterData.rejectionReason || '', // Include rejection reason if available
             message: `?��?請�??��? (�?${formatTimestamp(afterData.startDate, 'YYYY-MM-DD')} ??${formatTimestamp(afterData.endDate, 'YYYY-MM-DD')}) `
        };

        if (afterData.status === 'approved') {
            notificationType = 'leaveApproved';
            notificationData.message += `已被?��??�`;
        } else if (afterData.status === 'rejected') {
            notificationType = 'leaveRejected';
            notificationData.message += `已被?��??�`;
            if(afterData.rejectionReason) {
                 notificationData.message += `\n?��??��?: ${afterData.rejectionReason}`;
            }
        } else {
            // Handle other statuses if needed
            return;
        }

        // Send personal notification to the employee
        await sendNotification(notificationType, notificationData, { userId: userId });

    } catch (error) {
        logger.error(`Error sending leave status change notification for doc ${docId}: ${error.message}`, { error });
    }
});

// Cloud Function: Get current scheduling system status
// MODIFIED: Use v2 syntax
exports.getScheduleSystemStatus = onCall({ region: 'asia-east1' }, async (request) => { 
    if (!request.auth) { // Use request.auth
        // ... (unauthenticated error) ...
        throw new HttpsError('unauthenticated', '?�要用?��?證�??�獲?��??��??��?); // Use imported HttpsError
    }
    const uid = request.auth.uid; // Use request.auth.uid
    
    // --- Use correct collection paths ---
    const configRef = db.collection('settings').doc('schedule_config');
    const userRef = db.collection('users').doc(uid);
    // --- End correct collection paths ---

    try {
        // Read config and user data
        let [configDoc, userDoc] = await Promise.all([
            configRef.get(),
            userRef.get()
        ]);

        if (!configDoc.exists) {
            // Log error?
            throw new HttpsError('not-found', 'Schedule configuration not found.'); // Use imported HttpsError
        }
        if (!userDoc.exists) {
            // Log error?
            throw new HttpsError('not-found', 'User data not found.'); // Use imported HttpsError
        }

        let configData = configDoc.data();
        const userData = userDoc.data();
        const now = new Date();
        const nowTimestamp = admin.firestore.Timestamp.now();

        // Initialize variables based on configData
        let currentStatus = configData.systemStatus || 'DISABLED';
        let isLocked = configData.isLocked || false;
        let lockedBy = configData.lockedBy || null;
        let lockExpiresAt = configData.lockExpiresAt || null;
        let remainingSeconds = null;

        // --- ADDED: Check for Force Open Expiration ---
        if (configData.forceOpenUntil && configData.forceOpenUntil instanceof admin.firestore.Timestamp) {
            if (nowTimestamp.toMillis() > configData.forceOpenUntil.toMillis()) {
                // MODIFIED: console.log -> logger.info
                logger.info(`Force open period expired at ${configData.forceOpenUntil.toDate().toISOString()}. Reverting status.`);
                try {
                    await configRef.update({
                        systemStatus: 'CLOSED',
                        forceOpenUntil: admin.firestore.FieldValue.delete(),
                        lastForcedOpenBy: admin.firestore.FieldValue.delete(),
                        lastForcedOpenAt: admin.firestore.FieldValue.delete()
                    });
                    // MODIFIED: console.log -> logger.info
                    logger.info("System status reverted to CLOSED after force open expiration.");
                    configDoc = await configRef.get(); // Re-fetch needed
                    configData = configDoc.data();
                    currentStatus = configData.systemStatus || 'CLOSED';
                } catch (revertError) {
                    // MODIFIED: console.error -> logger.error
                    logger.error("Error reverting status after force open expiration:", revertError);
                    currentStatus = 'CLOSED';
                }
            } else {
                 // MODIFIED: console.log -> logger.info
                logger.info(`System is force-opened until ${configData.forceOpenUntil.toDate().toISOString()}.`);
                currentStatus = 'IDLE'; // Override status
            }
        }
        // --- End Force Open Check ---

        // --- Normal Status Check (Only if not forced open) ---
        if (currentStatus !== 'IDLE' && currentStatus !== 'IN_USE' && !(configData.forceOpenUntil && nowTimestamp.toMillis() <= configData.forceOpenUntil.toMillis())) {
             if (currentStatus === 'ENABLED' || currentStatus === 'CLOSED') { 
                 const openTimeStr = configData.openTime;
                 const closeTimeStr = configData.closeTime;
                 if (openTimeStr && closeTimeStr) {
                     const [openH, openM] = openTimeStr.split(':').map(Number);
                     const [closeH, closeM] = closeTimeStr.split(':').map(Number);
                     const openDate = new Date(now); openDate.setHours(openH, openM, 0, 0);
                     const closeDate = new Date(now); closeDate.setHours(closeH, closeM, 0, 0);
                     if (closeDate <= openDate) closeDate.setDate(closeDate.getDate() + 1);
                     currentStatus = (now >= openDate && now < closeDate) ? 'IDLE' : 'CLOSED';
                 } else {
                     currentStatus = 'CLOSED';
                 }
             }
        }
        // --- End Normal Status Check ---

        // --- Check Lock Status (using configRef) ---
        if (isLocked && lockExpiresAt && lockExpiresAt.toMillis() < nowTimestamp.toMillis()) {
            // MODIFIED: console.log -> logger.info
            logger.info("Lock expired. Releasing automatically.");
            try {
                await configRef.update({
                    isLocked: false,
                    lockedBy: null,
                    lockExpiresAt: null
                });
                isLocked = false;
                lockedBy = null;
                lockExpiresAt = null;
                // MODIFIED: console.log -> logger.info
                logger.info("Expired lock released.");
                 if (currentStatus === 'IN_USE') {
                     // Re-evaluate status after lock release
                     if (configData.forceOpenUntil && nowTimestamp.toMillis() <= configData.forceOpenUntil.toMillis()) {
                         currentStatus = 'IDLE';
                     } else {
                         // Re-run time check logic
                         const openTimeStr = configData.openTime; 
                         const closeTimeStr = configData.closeTime;
                         if (openTimeStr && closeTimeStr) {
                            const [openH, openM] = openTimeStr.split(':').map(Number);
                            const [closeH, closeM] = closeTimeStr.split(':').map(Number);
                            const openDate = new Date(now); openDate.setHours(openH, openM, 0, 0);
                            const closeDate = new Date(now); closeDate.setHours(closeH, closeM, 0, 0);
                            if (closeDate <= openDate) closeDate.setDate(closeDate.getDate() + 1);
                            currentStatus = (now >= openDate && now < closeDate) ? 'IDLE' : 'CLOSED';
                         } else {
                             currentStatus = 'CLOSED';
                         }
                     }
                     // MODIFIED: console.log -> logger.info
                     logger.info("System status updated after lock expiry:", currentStatus);
                 }
            } catch (releaseError) {
                // MODIFIED: console.error -> logger.error
                logger.error("Error releasing expired lock:", releaseError);
            }
        }

        // Update status to IN_USE if still locked 
        if (isLocked) {
            currentStatus = 'IN_USE';
            if (lockExpiresAt) {
                 remainingSeconds = Math.max(0, Math.floor((lockExpiresAt.toMillis() - nowTimestamp.toMillis()) / 1000));
            }
        }
        // --- End Lock Status Check ---

        // Get Forbidden/Holiday Dates
        // Assuming helper functions exist later in the file
        const forbiddenDates = getForbiddenDates(configData, userData); 
        const holidayDates = getHolidayDates(configData);

        // Return final result
        return {
            systemStatus: currentStatus,
            isLocked: isLocked,
            lockedBy: isLocked ? { id: lockedBy.id, name: lockedBy.name } : null,
            lockExpiresAt: lockExpiresAt ? lockExpiresAt.toDate().toISOString() : null,
            remainingSeconds: remainingSeconds,
            forbiddenDates: forbiddenDates, 
            holidayDates: holidayDates 
        };

    } catch (error) {
        // MODIFIED: console.error -> logger.error
        logger.error("Error in getScheduleSystemStatus:", error);
        // Log error?
        if (error instanceof HttpsError) { // Check imported HttpsError
            throw error; 
        }
        throw new HttpsError('internal', 'Failed to get schedule system status.', error.message); // Use imported HttpsError
    }
});

/**
 * Cloud Function: ?�試?�當?�用?��?定�??�系�? * ...
 */
// MODIFIED: Use v2 syntax
exports.requestScheduleLock = onCall({ region: 'asia-east1' }, async (request) => {
    if (!request.auth) { // Use request.auth
        await logActivity('System', 'requestScheduleLock', 'Unauthorized', 'Error', { message: 'User not authenticated.' });
        throw new HttpsError('unauthenticated', '?�要用?��?證�??��?求�?定�??�系統�?); // Use imported HttpsError
    }
    const uid = request.auth.uid; // Use request.auth.uid
    const now = new Date(); // Current server time
    const serverTimestamp = admin.firestore.FieldValue.serverTimestamp(); // For setting timestamps
    // ... rest of the logic remains largely the same, use request.auth.uid ...
    // ... (inside the function logic where uid or employeeName is needed) ...
    // MODIFIED: Removed declaration of settingsRef, statusRef, employeeRef as they seem unused here (mistake?)
    // Re-adding declarations as they ARE used.
    const configRef = db.collection('system_config').doc('schedule_config'); // Assuming system_config is correct
    const userRef = db.collection('users').doc(uid); // Assuming users collection holds employee data


     try {
            // 1. 讀?�設定�??�工資�?
            // MODIFIED: Fetch config and user data, not settings/status/employee
            const [configSnap, userSnap] = await Promise.all([
                configRef.get(),
                userRef.get() // Use userRef from declaration
            ]);

            if (!configSnap.exists) {
                 await logActivity(uid, 'requestScheduleLock', 'System', 'Failure', { reason: 'Config not found' });
                throw new HttpsError('failed-precondition', '?��??��??�系統設定�??��?請�??��???); // Use imported HttpsError
            }
            if (!userSnap.exists) { // Check userSnap
                 await logActivity(uid, 'requestScheduleLock', 'System', 'Failure', { reason: 'User not found' }); // Log User not found
                throw new HttpsError('not-found', '?��??�您?�用?��??��??��?請�??��???); // Use imported HttpsError, clarify user data
            }

            const config = configSnap.data();
            const userData = userSnap.data(); // Use userData
            const employeeName = userData.name || uid; // Use name from userData

            // 2. 檢查系統?�??(�?config 讀??
             const systemStatus = config.systemStatus || 'DISABLED';
             const isLocked = config.isLocked || false;
             const lockedBy = config.lockedBy || null;
             const lockExpiresAt = config.lockExpiresAt || null; // Firestore Timestamp
             const forceOpenUntil = config.forceOpenUntil || null; // Firestore Timestamp
             const nowTimestamp = admin.firestore.Timestamp.now();

             let effectiveStatus = systemStatus;
             let isForceOpenActive = false;

             // Check Force Open
             if (forceOpenUntil && nowTimestamp.toMillis() <= forceOpenUntil.toMillis()) {
                 effectiveStatus = 'IDLE'; // Force open overrides normal status
                 isForceOpenActive = true;
                 // MODIFIED: console.log -> logger.info
                 logger.info("Request lock: System is force-opened.");
             } else if (forceOpenUntil) {
                 // Force open expired, should have been reverted by getStatus, but double-check
                 // MODIFIED: console.warn -> logger.warn
                 logger.warn("Request lock: Found expired forceOpenUntil, system should be CLOSED/DISABLED.");
                 // Assume it should be CLOSED if not explicitly ENABLED
                 effectiveStatus = (systemStatus === 'ENABLED') ? 'CLOSED' : systemStatus; // Revert logic might be complex
             }

             // Check normal window if not forced open
             if (!isForceOpenActive && (effectiveStatus === 'ENABLED' || effectiveStatus === 'CLOSED')) {
                 const openTimeStr = config.openTime;
                 const closeTimeStr = config.closeTime;
                 if (openTimeStr && closeTimeStr) {
                     const [openH, openM] = openTimeStr.split(':').map(Number);
                     const [closeH, closeM] = closeTimeStr.split(':').map(Number);
                     const openDate = new Date(now); openDate.setHours(openH, openM, 0, 0);
                     const closeDate = new Date(now); closeDate.setHours(closeH, closeM, 0, 0);
                     if (closeDate <= openDate) closeDate.setDate(closeDate.getDate() + 1);
                     effectiveStatus = (now >= openDate && now < closeDate) ? 'IDLE' : 'CLOSED';
                 } else {
                     effectiveStatus = 'CLOSED'; // Default to closed if window times missing
                 }
             }

             // Check if lock expired
             if (isLocked && lockExpiresAt && lockExpiresAt.toMillis() < nowTimestamp.toMillis()) {
                 // MODIFIED: console.warn -> logger.warn
                 logger.warn(`Found expired lock during request by ${uid}. System should be IDLE/CLOSED now.`);
                 // Assume status is IDLE/CLOSED based on time window check above
                 // The lock should be released automatically by getStatus, but we proceed assuming it's available
             } else if (isLocked) {
                 // Still locked by someone
                 effectiveStatus = 'IN_USE';
             }


            // 3. 檢查?�終�??�是?��?許�?�?            if (effectiveStatus !== 'IDLE') {
                let reason = 'closed';
                let message = '?��??��??�系統�??��??��?系統不可?��?;
                if (effectiveStatus === 'IN_USE' && lockedBy?.id !== uid) {
                    reason = 'locked';
                    message = `系統?��?�?�� ${lockedBy?.name || '?��?使用??} 使用中�?請�?後�?試。`;
                     await logActivity(employeeName, 'requestScheduleLock', 'System', 'Failure', { reason: 'Already locked', lockedBy: lockedBy?.name || lockedBy?.id });
                } else if (effectiveStatus === 'DISABLED') {
                     reason = 'disabled';
                     message = '?�班系統?��?已�??��?;
                     await logActivity(employeeName, 'requestScheduleLock', 'System', 'Failure', { reason: 'System disabled' });
                } else if (effectiveStatus === 'CLOSED') {
                     await logActivity(employeeName, 'requestScheduleLock', 'System', 'Failure', { reason: 'Outside window' });
                }
                return { success: false, reason: reason, message: message };
            }


            // 4. ?�試使用事�??��? (?�新 config ?�件)
            let lockAcquired = false;
            let finalLockExpiresAt = null;

            await db.runTransaction(async (transaction) => { // Use db.runTransaction
                const freshConfigSnap = await transaction.get(configRef);
                if (!freshConfigSnap.exists) {
                     throw new HttpsError('failed-precondition', '讀?�設定失??(事�?�?'); // Use imported HttpsError
                }
                const freshConfigData = freshConfigSnap.data();
                const freshIsLocked = freshConfigData.isLocked || false;
                const freshLockExpiresAt = freshConfigData.lockExpiresAt || null;

                // Re-check lock status within transaction
                if (freshIsLocked && freshLockExpiresAt && freshLockExpiresAt.toMillis() >= nowTimestamp.toMillis()) {
                    // Locked by someone else within transaction
                    lockAcquired = false;
                } else {
                    // Available to lock
                    const sessionDurationMillis = (config.lockDurationSeconds || 300) * 1000; // Use config.lockDurationSeconds
                    const newExpiresAtDate = new Date(now.getTime() + sessionDurationMillis);
                    finalLockExpiresAt = newExpiresAtDate; // Store for return value

                    const lockPayload = {
                        isLocked: true,
                        lockedBy: { id: uid, name: employeeName }, // Store ID and name
                        lockAcquiredAt: serverTimestamp, // Use server timestamp
                        lockExpiresAt: admin.firestore.Timestamp.fromDate(newExpiresAtDate) // Convert JS Date to Firestore Timestamp
                    };
                    transaction.update(configRef, lockPayload);
                    lockAcquired = true;
                }
            });

            // 5. ?��?事�?結�?返�?
            if (lockAcquired && finalLockExpiresAt) {
                 await logActivity(employeeName, 'requestScheduleLock', 'System', 'Success', { expiresAt: finalLockExpiresAt.toISOString() });
                return {
                    success: true,
                    lockExpiresAt: finalLockExpiresAt.toISOString() // 返�? ISO ?��??��??�給?�端
                };
            } else {
                // ?��?失�? (已被他人?��? - ?��??�中被搶??
                 const lockedByOtherName = (await configRef.get()).data()?.lockedBy?.name || '?��?使用??; // Read again to get current holder name
                 await logActivity(employeeName, 'requestScheduleLock', 'System', 'Failure', { reason: 'Locked during transaction', lockedBy: lockedByOtherName });
                return {
                    success: false,
                    reason: 'locked',
                    message: `系統�?�� ${lockedByOtherName} 使用中�?請�?後�?試。` // Update message
                };
            }

     } catch (error) {
         // MODIFIED: console.error -> logger.error
         logger.error(`Error in requestScheduleLock for user ${uid}:`, error);
          await logActivity(uid, 'requestScheduleLock', 'System', 'Error', { message: error.message, code: error.code });
         if (error instanceof HttpsError) { // Check imported HttpsError
             throw error; // ?��? HttpsError
         } else {
             // Handle potential transaction errors more gracefully if needed
             throw new HttpsError('internal', '請�??��??�班系統?�發?�內?�錯誤�?); // Use imported HttpsError
         }
     }
});

/**
 * Cloud Function: ?�放?��??�戶?��??��??�系統�?�? * ...
 */
// MODIFIED: Use v2 syntax
exports.releaseScheduleLock = onCall({ region: 'asia-east1' }, async (request) => {
    if (!request.auth) { // Use request.auth
        await logActivity('System', 'releaseScheduleLock', 'Unauthorized', 'Error', { message: 'User not authenticated.' });
        throw new HttpsError('unauthenticated', '?�要用?��?證�??��??��??��?定�?); // Use imported HttpsError
    }
    const uid = request.auth.uid; // Use request.auth.uid
    // ... rest of the logic remains largely the same, use request.auth.uid ...
    const userRef = db.collection('users').doc(uid); // Assuming users collection holds employee data
    const configRef = db.collection('system_config').doc('schedule_config'); // Update config doc

    try {
            const userSnap = await userRef.get();
            const employeeName = userSnap.exists ? (userSnap.data().name || uid) : uid;

            // 使用事�?確�?讀?��?寫入?��?子�?            let released = false;
            let message = '';
            let currentHolder = null; // For logging if release failed due to wrong holder

            await db.runTransaction(async (transaction) => { // Use db.runTransaction
                const configSnap = await transaction.get(configRef); // Read config doc

                if (!configSnap.exists) {
                    // ?�?��?件�?存在，無?�?�放，�??�警??                    // MODIFIED: console.warn -> logger.warn
                    logger.warn(`releaseScheduleLock called by ${uid}, but config document doesn't exist.`);
                    message = '系統設�??�常，無?�?�放??;
                    released = false; // Consider this not a successful release in the normal sense
                    return; // Exit transaction
                }

                const currentConfigData = configSnap.data();
                currentHolder = currentConfigData.lockedBy?.name; // Store for potential logging

                if (!currentConfigData.isLocked) { // Check isLocked flag
                    // 系統不是 IN_USE ?�?��??��??�放
                    message = '系統?��?並�??��??�?��?;
                    released = false;
                } else if (currentConfigData.lockedBy?.id !== uid) { // Check lockedBy.id
                    // ?��??�由?��??�戶?��?
                    message = '?�並?��??��??�系統�?定�??��??�放??;
                    released = false;
                    // Log will happen outside transaction based on flag
                } else {
                    // 確�??�當?�用?��??��? -> ?�放
                    const releasePayload = {
                        isLocked: false,
                        lockedBy: null,
                        lockAcquiredAt: null,
                        lockExpiresAt: null,
                        // Optionally keep lastStatusChangeReason or update it
                        // lastStatusChangeReason: `Released by user ${uid}`
                    };
                    transaction.update(configRef, releasePayload);
                    released = true;
                    message = '?�班?��?已�??��??��?;
                }
            });

            // 記�??��? (事�??��?�?
            if (released) {
                await logActivity(employeeName, 'releaseScheduleLock', 'System', 'Success', { message });
            } else {
                 // Log failure if it was due to not holding the lock
                 if (message === '?�並?��??��??�系統�?定�??��??�放??) {
                     await logActivity(employeeName, 'releaseScheduleLock', 'System', 'Failure', { reason: 'Not lock holder', currentHolder: currentHolder || 'Unknown' });
                 } else if(message) { // Log other info messages
                     await logActivity(employeeName, 'releaseScheduleLock', 'System', 'Info', { message });
                 }
            }

            return { success: released, message: message };

    } catch (error) {
        // Get name using request.auth.token if available in v2
        const actorName = request.auth?.token?.name || uid; // Use request.auth.token.name
        // MODIFIED: console.error -> logger.error
        logger.error(`Error in releaseScheduleLock for user ${uid}:`, error);
        await logActivity(actorName, 'releaseScheduleLock', 'System', 'Error', { message: error.message, code: error.code });
        if (error instanceof HttpsError) { // Check imported HttpsError
            throw error; // ?��? HttpsError
        } else {
            throw new HttpsError('internal', '?�放?�班?��??�發?�內?�錯誤�?); // Use imported HttpsError
        }
    }
});

// --- ADD isAdmin HELPER AND forceOpenScheduling FUNCTION --- 

// --- Helper: Check Admin Role (Example) ---
// MODIFIED: Adapt isAdmin to work with v2 request object
async function isAdmin(request) { 
    if (!request.auth) {
        // Log for debugging server-side check failure
        logger.error('isAdmin check failed: Unauthenticated.');
        throw new HttpsError('unauthenticated', 'The function must be called while authenticated.'); // Use imported HttpsError
    }
    const uid = request.auth.uid;
    try {
        const userDoc = await db.collection('users').doc(uid).get(); // db is assumed to be initialized globally
        if (!userDoc.exists || (userDoc.data().level ?? 0) < 9) { // Assuming level 9+ is admin, handle missing level
             logger.warn(`isAdmin check failed for user ${uid}: Level is ${userDoc.data()?.level ?? 'missing/undefined'} (Exists: ${userDoc.exists})`);
            throw new HttpsError('permission-denied', 'User does not have admin privileges.'); // Use imported HttpsError
        }
        logger.info(`isAdmin check passed for user ${uid} (Level: ${userDoc.data().level})`);
        return true; // Return true if admin
    } catch (error) {
         logger.error(`Error during isAdmin check for user ${uid}:`, error);
         // Re-throw permission denied if it was that, otherwise throw internal error
         if (error instanceof HttpsError && error.code === 'permission-denied') {
             throw error;
         }
         throw new HttpsError('internal', 'Error checking admin privileges.', error.message); // Use imported HttpsError
    }
}


// --- NEW: Cloud Function to Force Open Scheduling (v2 syntax) ---
// MODIFIED: Use v2 syntax
exports.forceOpenScheduling = onCall({ region: 'asia-east1' }, async (request) => {
    await isAdmin(request); // Ensure caller is admin using the adapted helper

    const configRef = db.collection('system_config').doc('schedule_config'); // Use system_config collection
    const now = admin.firestore.Timestamp.now();
    const thirtyMinutesInMillis = 30 * 60 * 1000;
    const forceOpenUntil = admin.firestore.Timestamp.fromMillis(now.toMillis() + thirtyMinutesInMillis);

    try {
        await configRef.update({
            systemStatus: 'IDLE', // Force to IDLE
            forceOpenUntil: forceOpenUntil,
            lastForcedOpenBy: request.auth.uid, // Use request.auth.uid
            lastForcedOpenAt: now         // Optional: Log when it was forced
        });
        // MODIFIED: console.log -> logger.info
        logger.info(`Scheduling system forced open until ${forceOpenUntil.toDate().toISOString()} by ${request.auth.uid}`);
        // Log activity (optional)
        await logActivity(request.auth.uid, 'forceOpenScheduling', 'Admin Action', 'Success', { until: forceOpenUntil.toDate().toISOString() });
        return { success: true };
    } catch (error) {
        // MODIFIED: console.error -> logger.error
        logger.error("Error forcing schedule open:", error);
        // Log activity (optional)
        await logActivity(request.auth.uid, 'forceOpenScheduling', 'Admin Action', 'Error', { message: error.message });
        throw new HttpsError('internal', 'Failed to update schedule config.', error.message); // Use imported HttpsError
    }
});

/**
 * Cloud Function: Review Leave Request
 * Handles approval or rejection of leave requests by administrators
 * Requires level 9+ permission (admin)
 * 
 * @param {Object} request.data
 * @param {string} request.data.requestId - ID of the leave request document
 * @param {boolean} request.data.approved - Whether the request is approved or rejected
 * @param {string} [request.data.reason] - Optional reason for rejection
 */
exports.reviewLeaveRequest = onCall({ region: 'asia-east1' }, async (request) => {
    // 1. Authentication check
    if (!request.auth) {
        logger.error("reviewLeaveRequest: Unauthenticated call.");
        throw new HttpsError('unauthenticated', '?�要�?證身�?);
    }

    // 2. Permission check - require level 9+ (admin)
    const requiredLevel = 9;
    let adminName = null;
    
    try {
        const adminDoc = await db.collection('users').doc(request.auth.uid).get();
        if (!adminDoc.exists) {
            logger.error(`reviewLeaveRequest: Admin user ${request.auth.uid} not found in database.`);
            throw new HttpsError('permission-denied', '?��??�管?�員資�?');
        }
        
        const adminData = adminDoc.data();
        const userLevel = adminData.level ?? 0;
        adminName = adminData.name || request.auth.uid;
        
        if (userLevel < requiredLevel) {
            logger.error(`reviewLeaveRequest: Permission denied for UID ${request.auth.uid}. Required: ${requiredLevel}, User has: ${userLevel}.`);
            throw new HttpsError('permission-denied', `權�?不足 (?�要�?�?${requiredLevel})`);
        }
        
        logger.info(`reviewLeaveRequest: Called by admin ${adminName} (${request.auth.uid}). Data:`, request.data);
    } catch (error) {
        if (error instanceof HttpsError) {
            throw error; // Re-throw HTTP errors
        }
        logger.error("reviewLeaveRequest: Error checking admin permissions:", error);
        throw new HttpsError('internal', '驗�?管�??��??��??��??�誤');
    }

    // 3. Request validation
    const { requestId, approved, reason } = request.data;
    
    if (!requestId) {
        logger.error("reviewLeaveRequest: Missing requestId parameter", request.data);
        throw new HttpsError('invalid-argument', '請�??�ID?��?填�?');
    }
    
    if (typeof approved !== 'boolean') {
        logger.error("reviewLeaveRequest: Invalid 'approved' parameter, must be boolean", request.data);
        throw new HttpsError('invalid-argument', '請�??�審?��??��??�為布�???);
    }

    // 4. Process the leave request
    try {
        const leaveRequestRef = db.collection('leave_requests').doc(requestId);
        const leaveRequestDoc = await leaveRequestRef.get();
        
        if (!leaveRequestDoc.exists) {
            logger.error(`reviewLeaveRequest: Leave request ${requestId} not found`);
            throw new HttpsError('not-found', '?��??��?定�?請�???);
        }
        
        const leaveData = leaveRequestDoc.data();
        
        // Check if request is already processed
        if (leaveData.status === 'approved' || leaveData.status === 'rejected') {
            logger.warn(`reviewLeaveRequest: Leave request ${requestId} already processed (${leaveData.status})`);
            throw new HttpsError('failed-precondition', `此�??�單已被${leaveData.status === 'approved' ? '?��?' : '?��?'}`);
        }
        
        // Update the leave request status
        const updateData = {
            status: approved ? 'approved' : 'rejected',
            reviewedBy: request.auth.uid,
            reviewedByName: adminName,
            reviewTimestamp: admin.firestore.FieldValue.serverTimestamp()
        };
        
        // Add rejection reason if provided and request is rejected
        if (!approved && reason) {
            updateData.rejectionReason = reason;
        }
        
        await leaveRequestRef.update(updateData);
        logger.info(`reviewLeaveRequest: Successfully reviewed request ${requestId}. Approved: ${approved}`);
        
        // 5. Send notification to the employee
        try {
            const userId = leaveData.userId;
            if (!userId) {
                throw new Error("Missing userId in leave request");
            }
            
            const userDoc = await db.collection('users').doc(userId).get();
            if (!userDoc.exists) {
                throw new Error(`User ${userId} not found`);
            }
            
            const userData = userDoc.data();
            
            const notificationData = {
                title: approved ? '請�?已批?? : '請�?被�?�?,
                userName: userData.name || '?�工',
                startDate: formatTimestamp(leaveData.startDate, 'YYYY-MM-DD'),
                endDate: formatTimestamp(leaveData.endDate, 'YYYY-MM-DD'),
                reason: approved ? '' : (reason || '?��?供�???),
                message: `?��?請�??��? (${formatTimestamp(leaveData.startDate, 'YYYY-MM-DD')} ??${formatTimestamp(leaveData.endDate, 'YYYY-MM-DD')}) ${approved ? '已被?��?' : '已被?��?'}`
                + (approved ? '' : `\n?��??��?: ${reason || '?��?�?}`)
            };
            
            await sendNotification(
                approved ? 'leaveApproved' : 'leaveRejected',
                notificationData,
                { userId: userId }
            );
            
            logger.info(`reviewLeaveRequest: Notification sent to user ${userId} for request ${requestId}`);
        } catch (notifyError) {
            // Non-critical error - log but don't fail the function
            logger.error(`reviewLeaveRequest: Error sending notification for request ${requestId}:`, notifyError);
        }
        
        // 6. Log the activity
        await logActivity({
            userId: request.auth.uid,
            userName: adminName,
            feature: 'LeaveAdmin',
            action: approved ? 'ApproveLeave' : 'RejectLeave',
            details: {
                leaveRequestId: requestId,
                employeeId: leaveData.userId,
                startDate: formatTimestamp(leaveData.startDate, 'YYYY-MM-DD'),
                endDate: formatTimestamp(leaveData.endDate, 'YYYY-MM-DD'),
                reason: approved ? '' : (reason || '?��?供�???)
            },
            success: true
        });
        
        return { 
            success: true, 
            message: approved ? '請�??��?已批?? : '請�??��?已�?�? 
        };
        
    } catch (error) {
        logger.error(`reviewLeaveRequest: Error processing request ${requestId}:`, error);
        
        // Log the failed activity
        try {
            await logActivity({
                userId: request.auth.uid,
                userName: adminName,
                feature: 'LeaveAdmin',
                action: approved ? 'ApproveLeave' : 'RejectLeave',
                details: {
                    leaveRequestId: requestId,
                    error: error.message
                },
                success: false
            });
        } catch (logError) {
            logger.error("Failed to log activity for failed leave review:", logError);
        }
        
        if (error instanceof HttpsError) {
            throw error;
        }
        throw new HttpsError('internal', '?��?請�??��??��??�誤', error.message);
    }
});

// Ensure helper functions getForbiddenDates and getHolidayDates are defined below
function getForbiddenDates(configData, userData) {
    // ... (implementation)
     let forbidden = configData.forbiddenDates || [];
    const storeForbidden = configData.storeForbiddenDates?.[userData.store] || [];
    return [...new Set([...forbidden, ...storeForbidden])]; 
}

function getHolidayDates(configData) {
    // ... (implementation)
     return configData.holidayDates || [];
}

//=======================================
//        ?��?任�?評估?�數 (?��??��?
//=======================================

/**
 * ?��??�數：�??��?估�??��??��??��?任�??? * 觸發?��?：根?��??�任?��? evaluationConfig.triggerType?? *   - ?��??��???MONTHLY，根??evaluationConfig.evaluationFrequency (?��?/?��?)?? * TODO: ?�要設�?Pub/Sub 主�???Cloud Scheduler 作業來實?�觸?�此?�數?? */

/**
 * 評估?�個�??�任?��??�?��??�符?��??��??�工?? * @param {object} task - The bonus task object (including id).
 */
async function evaluateSingleTaskForAllEmployees(task) {
    logger.info(`Evaluating task [${task.name}] (${task.id}) for all employees.`);
    try {
        const minLevel = task.minLevel || 0;
        // MODIFIED: Query 'employees' collection instead of 'users'
        const usersSnapshot = await db.collection('employees') 
                                      .where('level', '>=', minLevel)
                                      // Add other potential filters like isBonusEligible later
                                      // .where('isBonusEligible', '==', true) // Example
                                      .get();

        if (usersSnapshot.empty) {
            logger.info(`No employees found meeting minimum level ${minLevel} for task ${task.id}.`);
            return;
        }

        logger.info(`Found ${usersSnapshot.size} employees potentially eligible for task ${task.id}.`);

        const evaluationDate = FieldValue.serverTimestamp(); // Use server timestamp for consistency
        const evaluationMonth = getEvaluationMonthString(task.evaluationConfig);
        if (!evaluationMonth) {
            logger.warn(`Could not determine evaluation month for task ${task.id}, skipping.`);
            return;
        }

        const employeePromises = [];
        usersSnapshot.forEach(userDoc => {
            const employee = { id: userDoc.id, ...userDoc.data() };
            employeePromises.push(evaluateTaskForEmployee(task, employee, evaluationMonth, evaluationDate));
        });

        await Promise.all(employeePromises);
        logger.info(`Finished evaluating task [${task.name}] (${task.id}) for all employees.`);

    } catch (error) {
        logger.error(`Error evaluating task ${task.id} for all employees:`, error);
    }
}

/**
 * 評估?��??��?任�?對單?�員工�??��??��??? * @param {object} task - The bonus task object.
 * @param {object} employee - The employee user object.
 * @param {string} evaluationMonth - The target month string 'YYYY-MM'.
 * @param {Timestamp} evaluationDate - Timestamp of when the evaluation is run.
 */
async function evaluateTaskForEmployee(task, employee, evaluationMonth, evaluationDate) {
    const progressDocRef = db.collection('employee_bonus_progress').doc(`${employee.id}_${evaluationMonth}`);
    logger.info(`Evaluating task [${task.name}] (${task.id}) for employee [${employee.displayName || employee.id}] (${employee.id}) for month ${evaluationMonth}.`);

    let status = "PENDING";
    let rewardEarned = null;
    const conditionsResult = [];
    let unlockConditionsMet = true; // Assume met initially

    try {
        // 1. 檢查?��?條件 (Unlock Conditions) - Currently only Tenure
        if (task.unlockConditions?.minTenureDays) {
            const tenureDays = calculateTenureDays(employee.hireDate);
            if (tenureDays === null || tenureDays < task.unlockConditions.minTenureDays) {
                unlockConditionsMet = false;
                status = "INELIGIBLE";
                logger.info(`Employee ${employee.id} ineligible for task ${task.id} due to tenure (${tenureDays} days < ${task.unlockConditions.minTenureDays} required).`);
            }
        }
        // Add checks for other unlock conditions (e.g., store performance) here later

        // 2. 如�??��?條件滿足，�?估核心�?�?(Core Conditions)
        if (unlockConditionsMet && task.conditions && task.conditions.length > 0) {
            let overallPassed = task.conditionsLogic === 'OR' ? false : true; // Initial state depends on logic
            // 使用�?��?�數調用 checkSingleCondition ?�數
            const conditionPromises = task.conditions.map(condition => {
                // 使用?��??�數?��??�格�?                return checkSingleCondition(employee.id, condition, employee, evaluationDate instanceof Date ? 
                    evaluationDate : new Date());
            });

            const results = await Promise.all(conditionPromises);
            results.forEach(result => {
                conditionsResult.push(result); // Store individual results
                if (task.conditionsLogic === 'AND') {
                    if (!result.passed) overallPassed = false;
                } else { // OR logic
                    if (result.passed) overallPassed = true;
                }
            });

            if (overallPassed) {
                status = "PASSED";
                rewardEarned = task.rewardValue;
                logger.info(`Employee ${employee.id} PASSED task ${task.id}.`);
            } else {
                status = "FAILED";
                logger.info(`Employee ${employee.id} FAILED task ${task.id}.`);
            }
        } else if (unlockConditionsMet && (!task.conditions || task.conditions.length === 0)) {
            // No core conditions defined, but unlock met - consider it PASSED
            status = "PASSED";
            rewardEarned = task.rewardValue;
             logger.info(`Employee ${employee.id} PASSED task ${task.id} (no core conditions defined).`);
        } else if (!unlockConditionsMet) {
            // Already set to INELIGIBLE above
        }

        // 3. 記�?結�???Firestore
        const taskResult = {
            taskId: task.id,
            taskName: task.name,
            status: status,
            rewardEarned: rewardEarned,
            evaluationDate: evaluationDate, // Record when this specific evaluation ran
            unlockConditionsMet: unlockConditionsMet,
            conditionsResult: conditionsResult // Store snapshot of condition checks
        };

        // Use set with merge:true to add/update the task result within the monthly document
        await progressDocRef.set({
            employeeId: employee.id,
            employeeName: employee.displayName || employee.name || '?�知姓�?',
            month: evaluationMonth,
            tasks: FieldValue.arrayUnion(taskResult) // Add task result to array, avoids duplicates if run multiple times
        }, { merge: true });

        logger.info(`Saved evaluation result for task ${task.id}, employee ${employee.id}, month ${evaluationMonth}. Status: ${status}`);

    } catch (error) {
        logger.error(`Error evaluating task ${task.id} for employee ${employee.id}:`, error);
        // Optionally log failure to a separate collection or update status to ERROR
    }
}

/**
 * 檢查?�個核心�?件�??��??�工?�否?��??? * @param {object} employee - The employee user object.
 * @param {object} condition - The condition object { type, metric, operator, value, params }.
 * @param {string} evaluationMonth - The target month string 'YYYY-MM' (for time-based lookups).
 * @returns {Promise<object>} - Promise resolving to { condition, dataValue, passed: boolean }
 * @deprecated 使用?��? checkSingleCondition(userId, condition, employeeData, evaluationDate) ?�代
 */
async function checkSingleCondition(employee, condition, evaluationMonth) {
    logger.warn(`使用已�??��? checkSingleCondition ?�接??���??�新調用以使?�新?�函?�。`);
    
    // 建�?評估?��?，使??evaluationMonth ?��?�?    let evaluationDate;
    try {
        const [year, month] = evaluationMonth.split('-').map(Number);
        evaluationDate = new Date(year, month, 0); // ?��??��?
    } catch (error) {
        logger.error(`?��?�?${evaluationMonth} ?�建評估?��?，使?�當?�日?�替代`, error);
        evaluationDate = new Date();
    }
    
    // 從這個函?�命?�空?�中?��?對全局?��??�數?��???    const globalCheckSingleCondition = global.checkSingleCondition || checkSingleCondition;
    // ?��??�歸調用，直?�調?�新?�口
    return await globalCheckSingleCondition(employee.id, condition, employee, evaluationDate);
}

// --- Evaluation Helper Functions ---

/**
 * Calculates tenure in days based on hire date.
 * @param {Timestamp|Date|string} hireDateInput - Employee hire date.
 * @returns {number|null} - Tenure in days, or null if hire date is invalid.
 * @deprecated Please use the more comprehensive version below
 */
function calculateTenureDays(hireDateInput) {
    logger.warn(`使用已�??��?簡單 calculateTenureDays ?�口?��??�新調用以使?�更完整?��??�。`);
    // 調用下方?��??��??�數，傳?�當?�日?��??��?估日??    return calculateTenureDaysExtended(hireDateInput, new Date());
}

/**
 * Compares two values using a specified operator.
 * @param {*} actualValue - The actual data value from the employee/system.
 * @param {string} operator - The comparison operator (e.g., '>=', '<=', '==').
 * @param {*} targetValue - The target value from the condition definition.
 * @returns {boolean} - True if the comparison holds, false otherwise.
 */
function compareValues(actualValue, operator, targetValue) {
    logger.debug(`Comparing values: ${actualValue} ${operator} ${targetValue}`);
    // Basic type coercion for comparison (may need refinement)
    const numActual = Number(actualValue);
    const numTarget = Number(targetValue);
    const useNumeric = !isNaN(numActual) && !isNaN(numTarget);

    try {
        switch (operator) {
            case '>=':
                return useNumeric ? numActual >= numTarget : actualValue >= targetValue;
            case '<=':
                return useNumeric ? numActual <= numTarget : actualValue <= targetValue;
            case '==':
                // Be careful with type coercion for '=='
                 return useNumeric ? numActual === numTarget : String(actualValue) === String(targetValue);
            case '!=':
                return useNumeric ? numActual !== numTarget : String(actualValue) !== String(targetValue);
            case '>':
                return useNumeric ? numActual > numTarget : actualValue > targetValue;
            case '<':
                return useNumeric ? numActual < numTarget : actualValue < targetValue;
            default:
                logger.warn(`Unsupported operator: ${operator}`);
                return false;
        }
    } catch (error) {
        logger.error("Error during value comparison:", error, { actualValue, operator, targetValue });
        return false;
    }
}

/**
 * Determines the evaluation month string (YYYY-MM) based on config.
 * @param {object} evaluationConfig - The evaluation config object.
 * @returns {string|null} - YYYY-MM string or null.
 */
function getEvaluationMonthString(evaluationConfig) {
    logger.warn(`使用已�??��? getEvaluationMonthString ?��?定義?��??�新調用以使?��???066行�??��??�數?�`);
    // 調用?��??�數以�??��??��?    if (typeof global.getEvaluationMonthString === 'function') {
        return global.getEvaluationMonthString(evaluationConfig);
    }
    
    // ?��?保�?實現?�輯，以?�萬一?��??�全局?�數
    if (!evaluationConfig || evaluationConfig.triggerType !== 'MONTHLY') {
        logger.warn("Cannot get evaluation month: Invalid config or triggerType is not MONTHLY.", { evaluationConfig });
        return null;
    }
    try {
        const currentDate = new Date();
        // If we have a specific month in the config, use it
        if (evaluationConfig.targetMonth) {
            return evaluationConfig.targetMonth;
        }
        
        // Otherwise calculate from the current date
        const targetMonth = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;
        logger.info(`Using current month for evaluation: ${targetMonth}`);
        return targetMonth;
    } catch (error) {
        logger.error("Error determining evaluation month:", error);
        return null;
    }
}

// =======================================
// == ?��?任�?評估?�數 (Cloud Functions) ==
// =======================================

// --- 引入必�???Firebase Admin SDK ---
// (?�設 admin, db, logger, FieldValue 已�??��?案�??��?始�?)

/**
 * 已由上方定義??compareValues ?�數?�代
 * @deprecated 請使?��??��?義�? compareValues ?�數
 */
function compareValues(actual, operator, target) {
    logger.warn(`使用已�??��? compareValues ?�接??���??�新調用以使?�新?�函?�。`);
    // ?��??�到上方定義?�函?��?保�??�數?��?一??    return compareValuesExtended(actual, operator, target);
}

/**
 * Calculates tenure in days between hire date and a given end date.
 * @param {admin.firestore.Timestamp | Date | string | null} hireDateInput - The user's hire date.
 * @param {Date} evaluationDate - The date the evaluation is run (defaults to now if invalid).
 * @returns {number|null} Tenure in days, or null if hire date is invalid.
 */
function calculateTenureDaysExtended(hireDateInput, evaluationDate = new Date()) {
     // (此函?�內容�?之�??��??��?�?
     let hireDate;
     if (!hireDateInput) return null;

     try {
         if (hireDateInput instanceof Date) {
             hireDate = hireDateInput;
         } else if (hireDateInput.toDate) { // Firestore Timestamp
             hireDate = hireDateInput.toDate();
         } else if (typeof hireDateInput === 'string') {
              hireDate = new Date(hireDateInput);
         } else {
              logger.warn("Unsupported hireDate format:", hireDateInput);
              return null;
         }

         if (isNaN(hireDate.getTime())) {
             logger.warn("Invalid hireDate after parsing:", hireDateInput);
             return null;
         }

         // Ensure evaluationDate is valid
         if (!evaluationDate || !(evaluationDate instanceof Date) || isNaN(evaluationDate.getTime())) {
             logger.warn("Invalid evaluationDate provided for tenure calculation. Using current time.");
             evaluationDate = new Date();
         }

         // 計�??��?差異 (忽略?��??��?)
         const evalDateOnly = new Date(evaluationDate.getFullYear(), evaluationDate.getMonth(), evaluationDate.getDate());
         const hireDateOnly = new Date(hireDate.getFullYear(), hireDate.getMonth(), hireDate.getDate());

         const diffTime = evalDateOnly.getTime() - hireDateOnly.getTime();
         const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24)); // ?��??�數�?         return diffDays >= 0 ? diffDays : 0;
     } catch (error) {
          logger.error("Error calculating tenure days:", error, { hireDateInput, evaluationDate });
          return null;
     }
}

/**
 * Checks an attendance-related condition.
 * @param {string} userId The employee's ID.
 * @param {string} metric The specific attendance metric (e.g., 'on_time_rate').
 * @param {string} operator The comparison operator.
 * @param {*} value The target value.
 * @param {string} timePeriod String indicating the period (e.g., 'LAST_MONTH').
 * @param {Date} evaluationDate Date the evaluation is running.
 * @returns {Promise<{passed: boolean, dataValue: any}>}
 */
async function checkAttendanceCondition(userId, metric, operator, value, timePeriod, evaluationDate) {
    // --- 計�??��?範�? ---
    let startDate, endDate;
    const evalYear = evaluationDate.getFullYear();
    const evalMonth = evaluationDate.getMonth(); // 0-indexed

    // Add more timePeriod options if needed
    if (timePeriod === 'LAST_MONTH') {
        startDate = new Date(evalYear, evalMonth - 1, 1, 0, 0, 0, 0); // First day of last month, start of day
        endDate = new Date(evalYear, evalMonth, 0, 23, 59, 59, 999); // Last day of last month, end of day
    } else if (timePeriod === 'CURRENT_MONTH') {
         startDate = new Date(evalYear, evalMonth, 1, 0, 0, 0, 0);
         endDate = new Date(evalYear, evalMonth + 1, 0, 23, 59, 59, 999);
    } else {
        logger.warn(`Unsupported timePeriod for attendance: ${timePeriod}`);
        return { passed: false, dataValue: `不支?��??��??�?? ${timePeriod}` };
    }

    logger.info(`Checking ATTENDANCE metric: ${metric} for user ${userId} between ${startDate.toISOString()} and ${endDate.toISOString()}`);

    // --- ASSUMPTIONS: Verify these constants match your Firestore structure! ---
    const CLOCK_RECORDS_COLLECTION = 'clock_records';
    const SCHEDULE_COLLECTION = 'schedules';
    const USER_ID_FIELD = 'userId';
    const TIMESTAMP_FIELD = 'timestamp';
    const STATUS_FIELD = 'status';                  // Assumed field written by recordClockEvent
    const ON_TIME_STATUS_VALUE = '準�?';            // Assumed value written by recordClockEvent
    const LATE_STATUS_VALUE = '?�到';              // Assumed value written by recordClockEvent
    const SCHEDULE_DATE_FIELD = 'date';             // (YYYY-MM-DD string)
    const SCHEDULE_SHIFT_FIELD = 'shift';
    const SCHEDULE_DAY_OFF_VALUE = '�?;

    try {
        let actualValue = null;
        let passed = false;

        // --- Query clock records and schedules --- 
        // ?�詢?�卡記�?
        const clockRecordsQuery = db.collection(CLOCK_RECORDS_COLLECTION)
                                  .where(USER_ID_FIELD, '==', userId)
                                  .where(TIMESTAMP_FIELD, '>=', startDate)
                                  .where(TIMESTAMP_FIELD, '<=', endDate);
        const clockRecordsSnapshot = await clockRecordsQuery.get();
        const clockRecords = [];
        clockRecordsSnapshot.forEach(doc => clockRecords.push(doc.data()));
        logger.info(`Found ${clockRecords.length} clock records for user ${userId}`);

        // ?�詢?�班記�?
        const scheduleQuery = db.collection(SCHEDULE_COLLECTION)
                             .where(USER_ID_FIELD, '==', userId)
                             .where(SCHEDULE_DATE_FIELD, '>=', startDate.toISOString().split('T')[0])
                             .where(SCHEDULE_DATE_FIELD, '<=', endDate.toISOString().split('T')[0]);
        const scheduleSnapshot = await scheduleQuery.get();
        const scheduleRecords = [];
        scheduleSnapshot.forEach(doc => scheduleRecords.push(doc.data()));
        logger.info(`Found ${scheduleRecords.length} schedule records for user ${userId}`);

        // --- Calculate metrics --- 
        switch (metric) {
            case 'on_time_rate': {
                let onTimeCount = 0;
                let relevantClockIns = 0;
                const scheduledWorkDaysMap = new Map();
                
                // 建�??�班工�??��?�?                scheduleRecords.forEach(schedule => {
                    if (schedule[SCHEDULE_SHIFT_FIELD] !== SCHEDULE_DAY_OFF_VALUE) {
                        scheduledWorkDaysMap.set(schedule[SCHEDULE_DATE_FIELD], schedule[SCHEDULE_SHIFT_FIELD]);
                    }
                });

                clockRecords.forEach(record => {
                    try {
                         const recordTimestamp = record[TIMESTAMP_FIELD];
                         if(recordTimestamp && recordTimestamp.toDate) {
                             const recordDateStr = recordTimestamp.toDate().toISOString().split('T')[0];
                             if (scheduledWorkDaysMap.has(recordDateStr)) {
                                 relevantClockIns++;
                                 // Use the status field recorded by recordClockEvent
                                 if (record[STATUS_FIELD] === ON_TIME_STATUS_VALUE) { 
                                     onTimeCount++;
                                 }
                             }
                         }
                    } catch (e) { logger.warn("Error processing clock record for on_time_rate:", e, record); }
                });

                actualValue = (relevantClockIns > 0) ? (onTimeCount / relevantClockIns) : 1.0; 
                logger.info(`On-time calculation: ${onTimeCount} on-time / ${relevantClockIns} relevant clock-ins = ${actualValue}`);
                passed = compareValues(actualValue, operator, value);
                break;
            }
            case 'absence_days': {
                const scheduledWorkDaysMap = new Map();
                const clockedDaysMap = new Map();
                
                // 建�??�班工�??��?�?                scheduleRecords.forEach(schedule => {
                    if (schedule[SCHEDULE_SHIFT_FIELD] !== SCHEDULE_DAY_OFF_VALUE) {
                        scheduledWorkDaysMap.set(schedule[SCHEDULE_DATE_FIELD], true);
                    }
                });
                
                // 建�?已�??�日?��?�?                clockRecords.forEach(record => {
                    try {
                        const recordTimestamp = record[TIMESTAMP_FIELD];
                        if(recordTimestamp && recordTimestamp.toDate) {
                            const recordDateStr = recordTimestamp.toDate().toISOString().split('T')[0];
                            clockedDaysMap.set(recordDateStr, true);
                        }
                    } catch (e) { logger.warn("Error processing clock record for absence_days:", e, record); }
                });
                
                // 計�?缺勤天數（�??��??��??��?天數�?                let absenceDays = 0;
                scheduledWorkDaysMap.forEach((_, dateStr) => {
                    if (!clockedDaysMap.has(dateStr)) {
                        absenceDays++;
                    }
                });
                
                actualValue = absenceDays;
                logger.info(`Absence days calculation: ${actualValue} scheduled work days without clock records`);
                passed = compareValues(actualValue, operator, value);
                break;
            }
            case 'late_count': {
                let lateCount = 0;
                const scheduledWorkDaysMap = new Map();
                
                // 建�??�班工�??��?�?                scheduleRecords.forEach(schedule => {
                    if (schedule[SCHEDULE_SHIFT_FIELD] !== SCHEDULE_DAY_OFF_VALUE) {
                        scheduledWorkDaysMap.set(schedule[SCHEDULE_DATE_FIELD], schedule[SCHEDULE_SHIFT_FIELD]);
                    }
                });

                clockRecords.forEach(record => {
                     try {
                         const recordTimestamp = record[TIMESTAMP_FIELD];
                         if(recordTimestamp && recordTimestamp.toDate) {
                             const recordDateStr = recordTimestamp.toDate().toISOString().split('T')[0];
                             if (scheduledWorkDaysMap.has(recordDateStr)) {
                                 // Use the status field recorded by recordClockEvent
                                 if (record[STATUS_FIELD] === LATE_STATUS_VALUE) { 
                                     lateCount++;
                                 }
                             }
                         }
                    } catch (e) { logger.warn("Error processing clock record for late_count:", e, record); }
                });
                actualValue = lateCount;
                logger.info(`Late count calculation: ${actualValue} late records found on scheduled work days`);
                passed = compareValues(actualValue, operator, value);
                break;
            }
            default:
                logger.warn(`Unsupported attendance metric: ${metric}`);
                return { passed: false, dataValue: `不支?��??�勤?��?: ${metric}` };
        }

        logger.info(`Attendance check result - Metric: ${metric}, Actual: ${actualValue}, Target: ${value}, Operator: ${operator}, Passed: ${passed}`);
        return { passed: passed, dataValue: actualValue };

    } catch (error) {
        logger.error(`Error checking attendance condition for user ${userId}, metric ${metric}:`, error);
        // Return a clear error value
        return { passed: false, dataValue: `檢查?�發?�錯�? ${error.message}` };
    }
}


/**
 * Checks a sales-related condition.
 * @param {string} userId The employee's ID.
 * @param {string | null} storeId The employee's store ID (might be needed).
 * @param {string} metric The specific sales metric.
 * @param {string} operator The comparison operator.
 * @param {*} value The target value.
 * @param {string} timePeriod String indicating the period.
 * @param {Date} evaluationDate Date the evaluation is running.
 * @returns {Promise<{passed: boolean, dataValue: any}>}
 */
async function checkSalesCondition(userId, storeId, metric, operator, value, timePeriod, evaluationDate) {
     // --- 計�??��?範�? (YYYY-MM) ---
     let yearMonth;
     const evalYear = evaluationDate.getFullYear();
     const evalMonth = evaluationDate.getMonth(); // 0-indexed

     if (timePeriod === 'LAST_MONTH') {
         const lastMonthDate = new Date(evalYear, evalMonth - 1, 1);
         yearMonth = `${lastMonthDate.getFullYear()}-${String(lastMonthDate.getMonth() + 1).padStart(2, '0')}`;
     } else if (timePeriod === 'CURRENT_MONTH') {
          yearMonth = `${evalYear}-${String(evalMonth + 1).padStart(2, '0')}`;
     } else {
         logger.warn(`Unsupported timePeriod for sales: ${timePeriod}`);
         return { passed: false, dataValue: null };
     }

    logger.info(`Checking SALES metric: ${metric} for user ${userId} (Store: ${storeId}) for period ${yearMonth}`);

    // --- ASSUMPTIONS: Collection and Field Names for Sales ---
    // PLEASE VERIFY these against your actual Firestore structure.
    const SALES_REPORTS_COLLECTION = 'sales_reports'; // ASSUMPTION: Monthly store reports collection name.
    const SALES_RECORDS_COLLECTION = 'sales_records'; // ASSUMPTION: Individual sales records collection name (if used).
    const STORE_ID_FIELD = 'store';                 // ASSUMPTION: Field name for store ID in reports/records.
    const USER_ID_FIELD_SALES = 'userId';         // ASSUMPTION: Field name for user ID in individual sales records.
    const REPORT_MONTH_FIELD = 'month';             // ASSUMPTION: Field name for month (YYYY-MM) in reports.
    const TARGET_SALES_FIELD = 'target';         // ASSUMPTION: Field name for target sales in reports.
    const ACTUAL_SALES_FIELD = 'revenue';         // ASSUMPTION: Field name for actual sales in reports.
    const TOTAL_SALES_FIELD = 'revenue';           // ASSUMPTION: Field name for total sales in reports (might be same as actual).
    const SALE_AMOUNT_FIELD = 'amount';               // ASSUMPTION: Field name for amount in individual sales records.
    const SALE_TIMESTAMP_FIELD = 'timestamp';          // ASSUMPTION: Field name for timestamp in individual sales records.


    try {
        let actualValue = null;
        let passed = false;

        // --- 計�??�輯 ---
        switch (metric) {
            case 'store_target_rate': {
                 if (!storeId) {
                     logger.warn(`Cannot check store_target_rate for user ${userId}: Missing storeId.`);
                     return { passed: false, dataValue: "缺�?店鋪資�?" };
                 }
                 // ASSUMPTION: Query sales_reports collection for the store and month.
                 const reportQuery = db.collection(SALES_REPORTS_COLLECTION)
                                      .where(STORE_ID_FIELD, '==', storeId)
                                      .where(REPORT_MONTH_FIELD, '==', yearMonth)
                                      .limit(1);
                 const reportSnapshot = await reportQuery.get();

                 if (reportSnapshot.empty) {
                      logger.warn(`No sales report found for store ${storeId}, month ${yearMonth}. Assuming 0% target rate.`);
                      actualValue = 0;
                 } else {
                      const reportData = reportSnapshot.docs[0].data();
                      const target = reportData[TARGET_SALES_FIELD];
                      const actual = reportData[ACTUAL_SALES_FIELD];
                      // Ensure target is a positive number to avoid division by zero or meaningless rates.
                      if (target && typeof target === 'number' && target > 0 && actual && typeof actual === 'number') {
                           actualValue = actual / target;
                      } else {
                           logger.warn(`Missing, invalid, or zero target/actual sales in report for ${storeId}, ${yearMonth}: Target=${target}, Actual=${actual}. Assuming 0% target rate.`);
                           actualValue = 0;
                      }
                 }
                 passed = compareValues(actualValue, operator, value); // Usually >=
                 break;
             }
            case 'personal_sales_amount': {
                 // ASSUMPTION: Query individual sales_records collection.
                 const [year, month] = yearMonth.split('-').map(Number);
                 const startDate = new Date(year, month - 1, 1);
                 const endDate = new Date(year, month, 0, 23, 59, 59, 999);

                 const salesQuery = db.collection(SALES_RECORDS_COLLECTION)
                                      .where(USER_ID_FIELD_SALES, '==', userId)
                                      .where(SALE_TIMESTAMP_FIELD, '>=', startDate)
                                      .where(SALE_TIMESTAMP_FIELD, '<=', endDate);
                 const salesSnapshot = await salesQuery.get();
                 actualValue = 0;
                 salesSnapshot.forEach(doc => {
                      const saleData = doc.data();
                      if (saleData[SALE_AMOUNT_FIELD] && typeof saleData[SALE_AMOUNT_FIELD] === 'number') {
                          actualValue += saleData[SALE_AMOUNT_FIELD];
                      }
                 });
                 passed = compareValues(actualValue, operator, value); // Usually >=
                 break;
            }
             case 'store_total_sales': {
                 if (!storeId) {
                      logger.warn(`Cannot check store_total_sales for user ${userId}: Missing storeId.`);
                     return { passed: false, dataValue: "缺�?店鋪資�?" };
                 }
                 // ASSUMPTION: Query sales_reports collection.
                 const reportQuery = db.collection(SALES_REPORTS_COLLECTION)
                                      .where(STORE_ID_FIELD, '==', storeId)
                                      .where(REPORT_MONTH_FIELD, '==', yearMonth)
                                      .limit(1);
                 const reportSnapshot = await reportQuery.get();

                 if (reportSnapshot.empty) {
                      logger.warn(`No sales report found for store ${storeId}, month ${yearMonth}. Assuming 0 total sales.`);
                      actualValue = 0;
                 } else {
                      const reportData = reportSnapshot.docs[0].data();
                      // Use the assumed field name for total sales.
                      actualValue = reportData[TOTAL_SALES_FIELD] ?? 0;
                 }
                 passed = compareValues(actualValue, operator, value); // Usually >=
                 break;
             }
            case 'average_sale_amount': {
                 // 計�??�戶平�?訂單?��?
                 const [year, month] = yearMonth.split('-').map(Number);
                 const startDate = new Date(year, month - 1, 1);
                 const endDate = new Date(year, month, 0, 23, 59, 59, 999);

                 const salesQuery = db.collection(SALES_RECORDS_COLLECTION)
                                      .where(USER_ID_FIELD_SALES, '==', userId)
                                      .where(SALE_TIMESTAMP_FIELD, '>=', startDate)
                                      .where(SALE_TIMESTAMP_FIELD, '<=', endDate);
                 const salesSnapshot = await salesQuery.get();
                 
                 if (salesSnapshot.empty) {
                     logger.warn(`No sales records found for user ${userId}, period ${yearMonth}. Assuming 0 average sale amount.`);
                     actualValue = 0;
                 } else {
                     let totalAmount = 0;
                     let recordCount = 0;
                     
                     salesSnapshot.forEach(doc => {
                         const saleData = doc.data();
                         if (saleData[SALE_AMOUNT_FIELD] && typeof saleData[SALE_AMOUNT_FIELD] === 'number') {
                             totalAmount += saleData[SALE_AMOUNT_FIELD];
                             recordCount++;
                         }
                     });
                     
                     actualValue = recordCount > 0 ? totalAmount / recordCount : 0;
                     logger.info(`Average sale calculation: ${totalAmount} total / ${recordCount} records = ${actualValue}`);
                 }
                 
                 passed = compareValues(actualValue, operator, value);
                 break;
            }
            case 'sales_count': {
                 // 計�??�戶完�??�銷?�數??                 const [year, month] = yearMonth.split('-').map(Number);
                 const startDate = new Date(year, month - 1, 1);
                 const endDate = new Date(year, month, 0, 23, 59, 59, 999);

                 const salesQuery = db.collection(SALES_RECORDS_COLLECTION)
                                      .where(USER_ID_FIELD_SALES, '==', userId)
                                      .where(SALE_TIMESTAMP_FIELD, '>=', startDate)
                                      .where(SALE_TIMESTAMP_FIELD, '<=', endDate);
                 const salesSnapshot = await salesQuery.get();
                 
                 actualValue = salesSnapshot.size;
                 logger.info(`Sales count: ${actualValue} sales records found for user ${userId} in period ${yearMonth}`);
                 
                 passed = compareValues(actualValue, operator, value);
                 break;
            }
            default:
                logger.warn(`Unsupported sales metric: ${metric}`);
                return { passed: false, dataValue: `不支?��??�售?��?: ${metric}` };
        }

        logger.info(`Sales check result - Metric: ${metric}, Actual: ${actualValue}, Target: ${value}, Operator: ${operator}, Passed: ${passed}`);
        return { passed: passed, dataValue: actualValue };

    } catch (error) {
        logger.error(`Error checking sales condition for user ${userId}, metric ${metric}:`, error);
        return { passed: false, dataValue: `檢查?�發?�錯�? ${error.message}` };
    }
}


/**
 * Main function to check a single condition. Routes based on type.
 * Called by evaluateTaskForEmployee.
 *
 * Determines the evaluation month string (YYYY-MM) based on config.
 * @param {object} evaluationConfig - The evaluation config object from the bonus task.
 * @returns {string|null} - YYYY-MM string or null if config is invalid or type isn't MONTHLY.
 */
function getEvaluationMonthString(evaluationConfig) {
    logger.warn(`使用已�??��? getEvaluationMonthString ?��?定義?��??�新調用以使?��???066行�??��??�數?�`);
    // 調用?��??�數以�??��??��?    if (typeof global.getEvaluationMonthString === 'function') {
        return global.getEvaluationMonthString(evaluationConfig);
    }
    
    // ?��?保�?實現?�輯，以?�萬一?��??�全局?�數
    if (!evaluationConfig || evaluationConfig.triggerType !== 'MONTHLY') {
        logger.warn("Cannot get evaluation month: Invalid config or triggerType is not MONTHLY.", { evaluationConfig });
        return null;
    }
    try {
        const currentDate = new Date();
        // If we have a specific month in the config, use it
        if (evaluationConfig.targetMonth) {
            return evaluationConfig.targetMonth;
        }
        
        // Otherwise calculate from the current date
        const targetMonth = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;
        logger.info(`Using current month for evaluation: ${targetMonth}`);
        return targetMonth;
    } catch (error) {
        logger.error("Error determining evaluation month:", error);
        return null;
    }
}

/**
 * Scheduled function to evaluate bonus tasks.
 * Triggered daily, checks internally if tasks are due based on their config.
 */
exports.evaluateBonusTasksScheduled = onSchedule({
    schedule: "every day 03:00", // Runs daily at 3 AM Taipei time
    timeZone: "Asia/Taipei",
    // secrets: [...] // Add secrets needed by condition checks if any (e.g., external API keys)
    timeoutSeconds: 540, // Max timeout for scheduled functions
    memory: '1GiB' // Adjust memory if needed for processing many users/tasks
}, async (event) => {
    // (此函?�內容�?之�??��??��?�??調用 evaluateSingleTaskForAllEmployees)
    logger.info("Starting scheduled bonus task evaluation run...");
    const startTime = Date.now();
    const now = new Date(); // Use a consistent 'now' for checks within this run
    const todayDay = now.getDate(); // Day of the month (1-31)
    let tasksEvaluatedCount = 0;

    // Log start of the system task
    await logActivity({ userId: 'system', feature: 'ScheduledTask', action: 'evaluateBonusTasksScheduledStart', details: `Run started at ${now.toISOString()}`, success: true });

    try {
        // ASSUMPTION: Bonus tasks are stored in 'bonus_tasks' collection.
        const tasksSnapshot = await db.collection('bonus_tasks')
                                      .where('isActive', '==', true) // Only evaluate active tasks
                                      .where('evaluationConfig.triggerType', '==', 'MONTHLY') // Currently only supports monthly triggers
                                      .get();

        if (tasksSnapshot.empty) {
            logger.info("No active monthly bonus tasks found to evaluate today.");
            // Log completion even if no tasks found
            const duration = Date.now() - startTime;
            await logActivity({ userId: 'system', feature: 'ScheduledTask', action: 'evaluateBonusTasksScheduledComplete', details: `Run finished in ${duration}ms. No active monthly tasks found.`, success: true });
            return; // Exit if no tasks
        }

        logger.info(`Found ${tasksSnapshot.size} active monthly bonus tasks.`);

        const evaluationPromises = [];

        tasksSnapshot.forEach(taskDoc => {
            const task = { id: taskDoc.id, ...taskDoc.data() };
            const evalConfig = task.evaluationConfig;

            // Basic validation of task data
            if (!evalConfig || !evalConfig.evaluationFrequency) {
                 logger.warn(`Task ${task.id} [${task.name}] is missing evaluationConfig or evaluationFrequency, skipping.`);
                 return; // Skip task if essential config is missing
            }

            // Determine if this task should be evaluated today based on its frequency setting
            let shouldEvaluateToday = false;
            if (evalConfig.evaluationFrequency === 'START_OF_MONTH') {
                 // Evaluate if today is the 1st day of the month
                if (todayDay === 1) {
                    shouldEvaluateToday = true;
                }
            } else if (evalConfig.evaluationFrequency === 'END_OF_MONTH') {
                // Evaluate if today is the *last* day of the current month
                const lastDayOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0).getDate();
                if (todayDay === lastDayOfMonth) {
                    shouldEvaluateToday = true;
                }
            } else {
                logger.warn(`Task ${task.id} [${task.name}] has unsupported evaluationFrequency: ${evalConfig.evaluationFrequency}, skipping.`);
                return; // Skip if frequency is unknown
            }

            // If today is the evaluation day for this task, add its evaluation to the promises
            if (shouldEvaluateToday) {
                logger.info(`Task [${task.name}] (${task.id}) is scheduled for evaluation today (Frequency: ${evalConfig.evaluationFrequency}). Queueing evaluation.`);
                // Queue the function that evaluates this task for all employees
                evaluationPromises.push(evaluateSingleTaskForAllEmployees(task));
                tasksEvaluatedCount++;
            } else {
                 logger.info(`Task [${task.name}] (${task.id}) is not scheduled for evaluation today (Frequency: ${evalConfig.evaluationFrequency}, Today: ${todayDay}).`);
            }
        });

        // Wait for all queued task evaluations to complete
        if (evaluationPromises.length > 0) {
             logger.info(`Waiting for ${evaluationPromises.length} task evaluations to complete...`);
            await Promise.all(evaluationPromises);
             logger.info(`All ${evaluationPromises.length} scheduled task evaluations completed.`);
        } else {
             logger.info("No tasks were due for evaluation today.");
        }

        const duration = Date.now() - startTime;
        logger.info(`Scheduled bonus task evaluation run finished in ${duration}ms. Evaluated ${tasksEvaluatedCount} tasks.`);
        // Log successful completion
        await logActivity({ userId: 'system', feature: 'ScheduledTask', action: 'evaluateBonusTasksScheduledComplete', details: `Run finished in ${duration}ms. Processed ${tasksEvaluatedCount} tasks scheduled for today.`, success: true });


    } catch (error) {
        const duration = Date.now() - startTime;
        logger.error("Critical error during scheduled bonus task evaluation run:", error);
        // Log failure
        await logActivity({ userId: 'system', feature: 'ScheduledTask', action: 'evaluateBonusTasksScheduledError', details: `Run failed after ${duration}ms: ${error.message}`, success: false });
        // Re-throwing the error might be appropriate depending on desired function behavior on failure
        // throw error;
    }
});

// --- Make sure to export the new scheduled function ---
// (If you use a central module.exports = {}, add 'evaluateBonusTasksScheduled' there.
// Since you use exports.funcName = ..., the line above already does the export.)

// --- ?�卡?��??�數 (HTTPS Callable) ---
exports.recordClockEvent = onCall({
    secrets: [LINE_OA_TOKEN_PARAM, TELEGRAM_BOT_TOKEN_PARAM], // Add secrets if needed by notifications inside
    region: 'asia-east2' // Specify your function region
}, async (request) => {
    logger.info("recordClockEvent received:", { data: request.data, auth: request.auth ? request.auth.uid : 'No auth' });

    // 1. 驗�??�戶身份
    if (!request.auth) {
        logger.warn("recordClockEvent: Authentication required.");
        throw new HttpsError('unauthenticated', '?�要�?證身份�??��??��?);
    }
    const userId = request.auth.uid;

    // --- ?��?：獲?��??�設定�??��?資�? ---
    let settingsData = {};
    let storeData = null;
    let parsedRadii = {};
    let parsedHours = {};
    const selectedStoreId = request.data?.storeId; // Get store ID from request
    const userLocation = request.data?.location; // Get location from request

    if (!selectedStoreId) {
        logger.warn(`recordClockEvent: Missing storeId in request data for user ${userId}.`);
        throw new HttpsError('invalid-argument', '?�卡請�?中缺少�?店�?訊�?);
    }
    // Location is optional for check if radius is unlimited, but needed otherwise
    if (!userLocation || userLocation.latitude == null || userLocation.longitude == null) {
         logger.warn(`recordClockEvent: Missing location data in request for user ${userId}. Radius check might fail if required.`);
         // We'll check later if the radius requires location
    }


    try {
        // CORRECTED: Read from store_config instead of clockinConfig
        const settingsRef = db.collection('settings').doc('store_config');
        // REMOVED: No longer fetching storeRef separately
        // const storeRef = db.collection('stores').doc(selectedStoreId); 

        const settingsSnap = await settingsRef.get();

        if (settingsSnap.exists) {
            settingsData = settingsSnap.data();
            // --- Store List Parsing (Server-side) ---
            if (settingsData.storeListString) {
                 const parsedStores = parseStoreListStringServer(settingsData.storeListString); 
                 // Find the data for the selected store
                 storeData = parsedStores.find(store => store.id === selectedStoreId); 
                 if (storeData) {
                      logger.info(`Found location data for selected store ${selectedStoreId} from storeListString.`);
                      // Check if lat/lon exist (should be handled by parser)
                      if (storeData.latitude == null || storeData.longitude == null) {
                           logger.error(`Parsed store data for ${selectedStoreId} is missing latitude/longitude.`);
                           throw new HttpsError('internal', `�??後�??��?資�? (${selectedStoreId}) 缺�?位置資�??�`);
                      }
                 } else {
                      logger.error(`Selected storeId ${selectedStoreId} not found in parsed storeListString.`);
                      throw new HttpsError('not-found', `?�系統設定中?��??��??��?�?(${selectedStoreId}) ?��?置�??�。`);
                 }
            } else {
                 logger.error("'storeListString' field missing in settings/store_config. Cannot verify location.");
                 throw new HttpsError('failed-precondition', '系統缺�?必�??��?店�?表設定�??��?驗�?位置??);
            }
            // --- End Store List Parsing ---

            parsedRadii = parseGeofenceRadiiServer(settingsData.storeGeofenceRadius);
            parsedHours = parseOperatingHoursServer(settingsData.storeOperatingHours);
            logger.info(`Fetched and parsed clockin settings for store ${selectedStoreId}.`);
        } else {
            // Changed warning message to reflect the new source
            logger.warn("Main settings document (settings/store_config) not found. Assuming no restrictions.");
            // If settings doc is missing, we also lack storeListString, so throw error.
            throw new HttpsError('failed-precondition', '?��??�主要設定�?�?(settings/store_config)，無法進�??�卡驗�???);
        }

        // REMOVED: Logic that fetched storeSnap separately
        /*
        if (storeSnap.exists) {
            storeData = storeSnap.data();
            // ASSUMPTION: Store document has 'latitude' and 'longitude' fields
            if (storeData.latitude == null || storeData.longitude == null) {
                 logger.error(`Store data for ${selectedStoreId} is missing latitude/longitude.`);
                 throw new HttpsError('failed-precondition', `?�?��?�?(${selectedStoreId}) 缺�?位置資�?，無法�?證�??�。`);
            }
        } else {
            logger.error(`Store document not found for ID: ${selectedStoreId}`);
            throw new HttpsError('not-found', `?��??��??��?�?(${selectedStoreId}) ?��??�。`);
        }
        */

    } catch (error) {
        logger.error(`Error fetching settings or store data for ${selectedStoreId}:`, error);
        if (error instanceof HttpsError) throw error;
        throw new HttpsError('internal', '讀?��??�設定�??��?資�??�發?�錯誤�?);
    }
    // --- End ?��?讀??---


    // --- ?��?：伺?�器端�?�?--- 
    // 1. ?��?驗�?
    const radiusLimit = parsedRadii[selectedStoreId] ?? UNLIMITED_RADIUS_SERVER;
    if (radiusLimit !== UNLIMITED_RADIUS_SERVER) {
        if (!userLocation || userLocation.latitude == null || userLocation.longitude == null) {
             logger.warn(`recordClockEvent: Geofence check failed for ${userId} at ${selectedStoreId} - Location data missing from request.`);
             throw new HttpsError('invalid-argument', '?�卡範�??�要�?證�?但�?求中缺�??��?位置資�???);
        }
        const distance = calculateDistance(
            userLocation.latitude,
            userLocation.longitude,
            storeData.latitude,
            storeData.longitude
        );
        logger.info(`Geofence check for ${userId} at ${selectedStoreId}: Distance=${distance.toFixed(1)}m, Limit=${radiusLimit}m`);
        if (distance > radiusLimit) {
            logger.warn(`recordClockEvent: Geofence check failed for ${userId}. Distance ${distance.toFixed(1)}m > Limit ${radiusLimit}m.`);
            // Use storeData.name if available, otherwise storeId
            const storeDisplayName = storeData?.name || selectedStoreId;
            throw new HttpsError('failed-precondition', `?�目?��???"${storeDisplayName}" (${distance.toFixed(0)}�? 超出?�許?��??��???(${radiusLimit}�??�`);
        }
    } else {
         logger.info(`Geofence check skipped for ${userId} at ${selectedStoreId} (unlimited radius).`);
    }

    // 2. ?�業?��?驗�?
    const storeOperatingHoursList = parsedHours[selectedStoreId]; // Get the list of ranges for this store
    if (storeOperatingHoursList && storeOperatingHoursList.length > 0) { // Only check if hours are defined
        if (!isWithinOperatingHoursServer(storeOperatingHoursList)) {
            logger.warn(`recordClockEvent: Operating hours check failed for ${userId} at ${selectedStoreId}.`);
             const hoursString = storeOperatingHoursList.map(r => `${String(r.start.hours).padStart(2,'0')}:${String(r.start.minutes).padStart(2,'0')}-${String(r.end.hours).padStart(2,'0')}:${String(r.end.minutes).padStart(2,'0')}`).join(', ');
             const storeDisplayName = storeData?.name || selectedStoreId;
            throw new HttpsError('failed-precondition', `?��??��?不在 "${storeDisplayName}" ?��??��??�內 (?�許: ${hoursString})?�`);
        }
        logger.info(`Operating hours check passed for ${userId} at ${selectedStoreId}.`);
    } else {
        logger.info(`Operating hours check skipped for ${userId} at ${selectedStoreId} (no hours defined).`);
    }
    // --- End 伺�??�端驗�? ---

    // 2. ?��??�戶資�? (?�選，用?��??��??��?)
    let userName = '?�知?�戶';
    try {
        const userRecord = await auth.getUser(userId);
        userName = userRecord.displayName || userRecord.email || userId; // Use display name, email, or UID
        // ?�者�? Firestore ??'employees' ??'users' ?��??��??�詳細�???        // const employeeDoc = await db.collection('employees').doc(userId).get();
        // if (employeeDoc.exists) {
        //     userName = employeeDoc.data().name || userName;
        // }
    } catch (error) {
        logger.error(`recordClockEvent: Error fetching user data for ${userId}:`, error);
        // Decide if this is critical. If not, continue with default userName.
    }

    // 3. 決�??��??��??��???    let determinedAction = 'clockIn'; // 默�??��???    try {
        const lastRecordSnapshot = await db.collection('clock_records')
            .where('userId', '==', userId)
            .orderBy('timestamp', 'desc')
            .limit(1)
            .get();

        if (!lastRecordSnapshot.empty) {
            const lastRecord = lastRecordSnapshot.docs[0].data();
            if (lastRecord.action === 'clockIn') {
                determinedAction = 'clockOut'; // 如�?上�?筆是上班，這次就是下班
            }
            // 如�?上�?筆是下班，這次仍然?��???(determinedAction ?��???
        }
        logger.info(`recordClockEvent: Determined action for ${userId}: ${determinedAction}`);
    } catch (error) {
        logger.error(`recordClockEvent: Error fetching last clock record for ${userId}:`, error);
        throw new HttpsError('internal', '讀?��?次�??��??��??�錯，無法確定�?作�?);
    }

    // 4. 準�??�卡記�??��?
    const serverTimestamp = FieldValue.serverTimestamp(); // Use server timestamp for the record
    const clockRecordData = {
        userId: userId,
        userName: userName, // Use fetched username
        action: determinedAction, // 'clockIn' or 'clockOut'
        timestamp: serverTimestamp, // IMPORTANT: Use server time
        source: 'web_app', // Mark the source
        storeId: selectedStoreId, // --- ADDED: Record the store ID --- 
        location: request.data.location || null, // Optional location data from client
        // validatedLocationId: request.data.validatedLocationId || null // This was likely meant for client-side info, server validation is done above
        // status field will be added below if it's a clock-in
    };

    // 5. 如�??��??��??��??�試?�斷並�??��???(準�?/?�到)
    if (determinedAction === 'clockIn') {
        try {
            // We need the actual time the server timestamp will resolve to for comparison
            // This requires an extra step: write first, then get the timestamp, then update.
            // OR: Make an assumption about server time skew (less accurate) or use client time for status check only (less secure).
            // Let's try a different approach: Use client time for status check only IF provided AND seems reasonable.
            // Or even better: Let's just record the schedule startTime here, and let the check function compare later? No, let's try to determine status now.

            // Workaround: Create a JS Date object representing approx server time NOW for comparison.
            // Note: This is NOT the exact timestamp saved, but usually close enough for status check.
            const approxServerDate = new Date(); // JS Date object on the server
            const clockInDateStr = approxServerDate.toLocaleDateString('sv-SE'); // Get YYYY-MM-DD format (Swedish locale is reliable)

            logger.info(`Attempting to check schedule for ${userId} on ${clockInDateStr}`);

            // --- ASSUMPTIONS FOR SCHEDULE CHECK ---
            const SCHEDULE_COLLECTION = 'schedules';
            const USER_ID_FIELD = 'userId';
            const SCHEDULE_DATE_FIELD = 'date'; // Assumed field for YYYY-MM-DD string
            const SCHEDULE_START_TIME_FIELD = 'startTime'; // Assumed field for HH:mm string
            // --- END ASSUMPTIONS ---

            const scheduleQuery = db.collection(SCHEDULE_COLLECTION)
                                  .where(USER_ID_FIELD, '==', userId)
                                  .where(SCHEDULE_DATE_FIELD, '==', clockInDateStr)
                                  .limit(1);
            const scheduleSnapshot = await scheduleQuery.get();

            if (!scheduleSnapshot.empty) {
                const scheduleData = scheduleSnapshot.docs[0].data();
                const scheduledStartTimeStr = scheduleData[SCHEDULE_START_TIME_FIELD]; // e.g., "09:00"

                if (scheduledStartTimeStr && typeof scheduledStartTimeStr === 'string' && /^[0-2][0-9]:[0-5][0-9]$/.test(scheduledStartTimeStr)) {
                    const [schedHours, schedMinutes] = scheduledStartTimeStr.split(':').map(Number);

                    // Get clock-in time (hours and minutes) from our approximate server time
                    const clockInHours = approxServerDate.getHours();
                    const clockInMinutes = approxServerDate.getMinutes();

                    logger.info(`Comparing ClockIn Time (${clockInHours}:${clockInMinutes}) with Scheduled Start (${schedHours}:${schedMinutes})`);

                    let determinedStatus = '準�?'; // Default to on time
                    if (clockInHours > schedHours || (clockInHours === schedHours && clockInMinutes > schedMinutes)) {
                        determinedStatus = '?�到'; // Strictly later than scheduled time
                    }

                    clockRecordData.status = determinedStatus; // Add status field
                    logger.info(`Determined clock-in status for ${userId} as: ${determinedStatus}`);
                } else {
                    logger.warn(`Could not parse scheduled startTime '${scheduledStartTimeStr}' for user ${userId} on ${clockInDateStr}. Status not set.`);
                }
            } else {
                logger.warn(`No schedule found for user ${userId} on ${clockInDateStr}. Status not set.`);
            }
        } catch (error) {
            logger.error(`Error checking schedule during clock-in for user ${userId}:`, error);
            // Proceed without status if schedule check fails
        }
    }

    // 6. 寫入 Firestore (Now potentially includes status)
    try {
        // Write the clock record
        const recordRef = await db.collection('clock_records').add(clockRecordData);
        logger.info(`Successfully recorded ${determinedAction} for ${userId}. Record ID: ${recordRef.id}. Status: ${clockRecordData.status || 'N/A'}`);

        // Optionally update employee document with last clock action and timestamp
        const employeeRef = db.collection('employees').doc(userId);
        const updateData = {
            lastClockAction: determinedAction,
            [`last${determinedAction.charAt(0).toUpperCase() + determinedAction.slice(1)}Timestamp`]: serverTimestamp // Use the actual server timestamp here
        };
        await employeeRef.set(updateData, { merge: true });
        logger.info(`Updated employee status for ${userId}.`);

        // 7. 返�??��??��?給�?�?        return { status: 'success', action: determinedAction };

    } catch (error) {
        logger.error(`Error writing clock record or updating employee for ${userId}:`, error);
        throw new HttpsError('internal', '寫入?�卡記�??�更?�員工�??��??�錯??);
    }
});

// --- ?��?：�??�函?��?計�?距離 (Haversine) ---
function calculateDistance(lat1, lon1, lat2, lon2) {
    if (lat1 == null || lon1 == null || lat2 == null || lon2 == null) {
        return Infinity; // Cannot calculate if coordinates are missing
    }
    const R = 6371e3; // metres
    const ?1 = lat1 * Math.PI / 180; // ?, λ in radians
    const ?2 = lat2 * Math.PI / 180;
    const ?? = (lat2 - lat1) * Math.PI / 180;
    const ?λ = (lon2 - lon1) * Math.PI / 180;

    const a = Math.sin(?? / 2) * Math.sin(?? / 2) +
        Math.cos(?1) * Math.cos(?2) *
        Math.sin(?λ / 2) * Math.sin(?λ / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    return R * c; // in metres
}

// --- ?��?：解?��?徑設定�?輔助?�數 (Server-side version) ---
function parseGeofenceRadiiServer(radiiString) {
    const radii = {};
    if (!radiiString || typeof radiiString !== 'string') return radii;

    radiiString.split(';').forEach(part => {
        part = part.trim();
        if (!part) return;
        const match = part.match(/^([^0-9]+)(\d+)?$/);
        if (match) {
            const storeName = match[1].trim();
            const radiusValue = match[2] ? parseInt(match[2], 10) : UNLIMITED_RADIUS_SERVER;
            if (storeName) {
                 radii[storeName] = isNaN(radiusValue) ? UNLIMITED_RADIUS_SERVER : radiusValue;
            }
        } else if (/^[^0-9]+$/.test(part)) {
             const storeName = part.trim();
             if(storeName) radii[storeName] = UNLIMITED_RADIUS_SERVER;
        }
    });
    return radii;
}

// --- ?��?：解?��?業�??�設定�?輔助?�數 (Server-side version) ---
function parseOperatingHoursServer(hoursString) {
    const hours = {};
    if (!hoursString || typeof hoursString !== 'string') return hours;

    hoursString.split(';').forEach(part => {
        part = part.trim();
        if (!part) return;
        const firstDigitIndex = part.search(/\d/);
        let storeName = '';
        let timeRangesStr = '';
        if (firstDigitIndex > 0) {
             storeName = part.substring(0, firstDigitIndex).trim();
             timeRangesStr = part.substring(firstDigitIndex).trim();
        } else if (firstDigitIndex === -1 && /^[^,;-]+$/.test(part)){
             storeName = part.trim();
             timeRangesStr = '';
        } else {
             return;
        }
        if (!storeName) return;
        const timeRanges = [];
        if (timeRangesStr) {
            timeRangesStr.split(',').forEach(rangeStr => {
                rangeStr = rangeStr.trim();
                const times = rangeStr.split('-');
                if (times.length === 2) {
                    const startStr = times[0].trim();
                    const endStr = times[1].trim();
                    if (/^\d{4}$/.test(startStr) && /^\d{4}$/.test(endStr)) {
                        try {
                             const startH = parseInt(startStr.substring(0, 2), 10);
                             const startM = parseInt(startStr.substring(2, 4), 10);
                             const endH = parseInt(endStr.substring(0, 2), 10);
                             const endM = parseInt(endStr.substring(2, 4), 10);
                             if (startH >= 0 && startH < 24 && startM >= 0 && startM < 60 &&
                                 endH >= 0 && endH < 24 && endM >= 0 && endM < 60) {
                                timeRanges.push({ start: { hours: startH, minutes: startM }, end: { hours: endH, minutes: endM } });
                             } else { logger.warn(`Invalid time range values in "${rangeStr}" for store "${storeName}"`); }
                        } catch (e) { logger.warn(`Error parsing time range "${rangeStr}" for store "${storeName}":`, e); }
                    } else { logger.warn(`Invalid HHMM format in "${rangeStr}" for store "${storeName}"`); }
                } else { logger.warn(`Invalid time range format (no '-') in "${rangeStr}" for store "${storeName}"`); }
            });
        }
         hours[storeName] = timeRanges;
    });
    return hours;
}

// --- ?��?：檢?�是?�在?�業?��??��??�數 (Server-side version, uses JS Date) ---
function isWithinOperatingHoursServer(storeHoursList) {
     if (!storeHoursList || storeHoursList.length === 0) {
         return true; // No hours defined = always allowed
     }

     const now = new Date(); // Server's current time
     const currentMinutes = now.getHours() * 60 + now.getMinutes();

     for (const range of storeHoursList) {
         const startMinutes = range.start.hours * 60 + range.start.minutes;
         let endMinutes = range.end.hours * 60 + range.end.minutes;
         if (endMinutes < startMinutes) { // Overnight range
             if (currentMinutes >= startMinutes || currentMinutes < endMinutes) {
                 return true;
             }
         } else { // Normal range
             if (currentMinutes >= startMinutes && currentMinutes < endMinutes) {
                 return true;
             }
         }
     }
     return false; // Not within any range
}

// --- End of New Helpers ---

// --- ADDED: Server-side parser for storeListString --- 
function parseStoreListStringServer(storeString) {
     const locations = [];
     if (!storeString || typeof storeString !== 'string') return locations;
     storeString.split(';').forEach(part => {
          part = part.trim();
          if (!part) return;
          const eqIndex = part.indexOf('=');
          if (eqIndex === -1) return;
          const namePart = part.substring(0, eqIndex).trim();
          const coordsPart = part.substring(eqIndex + 1).trim();
          const nameMatch = namePart.match(/^([^0-9]+)/);
          const storeName = nameMatch ? nameMatch[1].trim() : namePart;
          const coords = coordsPart.split(',');
          if (coords.length === 2) {
               const lat = parseFloat(coords[0].trim());
               const lon = parseFloat(coords[1].trim());
               if (!isNaN(lat) && !isNaN(lon) && storeName) {
                    locations.push({ id: storeName, name: storeName, latitude: lat, longitude: lon });
               }
          }
     });
     return locations;
}
// --- End of Added Helper ---

/**
 * Main function to check a single condition. Routes based on type.
 * Called by evaluateTaskForEmployee.
 *
 * Determines the evaluation month string (YYYY-MM) based on config.
 * @param {object} evaluationConfig - The evaluation config object from the bonus task.
 * @returns {string|null} - YYYY-MM string or null if config is invalid or type isn't MONTHLY.
 */
function getEvaluationMonthString(evaluationConfig) {
    logger.warn(`使用已�??��? getEvaluationMonthString ?��?定義?��??�新調用以使?��???066行�??��??�數?�`);
    // 調用?��??�數以�??��??��?    if (typeof global.getEvaluationMonthString === 'function') {
        return global.getEvaluationMonthString(evaluationConfig);
    }
    
    // ?��?保�?實現?�輯，以?�萬一?��??�全局?�數
    if (!evaluationConfig || evaluationConfig.triggerType !== 'MONTHLY') {
        logger.warn("Cannot get evaluation month: Invalid config or triggerType is not MONTHLY.", { evaluationConfig });
        return null;
    }
    try {
        const currentDate = new Date();
        // If we have a specific month in the config, use it
        if (evaluationConfig.targetMonth) {
            return evaluationConfig.targetMonth;
        }
        
        // Otherwise calculate from the current date
        const targetMonth = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;
        logger.info(`Using current month for evaluation: ${targetMonth}`);
        return targetMonth;
    } catch (error) {
        logger.error("Error determining evaluation month:", error);
        return null;
    }
}

/**
 * Function to check a single condition. Routes based on type.
 * Called by evaluateTaskForEmployee.
 * @param {string} userId - The employee ID
 * @param {object} condition - The condition to check
 * @param {object} taskData - Additional task data
 * @returns {object} Result containing condition, passed flag, and dataValue
 */
function checkCondition(userId, condition, taskData) {
    if (!condition || !condition.type) {
        logger.error(`Invalid condition for user ${userId}:`, condition);
        return { condition, passed: false, dataValue: null, error: 'Invalid condition format' };
    }

    let result;
    try {
        switch (condition.type) {
            case 'ATTENDANCE':
                result = checkAttendanceCondition(userId, condition, taskData);
                break;
            case 'SALES':
                result = checkSalesCondition(userId, condition, taskData);
                break;
            default:
                logger.warn(`Unsupported condition type "${condition.type}" for user ${userId}`);
                result = { condition, passed: false, dataValue: null, error: 'Unsupported condition type' };
        }
    } catch (error) {
        logger.error(`Error checking condition for user ${userId}:`, error, { condition });
        result = { condition, passed: false, dataValue: null, error: error.message };
    }
    
    logger.info(`Condition check final result for user ${userId}:`, result);
    return result; // Return the object containing condition, passed, and dataValue
}

// ?��?保�??��??�容，添?�別??const checkSingleCondition = checkCondition;

/**
 * Scheduled function to calculate monthly payrolls.
 * Triggered at the end of each month to process all active employees.
 */
exports.calculatePayrollScheduled = onSchedule({
    schedule: "0 1 1 * *", // Runs at 1:00 AM on the 1st day of each month
    timeZone: "Asia/Taipei",
    timeoutSeconds: 540, // Max timeout for scheduled functions
    memory: '1GiB' // Adjust memory if needed
}, async (event) => {
    logger.info("Starting scheduled payroll calculation run...");
    const startTime = Date.now();
    
    try {
        // ?��?上個�???YYYY-MM ?��?
        const now = new Date();
        const lastMonth = new Date(now.getFullYear(), now.getMonth(), 0); // Last day of previous month
        const targetMonth = `${lastMonth.getFullYear()}-${String(lastMonth.getMonth() + 1).padStart(2, '0')}`;
        
        logger.info(`Calculating payroll for month: ${targetMonth}`);
        await runPayrollCalculation(targetMonth);
        
        const duration = Date.now() - startTime;
        logger.info(`Payroll calculation completed in ${duration}ms for month ${targetMonth}`);
        await logActivity({ 
            userId: 'system', 
            feature: 'Payroll', 
            action: 'calculatePayrollScheduledComplete', 
            details: `Calculated payroll for month ${targetMonth} in ${duration}ms`, 
            success: true 
        });
    } catch (error) {
        const duration = Date.now() - startTime;
        logger.error("Critical error during payroll calculation:", error);
        await logActivity({ 
            userId: 'system', 
            feature: 'Payroll', 
            action: 'calculatePayrollScheduledError', 
            details: `Failed after ${duration}ms: ${error.message}`, 
            success: false 
        });
    }
});

/**
 * Main function to calculate payroll for all employees for a specific month.
 * @param {string} targetMonth - The target month in format 'YYYY-MM'.
 * @returns {Promise<void>}
 */
async function runPayrollCalculation(targetMonth) {
    // �???��??�份
    const [year, month] = targetMonth.split('-').map(Number);
    if (!year || !month || month < 1 || month > 12) {
        logger.error(`Invalid target month format: ${targetMonth}`);
        throw new Error(`Invalid target month format: ${targetMonth}`);
    }
    
    // 設�??�份?��?始�?結�??��?
    const startDate = new Date(year, month - 1, 1, 0, 0, 0, 0); // First day of month
    const endDate = new Date(year, month, 0, 23, 59, 59, 999); // Last day of month
    
    logger.info(`Calculating payroll for period: ${startDate.toISOString()} to ${endDate.toISOString()}`);
    
    // 1. ?��??��??�置
    const payrollConfig = await getPayrollConfig();
    if (!payrollConfig) {
        throw new Error("Failed to retrieve payroll configuration");
    }
    
    // 2. ?��??�?�活躍員�?    const employeesSnapshot = await db.collection('employees')
        .where('isActive', '==', true)
        .get();
    
    if (employeesSnapshot.empty) {
        logger.info("No active employees found.");
        return;
    }
    
    logger.info(`Found ${employeesSnapshot.size} active employees for payroll calculation.`);
    
    // 3. ?�次?��?每個員�?    const batchSize = 10; // ?��??��??�員工數??    const employees = [];
    employeesSnapshot.forEach(doc => {
        employees.push({ id: doc.id, ...doc.data() });
    });
    
    for (let i = 0; i < employees.length; i += batchSize) {
        const batch = employees.slice(i, i + batchSize);
        await Promise.all(batch.map(employee => 
            calculateEmployeePayroll(employee, targetMonth, startDate, endDate, payrollConfig)
        ));
        logger.info(`Processed ${Math.min(i + batchSize, employees.length)} of ${employees.length} employees`);
    }
}

/**
 * Get payroll configuration from Firestore.
 * @returns {Promise<object|null>} - Payroll configuration or null if not found.
 */
async function getPayrollConfig() {
    try {
        const configDoc = await db.collection('settings').doc('payroll_config').get();
        if (!configDoc.exists) {
            logger.warn("Payroll configuration not found, using defaults");
            return {
                defaultHourlyRate: 200, // ?�設?�薪 (TWD)
                overtimeMultiplier: 1.33, // ?�班費倍�?
                laborInsuranceRate: 0.2, // ?��?費�? (20%)
                healthInsuranceRate: 0.0469 // ?��?費�? (4.69%)
            };
        }
        return configDoc.data();
    } catch (error) {
        logger.error("Error retrieving payroll configuration:", error);
        return null;
    }
}

/**
 * Calculate payroll for a single employee.
 * @param {object} employee - Employee data.
 * @param {string} targetMonth - Target month in format 'YYYY-MM'.
 * @param {Date} startDate - Start date of the month.
 * @param {Date} endDate - End date of the month.
 * @param {object} payrollConfig - Payroll configuration.
 * @returns {Promise<void>}
 */
async function calculateEmployeePayroll(employee, targetMonth, startDate, endDate, payrollConfig) {
    const employeeId = employee.id;
    const employeeName = employee.displayName || employee.name || employeeId;
    logger.info(`Calculating payroll for employee: ${employeeName} (${employeeId}) for ${targetMonth}`);
    
    try {
        // 1. ?��??�勤?��?
        const attendanceSummary = await calculateAttendanceSummary(employeeId, startDate, endDate);
        
        // 2. ?��?休�??��?
        const leaveSummary = await calculateLeaveSummary(employeeId, startDate, endDate);
        
        // 3. ?��??��??��?
        const bonusSummary = await calculateBonusSummary(employeeId, targetMonth);
        
        // 4. 計�??��?
        // ?�本工�?
        const baseHourlyRate = employee.hourlyRate || payrollConfig.defaultHourlyRate;
        const baseSalaryPay = attendanceSummary.regularHours * baseHourlyRate;
        
        // ?�班�?        const overtimeRate = baseHourlyRate * payrollConfig.overtimeMultiplier;
        const overtimePay = attendanceSummary.overtimeHours * overtimeRate;
        
        // 總工�?        const totalSalary = baseSalaryPay + overtimePay + bonusSummary.totalBonus;
        
        // ??��?�目 (?��??�健保�?)
        const laborInsurance = totalSalary * payrollConfig.laborInsuranceRate;
        const healthInsurance = totalSalary * payrollConfig.healthInsuranceRate;
        const totalDeductions = laborInsurance + healthInsurance;
        
        // 淨工�?        const netSalary = totalSalary - totalDeductions;
        
        // 5. ?��?計�?結�?
        await savePayrollRecord(employeeId, targetMonth, {
            employeeId,
            employeeName,
            targetMonth,
            calculatedAt: new Date(),
            attendance: attendanceSummary,
            leave: leaveSummary,
            bonus: bonusSummary,
            salary: {
                baseHourlyRate,
                baseSalaryPay,
                overtimePay,
                totalSalary,
                deductions: {
                    laborInsurance,
                    healthInsurance,
                    totalDeductions
                },
                netSalary
            }
        });
        
        logger.info(`Completed payroll calculation for ${employeeName} (${employeeId}): ${netSalary} TWD`);
    } catch (error) {
        logger.error(`Error calculating payroll for employee ${employeeId}:`, error);
        throw error;
    }
}

/**
 * Save payroll record to Firestore.
 * @param {string} employeeId - Employee ID.
 * @param {string} targetMonth - Target month in format 'YYYY-MM'.
 * @param {object} payrollData - Calculated payroll data.
 * @returns {Promise<void>}
 */
async function savePayrollRecord(employeeId, targetMonth, payrollData) {
    try {
        const payrollRef = db.collection('payrolls').doc(`${employeeId}_${targetMonth}`);
        await payrollRef.set(payrollData, { merge: true });
        logger.info(`Saved payroll record for employee ${employeeId} for month ${targetMonth}`);
    } catch (error) {
        logger.error(`Error saving payroll record for employee ${employeeId}:`, error);
        throw error;
    }
}

/**
 * Calculate attendance summary for an employee.
 * @param {string} employeeId - Employee ID.
 * @param {Date} startDate - Start date of the month.
 * @param {Date} endDate - End date of the month.
 * @returns {Promise<Object>} - Attendance summary.
 */
async function calculateAttendanceSummary(employeeId, startDate, endDate) {
    try {
        logger.info(`Calculating attendance summary for employee ${employeeId} from ${startDate.toISOString()} to ${endDate.toISOString()}`);
        
        // ?�詢?�勤記�?
        const clockRecordsQuery = db.collection('clock_records')
                                 .where('userId', '==', employeeId)
                                 .where('timestamp', '>=', startDate)
                                 .where('timestamp', '<=', endDate);
        const clockRecordsSnapshot = await clockRecordsQuery.get();
        const clockRecords = [];
        clockRecordsSnapshot.forEach(doc => clockRecords.push(doc.data()));
        
        // ?�詢?�班記�?
        const scheduleQuery = db.collection('schedules')
                           .where('userId', '==', employeeId)
                           .where('date', '>=', startDate.toISOString().split('T')[0])
                           .where('date', '<=', endDate.toISOString().split('T')[0]);
        const scheduleSnapshot = await scheduleQuery.get();
        const scheduleRecords = [];
        scheduleSnapshot.forEach(doc => scheduleRecords.push(doc.data()));
        
        // 計�??��?
        let regularHours = 0;
        let overtimeHours = 0;
        let lateCount = 0;
        let absenceDays = 0;
        let onTimeCount = 0;
        let totalWorkDays = 0;
        
        // 建�??�班工�??��?�?        const scheduledWorkDaysMap = new Map();
        const clockedDaysMap = new Map();
        
        scheduleRecords.forEach(schedule => {
            if (schedule.shift !== '�?) {
                totalWorkDays++;
                scheduledWorkDaysMap.set(schedule.date, {
                    shift: schedule.shift,
                    store: schedule.store
                });
            }
        });
        
        // ?��??�卡記�?
        clockRecords.forEach(record => {
            try {
                const recordTimestamp = record.timestamp;
                if (recordTimestamp && recordTimestamp.toDate) {
                    const recordDate = recordTimestamp.toDate();
                    const recordDateStr = recordDate.toISOString().split('T')[0];
                    
                    if (!clockedDaysMap.has(recordDateStr)) {
                        clockedDaysMap.set(recordDateStr, []);
                    }
                    clockedDaysMap.get(recordDateStr).push(record);
                    
                    // 計�??�到?��???                    if (scheduledWorkDaysMap.has(recordDateStr)) {
                        // ?�斷?�到?��???                        if (record.status === '?�到') {
                            lateCount++;
                        } else if (record.status === '準�?') {
                            onTimeCount++;
                        }
                        
                        // 計�?工�?（�?設�??�班�?小�?�?                        const shiftHours = 8; // ?�本工�?，可以根?�班次�??�調??                        regularHours += shiftHours;
                        
                        // 計�??�班?��?（�??��?�?                        if (record.overtimeHours) {
                            overtimeHours += parseFloat(record.overtimeHours);
                        }
                    }
                }
            } catch (e) {
                logger.warn(`Error processing clock record for attendance summary: ${e.message}`, e);
            }
        });
        
        // 計�?缺勤天數
        scheduledWorkDaysMap.forEach((shiftInfo, dateStr) => {
            if (!clockedDaysMap.has(dateStr)) {
                absenceDays++;
            }
        });
        
        // 計�??�勤??        const onTimeRate = totalWorkDays > 0 ? onTimeCount / totalWorkDays : 0;
        
        // 構建並�??��?�?        const summary = {
            totalWorkDays,
            regularHours,
            overtimeHours,
            lateCount,
            absenceDays,
            onTimeCount,
            onTimeRate,
            period: {
                startDate: startDate.toISOString(),
                endDate: endDate.toISOString()
            }
        };
        
        logger.info(`Completed attendance summary calculation for ${employeeId}: ${JSON.stringify(summary)}`);
        return summary;
    } catch (error) {
        logger.error(`Error calculating attendance summary for employee ${employeeId}:`, error);
        // 返�??�設?�以?��?系統崩潰
        return {
            totalWorkDays: 0,
            regularHours: 0,
            overtimeHours: 0,
            lateCount: 0,
            absenceDays: 0,
            onTimeCount: 0,
            onTimeRate: 0,
            period: {
                startDate: startDate.toISOString(),
                endDate: endDate.toISOString()
            },
            error: error.message
        };
    }
}

/**
 * Calculate leave summary for an employee.
 * @param {string} employeeId - Employee ID.
 * @param {Date} startDate - Start date of the month.
 * @param {Date} endDate - End date of the month.
 * @returns {Promise<Object>} - Leave summary.
 */
async function calculateLeaveSummary(employeeId, startDate, endDate) {
    try {
        logger.info(`Calculating leave summary for employee ${employeeId} from ${startDate.toISOString()} to ${endDate.toISOString()}`);
        
        const startDateStr = startDate.toISOString().split('T')[0];
        const endDateStr = endDate.toISOString().split('T')[0];
        const monthStr = startDateStr.substring(0, 7); // 'YYYY-MM'
        
        // ?�詢請�?記�?
        const leaveRequestsQuery = db.collection('leave_requests')
                                .where('employeeId', '==', employeeId)
                                .where('month', '==', monthStr);
        const leaveRequestsSnapshot = await leaveRequestsQuery.get();
        
        // 如�?沒�?請�?記�?，�??��?設�?        if (leaveRequestsSnapshot.empty) {
            return {
                totalLeaveDays: 0,
                leaveTypes: {},
                leaveDates: [],
                period: {
                    startDate: startDate.toISOString(),
                    endDate: endDate.toISOString()
                }
            };
        }
        
        // ?��?請�?記�?
        let totalLeaveDays = 0;
        const leaveTypes = {};
        const leaveDates = [];
        
        leaveRequestsSnapshot.forEach(doc => {
            const leaveRequest = doc.data();
            const selectedDates = leaveRequest.selected_dates || [];
            
            // ?��?算在?��??�份?��?請�??��?
            const validDates = selectedDates.filter(dateStr => 
                dateStr >= startDateStr && dateStr <= endDateStr
            );
            
            totalLeaveDays += validDates.length;
            leaveDates.push(...validDates);
            
            // 統�?請�?類�?
            const leaveType = leaveRequest.leave_type || '一?��?';
            leaveTypes[leaveType] = (leaveTypes[leaveType] || 0) + validDates.length;
        });
        
        // 構建並�??��?�?        const summary = {
            totalLeaveDays,
            leaveTypes,
            leaveDates,
            period: {
                startDate: startDate.toISOString(),
                endDate: endDate.toISOString()
            }
        };
        
        logger.info(`Completed leave summary calculation for ${employeeId}: ${JSON.stringify(summary)}`);
        return summary;
    } catch (error) {
        logger.error(`Error calculating leave summary for employee ${employeeId}:`, error);
        // 返�??�設?�以?��?系統崩潰
        return {
            totalLeaveDays: 0,
            leaveTypes: {},
            leaveDates: [],
            period: {
                startDate: startDate.toISOString(),
                endDate: endDate.toISOString()
            },
            error: error.message
        };
    }
}

/**
 * Calculate bonus summary for an employee.
 * @param {string} employeeId - Employee ID.
 * @param {string} targetMonth - Target month in format 'YYYY-MM'.
 * @returns {Promise<Object>} - Bonus summary.
 */
async function calculateBonusSummary(employeeId, targetMonth) {
    try {
        logger.info(`Calculating bonus summary for employee ${employeeId} for month ${targetMonth}`);
        
        // ?�詢?��?記�?
        const progressDocId = `${employeeId}_${targetMonth}`;
        const progressDoc = await db.collection('employee_bonus_progress').doc(progressDocId).get();
        
        // 如�?沒�??��?記�?，�??��?設�?        if (!progressDoc.exists) {
            return {
                totalBonus: 0,
                bonusItems: [],
                targetMonth
            };
        }
        
        // ?��??��?記�?
        const progressData = progressDoc.data();
        const tasks = progressData.tasks || [];
        let totalBonus = 0;
        const bonusItems = [];
        
        tasks.forEach(taskResult => {
            if (taskResult.status === 'PASSED' && typeof taskResult.rewardEarned === 'number') {
                totalBonus += taskResult.rewardEarned;
                bonusItems.push({
                    taskId: taskResult.taskId,
                    taskName: taskResult.taskName,
                    reward: taskResult.rewardEarned,
                    evaluationDate: taskResult.evaluationDate
                });
            }
        });
        
        // 構建並�??��?�?        const summary = {
            totalBonus,
            bonusItems,
            targetMonth
        };
        
        logger.info(`Completed bonus summary calculation for ${employeeId}: ${JSON.stringify(summary)}`);
        return summary;
    } catch (error) {
        logger.error(`Error calculating bonus summary for employee ${employeeId}:`, error);
        // 返�??�設?�以?��?系統崩潰
        return {
            totalBonus: 0,
            bonusItems: [],
            targetMonth,
            error: error.message
        };
    }
}

/**
 * Compares two values using a specified operator.
 * @param {*} actual - The actual data value from the employee/system.
 * @param {*} operator - The comparison operator (e.g., '>=', '<=', '==').
 * @param {*} target - The target value from the condition definition.
 * @returns {boolean} - True if the comparison holds, false otherwise.
 */
function compareValuesExtended(actual, operator, target) {
    logger.debug(`Comparing values: ${actual} ${operator} ${target}`);
    // Basic type coercion for comparison (may need refinement)
    const numActual = Number(actual);
    const numTarget = Number(target);
    const useNumeric = !isNaN(numActual) && !isNaN(numTarget);

    try {
        switch (operator) {
            case '>=':
                return useNumeric ? numActual >= numTarget : actual >= target;
            case '<=':
                return useNumeric ? numActual <= numTarget : actual <= target;
            case '==':
                // Be careful with type coercion for '=='
                 return useNumeric ? numActual === numTarget : String(actual) === String(target);
            case '!=':
                return useNumeric ? numActual !== numTarget : String(actual) !== String(target);
            case '>':
                return useNumeric ? numActual > numTarget : actual > target;
            case '<':
                return useNumeric ? numActual < numTarget : actual < target;
            default:
                logger.warn(`Unsupported operator: ${operator}`);
                return false;
        }
    } catch (error) {
        logger.error("Error during value comparison:", error, { actual, operator, target });
        return false;
    }
}

// 為了保持向後兼容，添加別名
const compareValues_extended = compareValuesExtended;

}); // 閉合 exports.calculatePayrollScheduled 函數

